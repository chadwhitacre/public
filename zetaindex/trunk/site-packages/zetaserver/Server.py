import Queue
import inspect
import os
import signal
import sys
import threading
import time
from ThreadingXMLRPCServer import *
from optparse import OptionParser
from xmlrpclib import ServerProxy

from mx import DateTime as mxdatetime
from pysqlite2 import dbapi2

import crypto_utils
import Utils # namespace clash in tests :-(
from Utils import secured, public



WRAP_SECURED = """\
def %s(self, *args, **kwargs):
    if 'signature' in kwargs:
        signature = kwargs['signature']
        del(kwargs['signature'])
    else:
        signature = args[-1]
        args = args[:-1]
    if self.check_signature(signature, args, kwargs):
        url = args[0]
        args = args[1:]
        b = self._get_blog(url)
        return b.%s(*args, **kwargs)
    else:
        raise ValueError("Greetings, program! Sorry, invalid security " +
                         "signature.")
"""

WRAP_PUBLIC = """\
def %s(self, url, *args, **kwargs):
    b = self._get_blog(url)
    return b.%s(*args, **kwargs)
"""


BaseService = Blog
class XMLRPCWrapper(type):
    """This metaclass adds API from a base service class to an XMLRPC server class.
    """

    def __init__(cls, *args, **kwargs):

        super(XMLRPCWrapper, cls).__init__(*args, **kwargs)

        dummy = BaseService('', 0)

        for funcname in dir(dummy):

            func = getattr(dummy, funcname)

            if not funcname.startswith('_') and inspect.ismethod(func):
                if not hasattr(func, 'secured'):
                    raise AttributeError("All public methods of the base " +
                                         "service class need to be decorated")
                if func.secured:
                    code_def = WRAP_SECURED % (funcname, funcname)

                else:
                    code_def = WRAP_PUBLIC % (funcname, funcname)
                exec code_def in locals()
                if not hasattr(cls, funcname):
                    setattr(cls, funcname, locals()[funcname])



class BlogServer:
    """

    Nothing in here is blog-specific afaict.

    A single *Server handles request for multiple websites. This class is
    responsible for keeping each site separate.


    """


    __metaclass__ = BlogWrapper

    def __init__(self, storage_path):
        self.storage_path = storage_path
        self.open_blogs = {}
        self.key = crypto_utils.get_key()

    def ping(self):
        return 'pong'

    def check_signature(self, signature, args, kwargs):
        signature, ts = signature
        sig_txt = str(args)+str(kwargs)+ts
        return crypto_utils.verify_signature(sig_txt, signature, self.key)

    def _get_blog(self, url):
        if url in self.open_blogs:
            blog = self.open_blogs[url]
        else:
            db_path = os.path.join(self.storage_path, url, 'blog.sql')
            blog = Blog(db_path)
            self.open_blogs[url] = blog
        return blog

    def _close_blog(self, url):
        if url in self.open_blogs:
            blog = self.open_blogs[url]
            blog._close()
            del(self.open_blogs[url])

    def _shutdown(self):
        old_keys = self.open_blogs.keys()
        for url in old_keys:
            self._close_blog(url)



class ServerManager:

    def __init__(self):
        self.DIE = threading.Event()
        self.parse_options()
        self.setup_log()
        self.setup_pidfile()
        self.setup_handlers()
        self.create_servers()
        self.register_all_public_funcs()

    def parse_options(self):
        parser_ = OptionParser()
        parser_.add_option('-a', '--address', dest = 'address', type = 'str')
        parser_.add_option('-p', '--port', dest = 'port', type = 'int')
        parser_.add_option('-f', '--pidfile', dest = 'pidfile', type = 'str')
        parser_.add_option('-l', '--log', dest = 'log', type = 'str')
        parser_.add_option('-s', '--storage', dest = 'storage', type = 'str')
        parser_.add_option('-m', '--mode', dest = 'mode', type = 'int')
        parser_.add_option('-t', '--threads', dest = 'threads', type = 'int')
        parser_.set_defaults( address = '127.0.0.1'
                            , port = 8000
                            , pidfile = 'blog_server.pid'
                            , log = 'blog_server.log'
                            , storage = 'blog_storage'
                            , mode = UNTHREADED
                            , threads = 1
                             )
        self.options, args = parser_.parse_args()

    def setup_log(self):
        self.log = Utils.TimestampingPrinter(open(self.options.log, 'w', 0))
        sys.stdout = self.log
        sys.stderr = self.log

    def setup_pidfile(self):
        pidfile = open(self.options.pidfile, 'w')
        pidfile.write(str(os.getpid()))
        pidfile.close()

    def setup_handlers(self):
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

    def create_servers(self):
        self.bs = BlogServer(self.options.storage)
        if self.options.mode == UNTHREADED:
            print 'starting UNTHREADED server!'
            self.rpc = PlaceholderXMLRPCServer((self.options.address, self.options.port))
        if self.options.mode == THREADED:
            print 'starting THREADED server!'
            self.rpc = ThreadingXMLRPCServer((self.options.address, self.options.port))
        if self.options.mode == POOLED:
            print 'starting POOLED server!'
            self.rpc = PooledThreadingXMLRPCServer((self.options.address, self.options.port), threads = self.options.threads)
        self.rpc.register_function(self.bs.ping)

    def register_all_public_funcs(self):
        for funcname in dir(Blog):
            if not funcname.startswith('_'):
                print 'registering %s' % funcname
                func = getattr(self.bs, funcname)
                self.rpc.register_function(func)

    def rpc_thread_run(self):
        print 'starting!'
        while not self.DIE.isSet():
            self.rpc.handle_request()
        print 'ended infinite loop'

    def start(self):
        self.rpc_thread = threading.Thread(target = self.rpc_thread_run)
        self.rpc_thread.start()
        while True:
            time.sleep(1000000)

    def stop(self):
        print 'shutting down...'
        self.bs._shutdown()
        self.rpc.server_close()
        os.remove(self.options.pidfile)
        print 'done!'
        sys.exit(0)



    def signal_handler(self, signal, frame):
        signals = {2:'SIGINT', 15:'SIGTERM'}
        print 'SERVER MANAGER got %s'%signals[signal]
        print 'killing the rpc_thread'
        self.DIE.set()
        ServerProxy("http://%s:%s"%(self.options.address, self.options.port)).ping()
        self.stop()

