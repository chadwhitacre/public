import Queue
import SocketServer
import optparse
import os
import signal
import sys
import threading
import time
import traceback
from SimpleXMLRPCServer import SimpleXMLRPCDispatcher
from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler


class XMLRPCServer(SocketServer.TCPServer, SimpleXMLRPCDispatcher):
    """Represents an XMLRPC server.
    """

    allow_reuse_address = True
    logRequests = True

    def __init__(self, hostname='', port=5370, threadcount=1):

        # Satisfy base classes.
        # =====================
        addr = (hostname, port)
        SimpleXMLRPCDispatcher.__init__(self)
        SocketServer.TCPServer.__init__(self, addr, SimpleXMLRPCRequestHandler)

        # Set up signal handling.
        # =======================
        self.DIE = threading.Event()
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

        # Set up threading.
        # =================
        self.SHUTDOWN = object()
        self.threads = {}
        self.queue = Queue.Queue()
        self.fill_thread_pool(threadcount)


    # Public API
    # ==========

    def start(self):
        """Start the server.

        The server is actually run in a second thread, so that the main thread
        is free to listen for signals.

        """
        deputy = threading.Thread(target = self.deputy)
        deputy.start()
        while True:
            # Kick our feet up and watch for signals, AKA "varmints."
            time.sleep(1000000)

    def stop(self):
        print 'shutting down...'
        threads = self.threads.values()
        for i in range(len(threads)):
            self.queue.put(self.SHUTDOWN)
        for thread in threads:
            thread.join()
        self.socket.close()
        print 'done!'
        sys.exit(0)


    # Signal Handling
    # ===============

    def signal_handler(self, signal, frame):
        signals = {2:'SIGINT', 15:'SIGTERM'}
        print 'server got %s' % signals[signal]
        print 'killing the deputy thread'
        self.DIE.set()
        self.stop()


    # Threading
    # =========

    def fill_thread_pool(self, threadcount):
        """Given the number of threads to create, create them.
        """
        for i in range(threadcount):
            thread_ = threading.Thread( target=self.worker
                                      , args=(i,)
                                       )
            self.threads[i] = thread_
            thread_.start()

    def deputy(self):
        """Handle requests until doomsday.
        """
        print 'starting!'
        while not self.DIE.isSet():
            self.handle_request()
        print 'ended infinite loop'

    def worker(self, thread_id):
        while True:
            work = self.queue.get()
            if work is self.SHUTDOWN:
                break
            else:
                request, client_address = work
                try:
                    self.finish_request(request, client_address)
                    self.close_request(request)
                except:
                    self.handle_error(request, client_address)
                    self.close_request(request)

    def process_request(self, request, client_address):
        """Hand off to one of our pooled threads.
        """
        self.queue.put((request, client_address))
