import Queue
import optparse
import os
import signal
import socket
import sys
import threading
import time
import traceback


class Server:
    """Represents a TCP server.

    The only required parameter is a Protocol class defining the protocol that
    we are serving. This server uses a pool of threads to service requests.

    The Protocol class will be instantiated once for each connection
    established. The arguments to the constructor are the inbound stream and the
    outbound stream. It is called immediately after instantiation.

    """

    def __init__(self, Protocol, hostname='', port=5370, threadcount=1):

        # Configure the server.
        # =====================
        self.Protocol = Protocol

        # Set up signal handling.
        # =======================
        self.DIE = threading.Event()
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

        # Set up threads.
        # ===============
        self.SHUTDOWN = object()
        self.threads = {}
        self.queue = Queue.Queue()
        self.fill_thread_pool(threadcount)

        # Connect to our socket.
        # ======================
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind((hostname, port))
        self.socket.listen(5)


    # Public API
    # ==========

    def start(self):
        """Start the server.

        The server is actually run in a second thread, so that the main thread
        is free to listen for signals.

        """
        deputy = threading.Thread(target = self.deputy)
        deputy.start()
        while True:
            # Kick our feet up and watch for signals.
            time.sleep(1000000)

    def stop(self):
        print 'shutting down...'
        threads = self.threads.values()
        for i in range(len(threads)):
            self.queue.put(self.SHUTDOWN)
        for thread in threads:
            thread.join()
        self.socket.close()
        print 'done!'
        sys.exit(0)


    # Signal Handling
    # ===============

    def signal_handler(self, signal, frame):
        signals = {2:'SIGINT', 15:'SIGTERM'}
        print 'server got %s' % signals[signal]
        print 'killing the deputy thread'
        self.DIE.set()
        self.stop()


    # Threads
    # =======

    def fill_thread_pool(self, threadcount):
        """Given the number of threads to create, create them.
        """
        for i in range(threadcount):
            thread_ = threading.Thread( target=self.worker
                                      , args=(i,)
                                       )
            self.threads[i] = thread_
            thread_.start()

    def deputy(self):
        """Take requests off the wire and hand them over to work threads.
        """
        print 'starting!'
        while not self.DIE.isSet():
            try:
                work = self.socket.accept()
            except socket.error:
                return
            self.queue.put(work)
        print 'ended infinite loop'

    def worker(self, thread_id):
        """Given a thread id, work, work, work.
        """
        while True:
            work = self.queue.get()
            if work is self.SHUTDOWN:
                break
            else:
                request, client_address = work
                try:
                    self.serve_request(request, client_address)
                finally:
                    request.close()

    # buffering per SocketServer.StreamRequestHandler
    rbufsize = -1
    wbufsize = 0

    def serve_request(self, request, client_address):
        """This is where the work actually gets done.
        """
        rfile = request.makefile('rb', self.rbufsize)
        wfile = request.makefile('wb', self.wbufsize)

        try:
            protocol = self.Protocol(rfile, wfile)
            protocol()
        except:
            print (u"Failed to service request from " +
                   u"%s:%d." % client_address)
            print traceback.format_exc()

        if not wfile.closed:
            wfile.flush()
        wfile.close()
        rfile.close()

