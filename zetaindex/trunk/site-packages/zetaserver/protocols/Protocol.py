import sys

class Protocol:
    """Represent a TCP application-layer protocol.

    This is a base class for both client and server implementations.

    """


    # Public API
    # ==========

    def __init__(self, caller, rfile, wfile):
        self._caller = caller
        self._listen = caller._listen
        self._rfile = rfile
        self._wfile = wfile

    def __call__(self):
        """Override this for different client and server behavior.
        """
        raise NotImplementedError


    # Extend base file API to support listening.
    # ==========================================

    def read(self, size=-1):
        data = self._rfile.read(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % data)
        return data

    def readline(self, size=-1):
        line = self._rfile.readline(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % line)
        return line

    def write(self, data, raw=False):
        if not raw:
            if not data.endswith('\n'):
                data += '\n'
        if self._listen:
            sys.stdout.write("SEND: %s" % data)
        self._wfile.write(data)


    # Helpers
    # =======
    # These are common to both clients and servers.

    def readlisting(self, trim_endings=False):
        """Read a listing off the wire.
        """
        listing = []
        rawline = self._readline()
        while rawline != '000\n':
            parsedline = self._parselisting(rawline, trim_endings)
            listing.append(parsedline)
            rawline = self._readline()
        return tuple(listing)

    def sendlisting(self, listing):
        """Given a listing, write it to the wire.

        This takes either a string or a list of lines.

        """
        if isinstance(listing, basestring):
            listing = listing.splitlines(True)
        for line in listing:
            line = unicode(line)
            if not line.endswith('\n'):
                line += '\n'
            self._write(line)
        self._write("000\n")



class ClientError(StandardError):

    def __init__(self, c, v):
        StandardError.__init__(self)
        self.code = c
        self.msg = v

    def __str__(self):
        return "[%d] %s" % (self.code, self.msg)


class Client(Protocol):
    """Base class for client implementations of TCP application-layer protocols
    """

    def __call__(self):
        c, v = self.get_response('')
        assert c == 200

    def get_response(self, msg):
        """Given a one-line message, return a parsed one-line response.

        The message to write may but needn't be terminated by a newline. The
        return value will be a two-tuple, the first element of which will be the
        three-digit response code. The second element will be a tuple containing
        any values returned by the server.

        Any error response from the server (codes in the 500 range) will trigger
        a ClientError here.

        """
        if msg:
            if not msg.endswith('\n'):
                msg += '\n'
            self.write(msg)
        response = self.readline().rstrip('\n')
        c, v = self._parse_response(response)
        if unicode(c).startswith('5'):
            raise ClientError(c, v)
        else:
            return (c, v)

    def _parse_response(self, msg):
        """Given a one-line response from the server, parse it.
        """
        msg = msg.rstrip('\n')
        parts = msg.split(' ', 1)
        if len(parts) == 1:
            parts += ('',)
        _code, _vals = parts
        code_ = int(_code)
        values = unicode(_vals)
        return code_, values


    # API
    # ===

    def ECHO(self, msg):
        """ECHO a message
        """
        c, v = self.get_response("ECHO %s" % msg)
        assert c == 200
        return v

    def QUIT(self):
        """QUIT
        """
        c, v = self.get_response("QUIT")
        assert c == 200
        self.socket.close()
        self.socket = None


class EndRequest(StandardError):
    """Represents the end of a single TCP application request.
    """

class EndSession(StandardError):
    """Represents the end of an entire TCP application session.
    """

class Server(Protocol):
    """Base class for server implementations of TCP application-layer protocols
    """

    WELCOME = "200 Ok."
    API = ('ECHO', 'QUIT')

    def __call__(self):
        self.write(self.WELCOME)
        try:
            while True:
                try:
                    command, arguments = self.get_request()
                    if command in self.API:
                        method = getattr(self, command)(arguments)
                    else:
                        self.write("500 Unsupported command %s" % command)
                except EndRequest:
                    pass
        except EndSession:
            self.write("200 Goodbye.")

    def get_request(self):
        """Read a request off the wire and parse it into command and arguments.
        """
        request = self.readline().rstrip('\n')
        request = request.rstrip('\n')
        parts = request.split(' ', 1)
        if len(parts) == 1:
            parts += ('',)
        return parts


    # API
    # ===

    def ECHO(self, msg):
        """ECHO a message
        """
        self.write("200 %s" % msg)

    def QUIT(self):
        """QUIT
        """
        raise EndSession
