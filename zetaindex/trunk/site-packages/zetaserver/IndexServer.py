class Blog:
    """Represent a Blog.

    This is where the actual work gets done; db connections, etc.

    """

    def __init__(self, db_path, autoconnect = 1):
        self.db_path = db_path
        self.SHUTDOWN = object()
        self.WRITES_COMPLETE = threading.Event()

        self.POSTS_CHANGED = Utils.ThreadSafeTimeStamp()
        self.EVENTS_CHANGED = Utils.ThreadSafeTimeStamp()

        self.alive = False
        if autoconnect:
            self._connect()


    def _connect(self):
        if not os.path.isfile(self.db_path):
            self._create_db()
        self._open_db()


    def _open_db(self):
        self._writing_queue = Queue.Queue()
        self._writing_thread = threading.Thread(target = self._writing_thread_run)
        self._writing_thread.start()
        self._reading_cache = Utils.BlogCache(self.db_path, 10, {'POSTS_CHANGED':self.POSTS_CHANGED, 'EVENTS_CHANGED':self.EVENTS_CHANGED})
        self.alive = True


    def _writing_thread_run(self):
        conn = dbapi2.connect(self.db_path)
        cur = conn.cursor()
        i = 0
        while True:
            i += 1
            work = self._writing_queue.get()
            if work == self.SHUTDOWN:
                break
            elif isinstance(work, basestring):
                cur.execute(work)
                conn.commit()
                if self._writing_queue.empty():
                    self.WRITES_COMPLETE.set()
            elif isinstance(work, tuple):
                sql, events = work
                cur.execute(sql)
                conn.commit()
                if self._writing_queue.empty():
                    self.WRITES_COMPLETE.set()
                for event in events:
                    event.set()
            else:
                raise TypeError, 'WTF IS THIS --> %s <-- SUPPOSED TO BE!?'%repr(work)
        cur.close()
        conn.close()


    def _create_db(self):
        db_dir = os.path.split(self.db_path)[0]
        os.makedirs(db_dir)
        self.conn = dbapi2.connect(self.db_path)
        self.cur = self.conn.cursor()
        posts_table_sql = '''
            create table posts (
             uid        INTEGER PRIMARY KEY,
             author     VARCHAR,
             content    TEXT,
             timestamp  TIMESTAMP
             );'''
        comments_table_sql = '''
            create table comments (
             uid        INTEGER PRIMARY KEY,
             post_uid   INTEGER,
             parent_uid INTEGER,
             author     VARCHAR,
             content    TEXT,
             timestamp  TIMESTAMP
             );
             '''
        self.cur.execute(posts_table_sql)
        self.cur.execute(comments_table_sql)
        self.conn.commit()
        self.cur.close()
        self.conn.close()
        del(self.cur)
        del(self.conn)


    def _close(self):
        self._writing_queue.put(self.SHUTDOWN)
        self._writing_thread.join()
        self.alive = False


    @secured
    def post_post(self, author, content, wait = 0, signature = ''):
        timestamp = unicode(mxdatetime.now())
        sql = '''insert into posts (author, content, timestamp)\
        values ("%s", "%s", "%s");'''%(author, content, timestamp)
        self.WRITES_COMPLETE.clear()
        if wait:
            waiter = threading.Event()
            self._writing_queue.put((sql, [self.POSTS_CHANGED, waiter]))
            waiter.wait()
        else:
            self._writing_queue.put((sql, [self.POSTS_CHANGED]))
        return ('posting', timestamp)


    @public
    def print_db(self):
        results = self._reading_cache["select * from posts;",
            'POSTS_CHANGED']
        from pprint import pformat
        return pformat(results)
