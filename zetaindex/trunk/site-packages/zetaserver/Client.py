import socket
import sys

class ClientError(StandardError):
    """Represents an error in zetaindex Client.
    """

    def __init__(self, code_=0):
        StandardError.__init__(self)
        if code_ in RESPONSES:
            self.msg = RESPONSES[code_]
        else:
            self.msg = str(code_)
        self.code = code_

    def __str__(self):
        return "[%d] %s" % (self.code, self.msg)


RESPONSES = {
    100 : "Listing follows."
  , 200 : "Ok."
        }


class Client:
    """Represent a connection to a TCP server.
    """


    # Connection
    # ==========

    _sock = None
    _listen = False

    def __init__(self, protocol, host='localhost', port=53700):
        """Establish a connection to a zetaindex server.
        """

        self.protocol = protocol
        self._host = host
        self._port = port

        # connection code yanked from httplib
        for res in socket.getaddrinfo( host
                                     , port
                                     , 0
                                     , socket.SOCK_STREAM
                                      ):
            af, socktype, proto, canonname, sa = res
            try:
                self._sock = socket.socket(af, socktype, proto)
                self._sock.connect(sa)
            except socket.error, msg:
                if self._sock:
                    self._sock.close()
                self._sock = None
                continue
            break
        if not self._sock:
            raise socket.error, msg


        # Convert our socket to a file API.
        # =================================

        self._rfile = self._sock.makefile('rb', -1)   # buffered
        self._wfile = self._sock.makefile('wb', 0)    # unbuffered


        # Read off the first line.
        # ========================

        c, v = self._parse(self._readline())
        if c != 200:
            raise ClientError("Error connecting to server: %s" % v[0])


    def __repr__(self):
        return "<zetaindex://%s:%s>" % (self._host, self._port)
    __str__ = __repr__



    # Extend base file API to support listening.
    # ==========================================

    def _read(self, size=-1):
        msg = self._rfile.read(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % msg)
        return msg

    def _readline(self, size=-1):
        line = self._rfile.readline(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % line)
        return line

    def _write(self, msg):
        if self._listen:
            sys.stdout.write("SEND: %s" % msg)
        self._wfile.write(msg)



    # Helpers
    # =======

    def _req(self, msg):
        """Given a one-line message, return a parsed one-line response.

        The message to write may but needn't be terminated by a newline. The
        return value will be a two-tuple, the first element of which will be the
        three-digit response code. The second element will be a tuple containing
        any values returned by the server.

        Any error response from the server (codes in the 500 range) will trigger
        a ClientError here.

        """
        if not msg.endswith('\n'):
            msg += '\n'
        self._write(msg)
        response = self._readline().rstrip('\n')
        c, v = self._parse(response)
        if unicode(c).startswith('5'):
            raise ClientError(c)
        else:
            return (c, v)

    def _parse(self, msg):
        """Given a one-line response from the server, parse it.
        """
        msg = msg.rstrip('\n')
        _code, _vals = msg.split(' ', 1)
        code_ = int(_code)
        values = unicode(_vals)
        return code_, values

    def _readlisting(self, trim_endings=False):
        """Read a listing off the wire.
        """
        listing = []
        rawline = self._readline()
        while rawline != '000\n':
            parsedline = self._parselisting(rawline, trim_endings)
            listing.append(parsedline)
            rawline = self._readline()
        return tuple(listing)

    def _sendlisting(self, listing):
        """Given a listing, write it to the wire.

        This takes either a string or a list of lines.

        """
        if isinstance(listing, basestring):
            listing = listing.splitlines(True)
        for line in listing:
            line = unicode(line)
            if not line.endswith('\n'):
                line += '\n'
            self._write(line)
        self._write("000\n")



    # Protocol
    # ========

    def AUTH(self, identifier):
        """AUTHorize
        """
        c, v = self._req(u"AUTH %s" % identifier)
        assert c == 200


    def ECHO(self, msg=''):
        """ECHO a message
        """
        msg = unicode(msg)
        c, v = self._req(u"ECHO %s" % msg)
        assert c == 200
        return v


    def NOOP(self):
        """NOOP
        """
        c, v = self._req(u"NOOP")
        assert c == 200


    def QUIT(self):
        """QUIT
        """
        c, v = self._req(u"QUIT")
        assert c == 200
        self._sock.close()
        self._sock = None



if __name__ == '__main__':
    client = Client(_listen=True)
    import code
    code.interact(local=locals())
