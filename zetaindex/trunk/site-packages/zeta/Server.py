import Queue
import optparse
import os
import signal
import socket
import sys
import threading
import time
import traceback

from zeta.index.Client import Client


class Server:
    """Provides the zeta indexing service.

    This server uses a pool of threads to service requests.

    """

    def __init__(self, protocol, hostname='', port=53700, threadcount=1):

        # Configure the server.
        # =====================
        self.protocol = protocol
        self.parse_options()

        # Set up signal handling.
        # =======================
        self.DIE = threading.Event()
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

        # Set up threads.
        # ===============
        self.SHUTDOWN = object()
        self.threads = {}
        self.queue = Queue.Queue()
        self.fill_thread_pool(threadcount)

        # Connect to our socket.
        # ======================
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.socket.bind((hostname, port))
        self.socket.listen(5)


    # Configuration
    # =============

    def parse_options(self):
        parser_ = optparse.OptionParser()
        parser_.add_option('-a', '--address', dest = 'address', type = 'str')
        parser_.add_option('-p', '--port', dest = 'port', type = 'int')
        parser_.add_option('-f', '--pidfile', dest = 'pidfile', type = 'str')
        parser_.add_option('-l', '--log', dest = 'log', type = 'str')
        parser_.add_option('-s', '--storage', dest = 'storage', type = 'str')
        parser_.add_option('-t', '--threads', dest = 'threads', type = 'int')
        parser_.set_defaults( address = '127.0.0.1'
                            , port = 53700
                            , pidfile = 'zetaindex.pid'
                            , log = 'zetaindex.log'
                            , threads = 1
                             )
        self.options, args = parser_.parse_args()


    # Public API
    # ==========

    def start(self):
        """Start the server.

        The server is actually run in a second thread, so that the main thread
        is free to listen for signals.

        """
        deputy = threading.Thread(target = self.deputy)
        deputy.start()
        while True:
            # Kick our feet up and watch for signals.
            time.sleep(1000000)

    def stop(self):
        print 'shutting down...'
        threads = self.threads.values()
        for i in range(len(threads)):
            self.queue.put(self.SHUTDOWN)
        for thread in threads:
            thread.join()
        self.socket.close()
        print 'done!'
        sys.exit(0)


    # Signal Handling
    # ===============

    def signal_handler(self, signal, frame):
        signals = {2:'SIGINT', 15:'SIGTERM'}
        print 'zetaindex got %s' % signals[signal]
        print 'killing the deputy thread'
        self.DIE.set()
        self.stop()


    # Threads
    # =======

    def fill_thread_pool(self, threadcount):
        """Given the number of threads to create, create them.
        """
        for i in range(threadcount):
            thread_ = threading.Thread( target=self.worker
                                      , args=(i,)
                                       )
            self.threads[i] = thread_
            thread_.start()

    def deputy(self):
        """Take requests off the wire and hand them over to work threads.
        """
        print 'starting!'
        while not self.DIE.isSet():
            try:
                work = self.socket.accept()
            except socket.error:
                return
            self.queue.put(work)
        print 'ended infinite loop'

    def worker(self, thread_id):
        """Given a thread id, work, work, work.
        """
        while True:
            work = self.queue.get()
            if work is self.SHUTDOWN:
                break
            else:
                request, client_address = work
                try:
                    self.serve_request(request, client_address)
                finally:
                    request.close()

    # buffering per SocketServer.StreamRequestHandler
    rbufsize = -1
    wbufsize = 0

    def serve_request(self, request, client_address):
        """This is where the work actually gets done.
        """
        rfile = request.makefile('rb', self.rbufsize)
        wfile = request.makefile('wb', self.wbufsize)

        try:
            protocol = self.protocol(rfile, wfile)
            protocol()
        except:
            print (u"Failed to service request from " +
                   u"%s:%d." % client_address)
            print traceback.format_exc()

        if not wfile.closed:
            wfile.flush()
        wfile.close()
        rfile.close()




class BaseProtocol:

    WELCOME = "200 Ok."
    API = ('ECHO',)
    _listen = False


    # Expected API
    # ============

    def __init__(self, rfile, wfile):
        self._rfile = rfile
        self._wfile = wfile

    def __call__(self):
        self._write(self.WELCOME)
        while True:
            command, arguments = self._get_request()
            if command == 'QUIT':
                self._write("200 Goodbye.")
                break
            elif command in self.API:
                method = getattr(self, command)(arguments)
            else:
                self._write("500 Unsupported command %s" % command)


    # Protocol Example
    # ================

    def ECHO(self, msg):
        """ECHO
        """
        self._write("200 %s" % msg)


    # Extend base file API to support listening.
    # ==========================================

    def _read(self, size=-1):
        msg = self._rfile.read(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % msg)
        return msg

    def _readline(self, size=-1):
        line = self._rfile.readline(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % line)
        return line

    def _write(self, msg):
        if not msg.endswith('\n'):
            msg += '\n'
        if self._listen:
            sys.stdout.write("SEND: %s" % msg)
        self._wfile.write(msg)


    # Protocol Helpers
    # ================

    def _get_request(self):
        """Read a request off the wire and parse it into command and arguments.
        """
        request = self._readline().rstrip('\n')
        request = request.rstrip('\n')
        parts = request.split(' ', 1)
        if len(parts) == 1:
            parts += ('',)
        return parts

    def _readlisting(self, trim_endings=False):
        """Read a listing off the wire.
        """
        listing = []
        rawline = self._readline()
        while rawline != '000\n':
            parsedline = self._parselisting(rawline, trim_endings)
            listing.append(parsedline)
            rawline = self._readline()
        return tuple(listing)

    def _sendlisting(self, listing):
        """Given a listing, write it to the wire.

        This takes either a string or a list of lines.

        """
        if isinstance(listing, basestring):
            listing = listing.splitlines(True)
        for line in listing:
            line = unicode(line)
            if not line.endswith('\n'):
                line += '\n'
            self._write(line)
        self._write("000\n")



class IndexProtocol(BaseProtocol):
    """Represent the zetaindex protocol.

    This is a stateful protocol.

    """

    API = ( 'AUTH'
          , 'FIND'
          , 'INDX'
           )


    authenticated = False

    def AUTH(self, args):
        self._write('200 AUTH!')

    def FIND(self, args):
        if self.check_auth():
            self._write('200 FIND!')

    def INDX(self, args):
        if self.check_auth():
            self._write('200 INDX!')

    def auth_check(self):
        if not authenticated:
            self._write("500 Not authenticated.")



if __name__ == '__main__':
    server = Server(IndexProtocol)
    server.protocol._listen = True
    server.start()


