import socket
import sys

from citlib.utils import CitError, bitmap, bitbucket


class ROOM:
    config = ( 'QR_PERMANENT'
             , '<not used>'
             , 'QR_PRIVATE'
             , 'QR_PASSWORDED'
             , 'QR_GUESSNAME'
             , 'QR_DIRECTORY'
             , 'QR_UPLOAD'
             , 'QR_DOWNLOAD'
             , 'QR_VISDIR'
             , 'QR_ANONONLY'
             , 'QR_ANON2'
             , 'QR_NETWORK'
             , 'QR_PREFONLY'
             , 'QR_READONLY'
             , 'QR_MAILBOX'
              )
    config2 = ( 'QR2_SYSTEM'
              , 'QR2_SELFLIST'
               )
    access = ( 'UA_KNOWN'
             , 'UA_GOTOALLOWED'
             , 'UA_HASNEWMSGS'
             , 'UA_ZAPPED'
              )


class CitConn:
    """Represent a connection to a Citadel server.

    Our job here is to adapt the Citadel protocol to Python's data types, and
    the public API corresponds exactly to the Citadel protocol.

    """


    # Connection
    # ==========

    _sock = None

    def __init__(self, host='localhost', port=504, _listen=False):
        """Establish a connection to a Citadel server.
        """

        self._host = host
        self._port = port
        self._listen = _listen

        # connection code yanked from httplib
        for res in socket.getaddrinfo( host
                                     , port
                                     , 0
                                     , socket.SOCK_STREAM
                                      ):
            af, socktype, proto, canonname, sa = res
            try:
                self._sock = socket.socket(af, socktype, proto)
                self._sock.connect(sa)
            except socket.error, msg:
                if self._sock:
                    self._sock.close()
                self._sock = None
                continue
            break
        if not self._sock:
            raise socket.error, msg


        # Convert our socket to a file API.
        # =================================

        self._rfile = self._sock.makefile('rb', -1)   # buffered
        self._wfile = self._sock.makefile('wb', 0)    # unbuffered


        # Read off the first line.
        # ========================

        c, v = self._parse(self._readline())
        if c != 200:
            raise CitError("Error connecting to server: %s" % v[0])


    def __repr__(self):
        return "<citadel://%s:%s>" % (self._host, self._port)
    __str__ = __repr__



    # Extend base file API to support listening.
    # ==========================================

    def _read(self, size=-1):
        msg = self._rfile.read(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % msg)
        return msg

    def _readline(self, size=-1):
        line = self._rfile.readline(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % line)
        return line

    def _write(self, msg):
        if self._listen:
            sys.stdout.write("SEND: %s" % msg)
        self._wfile.write(msg)



    # Helpers
    # =======

    def _req(self, msg):
        """Given a one-line message, return a parsed one-line response.

        The message to write may but needn't be terminated by a newline. The
        return value will be a two-tuple, the first element of which will be the
        three-digit response code. The second element will be a tuple containing
        any values returned by the server.

        Any error response from the server (codes in the 500 range) will trigger
        a CitError here.

        """
        if not msg.endswith('\n'):
            msg += '\n'
        self._write(msg)
        response = self._readline().rstrip('\n')
        c, v = self._parse(response)
        if str(c).startswith('5'):
            raise CitError(c)
        else:
            return (c, v)


    def _parse(self, msg):
        """Given a one-line response from the server, parse it.
        """
        msg = msg.rstrip('\n')
        _code, _vals = msg.split(' ', 1)
        #code_ = tuple(int(i) for i in list(str(_code)))
        code_ = int(_code)
        values = tuple(_vals.split('|'))
        return code_, values


    def _readlisting(self):
        """Read a listing off the wire.
        """
        listing = []
        rawline = self._readline()
        while rawline != '000\n':
            parsedline = self._parselisting(rawline)
            listing.append(parsedline)
            rawline = self._readline()
        return tuple(listing)


    def _parselisting(self, line):
        """Given a raw line, return a list of values, or a single value.
        """
        line = line.rstrip('\n')
        if '|' in line:
            return line.split('|')
        else:
            return line


    def _sendlisting(self, listing):
        """Given a listing, write it to the wire.
        """
        if isinstance(listing, basestring):
            listing = listing.splitlines(True)
        _listing = []
        for line in listing:
            line = str(line)
            if not line.endswith('\n'):
                line += '\n'
            _listing.append(line)
        listing = _listing
        for line in listing:
            self._write(line)
        self._write("000\n")



    # Server Commands
    # ===============

    def CONF(self):
        """get or set global CONFiguration options
        """
        raise NotImplementedError

    def ECHO(self):
        """ECHO something
        """
        raise NotImplementedError

    def GTLS(self):
        """Get Transport Layer Security Status
        """
        raise NotImplementedError

    def IDEN(self):
        """IDENtify the client software
        """
        raise NotImplementedError

    def INFO(self):
        """get server INFO
        """
        raise NotImplementedError

    def IPGM(self):
        """identify as an Internal ProGraM
        """
        raise NotImplementedError

    def MRTG(self):
        """Multi Router Traffic Grapher
        """
        raise NotImplementedError

    def NETP(self):
        """authenticate as network session with connection NET Password
        """
        raise NotImplementedError

    def NOOP(self):
        """NO OPeration
        """
        raise NotImplementedError

    def QNOP(self):
        """Quiet No OPeration
        """
        raise NotImplementedError

    def QUIT(self):
        """QUIT
        """
        c, v = self._req("QUIT")
        assert c == 200
        self._sock.close()
        self._sock = None


    def REQT(self):
        """REQuest client Termination
        """
        raise NotImplementedError

    def STLS(self):
        """Start Transport Layer Security
        """
        raise NotImplementedError



    # User Commands
    # =============

    def AGUP(self):
        """Administrative Set User Parameters
        """
        raise NotImplementedError

    def ASUP(self):
        """Administrative Get User Parameters
        """
        raise NotImplementedError

    def CHEK(self):
        """CHEcK various things
        """
        raise NotImplementedError

    def CREU(self):
        """CREate new User account
        """
        raise NotImplementedError

    def EBIO(self):
        """Enter BIOgraphy
        """
        raise NotImplementedError

    def GETU(self):
        """GET User configuration
        """
        raise NotImplementedError

    def GNUR(self):
        """Get Next Unvalidated User
        """
        raise NotImplementedError

    def GREG(self):
        """Get REGistration for user
        """
        raise NotImplementedError

    def HCHG(self):
        """Hostname CHanGe
        """
        raise NotImplementedError

    def LBIO(self):
        """List users who have BIOs on file
        """
        raise NotImplementedError

    def LIST(self):
        """user LISTing
        """
        raise NotImplementedError


    def LOUT(self):
        """LogOUT
        """
        c, v = self._req("LOUT")
        assert c == 200


    def NEWU(self):
        """create NEW User account
        """
        raise NotImplementedError

    def PASS(self, password):
        """send PASSword

        Given a password, return a user record or return an error.

        """
        c, v = self._req("PASS %s" % password)
        if c == 200:
            return v
        elif c == 540:
            raise CitError("Password required")
        elif c == 541:
            raise CitError("Already logged in")
        elif c == 542:
            raise CitError("Username required")


    def QUSR(self):
        """Query for a USeR
        """
        raise NotImplementedError

    def RBIO(self):
        """Read BIOgraphy
        """
        raise NotImplementedError

    def RCHG(self):
        """Roomname CHanGe
        """
        raise NotImplementedError

    def REGI(self):
        """send REGIstration
        """
        raise NotImplementedError

    def RWHO(self):
        """Read WHO's online
        """
        raise NotImplementedError

    def SETP(self):
        """SET new Password
        """
        raise NotImplementedError

    def SETU(self):
        """SET User configuration
        """
        raise NotImplementedError

    def STEL(self):
        """enter STEaLth mode
        """
        raise NotImplementedError

    def UCHG(self):
        """Username CHanGe
        """
        raise NotImplementedError


    def USER(self, username):
        """send USER name
        """
        c, v = self._req("USER %s" % username)
        if c == 300:
            return
        elif c == 570:
            raise CitError("No such user: %s" % username)


    def VALI(self):
        """VALIdate user
        """
        raise NotImplementedError



    # Floor Commands
    # ==============

    def CFLR(self):
        """Create a new FLooR
        """
        raise NotImplementedError

    def EFLR(self):
        """Edit a FLooR
        """
        raise NotImplementedError

    def KFLR(self):
        """Kill a FLooR
        """
        raise NotImplementedError

    def LFLR(self):
        """List all known FLooRs
        """
        c, v = self._req("lflr")
        if c == 520:
            raise CitError("Not logged in")
        assert c == 100
        assert v == ('Known floors:',)
        return self._readlisting()



    # Room Commands
    # =============

    def CRE8(self):
        """CRE[ate] a new room
        """
        raise NotImplementedError

    def EINF(self):
        """Enter INFo file for room
        """
        raise NotImplementedError

    def FORG(self):
        """FORGet the current room
        """
        raise NotImplementedError

    def GETA(self):
        """GET room Aide
        """
        raise NotImplementedError

    def GETR(self):
        """GET Room attributes
        """
        raise NotImplementedError

    def GNET(self):
        """Set NETwork configuration for this room
        """
        raise NotImplementedError

    def SNET(self):
        """Set NETwork configuration for this room
        """
        raise NotImplementedError

    def GOTO(self):
        """GOTO a room
        """
        raise NotImplementedError

    def INVT(self):
        """INViTe a user to a room
        """
        raise NotImplementedError

    def KICK(self):
        """KICK a user out of a room
        """
        raise NotImplementedError

    def KILL(self):
        """KILL current room
        """
        raise NotImplementedError

    def LKRA(self):
        """List All Known Rooms
        """
        raise NotImplementedError

    def LZRM(self):
        """List Zapped RooMs
        """
        raise NotImplementedError


    def LKRN(self, floor=-1):
        """List Known Rooms with New messages
        """
        c, v = self._req("lkrn %d" % floor)
        if c != 100:
            raise CitError(c)
        rooms = []
        for raw in self._readlisting():
            room = [None] * 6
            room[0] = raw[0]
            room[1] = bitbucket(raw[1], ROOM.config)
            room[2] = bitbucket(raw[2], ROOM.config2)
            room[3] = int(raw[3])
            room[4] = int(raw[4])
            room[5] = bitbucket(raw[5], ROOM.access)
            rooms.append(room)
        return rooms


    def LPRM(self):
        """List all Public RooMs
        """
        raise NotImplementedError

    def LRMS(self):
        """List all accessible RooMS
        """
        raise NotImplementedError

    def NSYN(self):
        """Network SYNchronize room
        """
        raise NotImplementedError

    def RDIR(self):
        """Read room DIRectory
        """
        raise NotImplementedError

    def RINF(self):
        """read Room INFormation file
        """
        raise NotImplementedError

    def SETA(self):
        """SET room Aide
        """
        raise NotImplementedError

    def SETR(self):
        """SET Room attributes
        """
        raise NotImplementedError

    def SLRP(self):
        """Set Last-message-Read Pointer
        """
        raise NotImplementedError

    def VIEW(self):
        """set the VIEW for a room
        """
        raise NotImplementedError

    def WHOK(self):
        """WHO Knows room
        """
        raise NotImplementedError



    # Message Commands
    # ================

    def ASYN(self):
        """ASYNchronous message support
        """
        raise NotImplementedError


    def DELE(self, msgnum):
        """DELEte a message

        Takes a message number.

        """
        if not isinstance(msgnum, (int, long)):
            raise TypeError("DELE takes a plain or long integer")
        c, v = self._req("DELE %d" % msgnum)
        assert c == 200


    def EMSG(self):
        """Enter a system MeSsaGe
        """
        raise NotImplementedError


    def ENT0(self, *args, **kwargs):
        """ENTer message, mode 0
        """
        c, v = self._req("ENT0 %d|%s|%d|%d|%s|%s|%d|%s|%s" % args)
        assert c in (400, 800)
        self._sendlisting(kwargs['message'])
        if c == 800:
            confirmation = self._readlisting()
            return confirmation


    def GPEX(self):
        """Get Policy for message EXpiration
        """
        raise NotImplementedError

    def GTSN(self):
        """GeT the list of SeeN messages
        """
        raise NotImplementedError

    def FSCK(self):
        """check message base reference counts
        """
        raise NotImplementedError

    def MESG(self):
        """read system MESsaGe
        """
        raise NotImplementedError

    def MOVE(self):
        """MOVE or copy a message to a different room
        """
        raise NotImplementedError


    def MSGS(self, scope='all', num='', params=None, headers=0):
        """get pointers to MeSsaGeS in this room

        Takes four arguments:

            scope   'all', 'old', 'new', 'last', 'first', 'gt'       [optional]
            num     int, long              [required for 'last', 'first', 'gt']
            params  a dictionary of search parameters                [optional]
            headers 0, 1                                             [optional]

        Returns a list of integers when headers is 0, or a list of tuples when
        it is 1.

        """

        # Validate input.
        # ===============

        scope = scope.lower()
        if scope not in ('all', 'old', 'new', 'last', 'first', 'gt'):
            raise ValueError("Bad scope: %s." % scope)
        need_int = scope in ('last', 'first', 'gt')
        have_int = isinstance(num, (int, long))
        if need_int and not have_int:
            raise ValueError("Scope %s requires a second int arg." % scope)
        else:
            num = str(num)

        if not params:
            _search = 0
        else:
            if not isinstance(params, dict):
                raise TypeError("Search params must be a dictionary.")
            _params = []
            for k, v in params.items():
                _params.append("%s|%s" % (str(k), str(v)))

        if headers not in (0, 1):
            raise ValueError("Headers must be 0 or 1, got %s." % str(headers))


        # Execute.
        # ========

        c, v = self._req("MSGS %s|%s|%d|%d" % (scope, num, _search, headers))


        # Parse output.
        # =============

        assert c in (100, 800)
        if c == 100:
            listing = self._readlisting()
            if not headers:
                return [int(msgnum) for msgnum in listing]
            else:
                for msg in listing:
                    msg[0] = int(msg[0]) # msgnum
                    msg[1] = int(msg[1]) # timestamp
                return [tuple(msg) for msg in listing]

        elif c == 800:
            self._readlisting()
            raise NotImplementedError



    def MSG0(self, msgid, gimme=0):
        """read MeSsaGe, mode 0

        Takes a message id and a flag indicating whether to return headers,
        body, or both.

        """
        c, v = self._req("MSG0 %d|%d" % (msgid, gimme))
        assert c == 100
        message = self._readlisting()
        in_text = False
        cit_headers = {}
        text = []
        for line in message:
            if line == 'text':
                in_text = True
                continue
            if not in_text:
                key, val = line.split('=',1)
                cit_headers[key] = val
            else:
                text.append(line)
        text = '\n'.join(text)
        return (cit_headers, text)


    def MSG1(self):
        """read MeSsaGe, mode 1
        """
        raise NotImplementedError

    def MSG2(self):
        """read MeSsaGe, mode 2
        """
        raise NotImplementedError

    def MSG3(self):
        """read MeSsaGe, mode 3 - internal command
        """
        raise NotImplementedError

    def MSG4(self):
        """read MeSsaGe, mode 4 - output in preferred MIME format
        """
        raise NotImplementedError

    def MSGP(self):
        """set MeSsaGe Preferred MIME format
        """
        raise NotImplementedError

    def OPNA(self):
        """OPeN Attachment
        """
        raise NotImplementedError

    def SEEN(self):
        """set or clear the SEEN flag for a message
        """
        raise NotImplementedError

    def SPEX(self):
        """Set Policy for message EXpiration
        """
        raise NotImplementedError

    def SRCH(self):
        """SeaRCH the message base
        """
        raise NotImplementedError



    # Instant Message Commands
    # ========================

    def DEXP(self):
        """Disable receiving instant messages
        """
        raise NotImplementedError

    def GEXP(self):
        """Get instant messages
        """
        raise NotImplementedError

    def PEXP(self):
        """Print instant messages
        """
        raise NotImplementedError

    def SEXP(self):
        """Send instant message
        """
        raise NotImplementedError



    # Chat Commands
    # =============

    def CHAT(self):
        """enter CHAT mode
        """
        raise NotImplementedError



    # Mail Commands
    # =============

    def AUTO(self):
        """AUTOcompletion of email addresses
        """
        raise NotImplementedError

    def IGAB(self):
        """Initialize Global Address Book
        """
        raise NotImplementedError

    def ISME(self):
        """find out if an e-mail address IS ME
        """
        raise NotImplementedError

    def QDIR(self):
        """Query global DIRectory
        """
        raise NotImplementedError

    def SMTP(self):
        """utility commands for the SMTP gateway
        """
        raise NotImplementedError



    # Calendar Commands
    # =================

    def ICAL(self):
        """Internet CALendaring commands
        """
        raise NotImplementedError



    # File Commands
    # =============

    def CLOS(self):
        """CLOSe the download file
        """
        raise NotImplementedError

    def DELF(self):
        """DELete a File
        """
        raise NotImplementedError

    def MOVF(self):
        """MOVe a File
        """
        raise NotImplementedError

    def NDOP(self):
        """Network Download OPen file
        """
        raise NotImplementedError

    def NETF(self):
        """NETwork send a File
        """
        raise NotImplementedError

    def NUOP(self):
        """Network Upload OPen file
        """
        raise NotImplementedError

    def OIMG(self):
        """Open an IMaGe file
        """
        raise NotImplementedError

    def OPEN(self):
        """OPEN a file for download
        """
        raise NotImplementedError

    def READ(self):
        """READ from the download file
        """
        raise NotImplementedError

    def UCLS(self):
        """CLoSe the Upload file
        """
        raise NotImplementedError

    def UIMG(self):
        """Upload an IMaGe file
        """
        raise NotImplementedError

    def UOPN(self):
        """OPeN a file for Uploading
        """
        raise NotImplementedError

    def WRIT(self):
        """WRITe to the upload file
        """
        raise NotImplementedError