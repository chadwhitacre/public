import socket
import sys

from citlib.utils import CitError, bitmap, bitbucket


class ROOM:
    """Bit bucket defs for room API.
    """
    config = ( 'QR_PERMANENT'
             , '<not used>'
             , 'QR_PRIVATE'
             , 'QR_PASSWORDED'
             , 'QR_GUESSNAME'
             , 'QR_DIRECTORY'
             , 'QR_UPLOAD'
             , 'QR_DOWNLOAD'
             , 'QR_VISDIR'
             , 'QR_ANONONLY'
             , 'QR_ANON2'
             , 'QR_NETWORK'
             , 'QR_PREFONLY'
             , 'QR_READONLY'
             , 'QR_MAILBOX'
              )
    config2 = ( 'QR2_SYSTEM'
              , 'QR2_SELFLIST'
               )
    access = ( 'UA_KNOWN'
             , 'UA_GOTOALLOWED'
             , 'UA_HASNEWMSGS'
             , 'UA_ZAPPED'
              )


class CitConn:
    """Represent a connection to a Citadel server.

    Our job here is to adapt the Citadel protocol to Python's data types, and
    the public API corresponds exactly to the Citadel protocol.

    """


    # Connection
    # ==========

    _sock = None

    def __init__(self, host='localhost', port=504, _listen=False):
        """Establish a connection to a Citadel server.
        """

        self._host = host
        self._port = port
        self._listen = _listen

        # connection code yanked from httplib
        for res in socket.getaddrinfo( host
                                     , port
                                     , 0
                                     , socket.SOCK_STREAM
                                      ):
            af, socktype, proto, canonname, sa = res
            try:
                self._sock = socket.socket(af, socktype, proto)
                self._sock.connect(sa)
            except socket.error, msg:
                if self._sock:
                    self._sock.close()
                self._sock = None
                continue
            break
        if not self._sock:
            raise socket.error, msg


        # Convert our socket to a file API.
        # =================================

        self._rfile = self._sock.makefile('rb', -1)   # buffered
        self._wfile = self._sock.makefile('wb', 0)    # unbuffered


        # Read off the first line.
        # ========================

        c, v = self._parse(self._readline())
        if c != 200:
            raise CitError("Error connecting to server: %s" % v[0])


    def __repr__(self):
        return "<citadel://%s:%s>" % (self._host, self._port)
    __str__ = __repr__



    # Extend base file API to support listening.
    # ==========================================

    def _read(self, size=-1):
        msg = self._rfile.read(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % msg)
        return msg

    def _readline(self, size=-1):
        line = self._rfile.readline(size)
        if self._listen:
            sys.stdout.write("RECV: %s" % line)
        return line

    def _write(self, msg):
        if self._listen:
            sys.stdout.write("SEND: %s" % msg)
        self._wfile.write(msg)



    # Helpers
    # =======

    def _req(self, msg):
        """Given a one-line message, return a parsed one-line response.

        The message to write may but needn't be terminated by a newline. The
        return value will be a two-tuple, the first element of which will be the
        three-digit response code. The second element will be a tuple containing
        any values returned by the server.

        Any error response from the server (codes in the 500 range) will trigger
        a CitError here.

        """
        if not msg.endswith('\n'):
            msg += '\n'
        self._write(msg)
        response = self._readline().rstrip('\n')
        c, v = self._parse(response)
        if unicode(c).startswith('5'):
            raise CitError(c)
        else:
            return (c, v)


    def _parse(self, msg):
        """Given a one-line response from the server, parse it.
        """
        msg = msg.rstrip('\n')
        _code, _vals = msg.split(' ', 1)
        #code_ = tuple(int(i) for i in list(unicode(_code)))
        code_ = int(_code)
        values = tuple(_vals.split('|'))
        return code_, values


    def _readlisting(self, trim_endings=False):
        """Read a listing off the wire.
        """
        listing = []
        rawline = self._readline()
        while rawline != '000\n':
            parsedline = self._parselisting(rawline, trim_endings)
            listing.append(parsedline)
            rawline = self._readline()
        return tuple(listing)


    def _parselisting(self, line, trim_endings=False):
        """Given a raw line, return a list of values, or a single value.
        """
        if trim_endings:
            line = line.rstrip('\n')
        if '|' in line:
            return line.split('|')
        else:
            return line


    def _sendlisting(self, listing):
        """Given a listing, write it to the wire.

        This takes either a string or a list of lines.

        """
        if isinstance(listing, basestring):
            listing = listing.splitlines(True)
        for line in listing:
            line = unicode(line)
            if not line.endswith('\n'):
                line += '\n'
            self._write(line)
        self._write("000\n")



    # Server Commands
    # ===============

    def CONF(self):
        """get or set global CONFiguration options
        """
        raise NotImplementedError

    def ECHO(self):
        """ECHO something
        """
        raise NotImplementedError

    def GTLS(self):
        """Get Transport Layer Security Status
        """
        raise NotImplementedError

    def IDEN(self):
        """IDENtify the client software
        """
        raise NotImplementedError

    def INFO(self):
        """get server INFO
        """
        raise NotImplementedError

    def IPGM(self):
        """identify as an Internal ProGraM
        """
        raise NotImplementedError

    def MRTG(self):
        """Multi Router Traffic Grapher
        """
        raise NotImplementedError

    def NETP(self):
        """authenticate as network session with connection NET Password
        """
        raise NotImplementedError

    def NOOP(self):
        """NO OPeration
        """
        c, v = self._req(u"NOOP")
        assert c == 200

    def QNOP(self):
        """Quiet No OPeration
        """
        raise NotImplementedError

    def QUIT(self):
        """QUIT
        """
        c, v = self._req(u"QUIT")
        assert c == 200
        self._sock.close()
        self._sock = None


    def REQT(self):
        """REQuest client Termination
        """
        raise NotImplementedError

    def STLS(self):
        """Start Transport Layer Security
        """
        raise NotImplementedError



    # User Commands
    # =============

    def AGUP(self):
        """Administrative Set User Parameters
        """
        raise NotImplementedError

    def ASUP(self):
        """Administrative Get User Parameters
        """
        raise NotImplementedError

    def CHEK(self):
        """CHEcK various things
        """
        raise NotImplementedError

    def CREU(self):
        """CREate new User account
        """
        raise NotImplementedError

    def EBIO(self):
        """Enter BIOgraphy
        """
        raise NotImplementedError

    def GETU(self):
        """GET User configuration
        """
        raise NotImplementedError

    def GNUR(self):
        """Get Next Unvalidated User
        """
        raise NotImplementedError

    def GREG(self):
        """Get REGistration for user
        """
        raise NotImplementedError

    def HCHG(self):
        """Hostname CHanGe
        """
        raise NotImplementedError

    def LBIO(self):
        """List users who have BIOs on file
        """
        raise NotImplementedError

    def LIST(self):
        """user LISTing
        """
        raise NotImplementedError


    def LOUT(self):
        """LogOUT
        """
        c, v = self._req(u"LOUT")
        assert c == 200


    def NEWU(self):
        """create NEW User account
        """
        raise NotImplementedError

    def PASS(self, password):
        """send PASSword

        Given a password, return a user record or return an error.

        """
        c, v = self._req(u"PASS %s" % password)
        if c == 200:
            return v
        elif c == 540:
            raise CitError("Password required")
        elif c == 541:
            raise CitError("Already logged in")
        elif c == 542:
            raise CitError("Username required")


    def QUSR(self):
        """Query for a USeR
        """
        raise NotImplementedError

    def RBIO(self):
        """Read BIOgraphy
        """
        raise NotImplementedError

    def RCHG(self):
        """Roomname CHanGe
        """
        raise NotImplementedError

    def REGI(self):
        """send REGIstration
        """
        raise NotImplementedError

    def RWHO(self):
        """Read WHO's online
        """
        raise NotImplementedError

    def SETP(self):
        """SET new Password
        """
        raise NotImplementedError

    def SETU(self):
        """SET User configuration
        """
        raise NotImplementedError

    def STEL(self):
        """enter STEaLth mode
        """
        raise NotImplementedError

    def UCHG(self):
        """Username CHanGe
        """
        raise NotImplementedError


    def USER(self, username):
        """send USER name
        """
        c, v = self._req(u"USER %s" % username)
        if c == 300:
            return
        elif c == 570:
            raise CitError("No such user: %s" % username)


    def VALI(self):
        """VALIdate user
        """
        raise NotImplementedError



    # Floor Commands
    # ==============

    def CFLR(self):
        """Create a new FLooR
        """
        raise NotImplementedError

    def EFLR(self):
        """Edit a FLooR
        """
        raise NotImplementedError

    def KFLR(self):
        """Kill a FLooR
        """
        raise NotImplementedError

    def LFLR(self):
        """List all known FLooRs
        """
        c, v = self._req(u"LFLR")
        assert c == 100
        raw = self._readlisting(trim_endings=True)
        floors = []
        for floor in raw:
            floors.append(( int(floor[0])  # num
                          , floor[1]       # name
                          , int(floor[2])  # refcount
                           ))
        return floors



    # Room Commands
    # =============

    def CRE8(self):
        """CRE[ate] a new room
        """
        raise NotImplementedError

    def EINF(self):
        """Enter INFo file for room
        """
        raise NotImplementedError

    def FORG(self):
        """FORGet the current room
        """
        raise NotImplementedError

    def GETA(self):
        """GET room Aide
        """
        raise NotImplementedError

    def GETR(self):
        """GET Room attributes
        """
        raise NotImplementedError

    def GNET(self):
        """Get NETwork configuration for this room
        """
        raise NotImplementedError

    def SNET(self):
        """Set NETwork configuration for this room
        """
        raise NotImplementedError

    def GOTO(self):
        """GOTO a room
        """
        raise NotImplementedError

    def INVT(self):
        """INViTe a user to a room
        """
        raise NotImplementedError

    def KICK(self):
        """KICK a user out of a room
        """
        raise NotImplementedError

    def KILL(self):
        """KILL current room
        """
        raise NotImplementedError


    def _LR(self, _cmd, floor=-1):
        """Base for listing rooms
        """

        # Validate.
        # =========

        if _cmd not in (u'LKRA', u'LZRM', u'LKRN', u'LKRO', u'LPRM', u'LRMS'):
            raise ValueError(u"%s is not a valid room listing command." % _cmd)
        if not isinstance(floor, (long, int)):
            raise TypeError(u"floor must be a plain or long integer.")


        # Execute.
        # ========

        c, v = self._req(u"%s %d" % (_cmd, floor))


        # Parse.
        # ======

        assert c == 100
        rooms = []
        for raw in self._readlisting():
            room = [None] * 6
            room[0] = raw[0]
            room[1] = bitbucket(raw[1], ROOM.config)
            room[2] = bitbucket(raw[2], ROOM.config2)
            room[3] = int(raw[3])
            room[4] = int(raw[4])
            room[5] = bitbucket(raw[5], ROOM.access)
            rooms.append(room)
        return rooms


    def LKRA(self, floor=-1):
        """List All Known Rooms
        """
        return self._LR(u'LKRA', floor)

    def LZRM(self, floor=-1):
        """List Zapped RooMs
        """
        return self._LR(u'LZRM', floor)

    def LKRN(self, floor=-1):
        """List Known Rooms with New messages
        """
        return self._LR(u'LKRN', floor)

    def LKRO(self, floor=-1):
        """List Known Rooms with Old [no new] messages
        """
        return self._LR(u'LKRO', floor)

    def LPRM(self, floor=-1):
        """List all Public RooMs
        """
        return self._LR(u'LPRM', floor)

    def LRMS(self, floor=-1):
        """List all accessible RooMS
        """
        return self._LR(u'LRMS', floor)


    def NSYN(self):
        """Network SYNchronize room
        """
        raise NotImplementedError

    def RDIR(self):
        """Read room DIRectory
        """
        raise NotImplementedError

    def RINF(self):
        """read Room INFormation file
        """
        raise NotImplementedError

    def SETA(self):
        """SET room Aide
        """
        raise NotImplementedError

    def SETR(self):
        """SET Room attributes
        """
        raise NotImplementedError

    def SLRP(self):
        """Set Last-message-Read Pointer
        """
        raise NotImplementedError

    def VIEW(self):
        """set the VIEW for a room
        """
        raise NotImplementedError

    def WHOK(self):
        """WHO Knows room
        """
        raise NotImplementedError



    # Message Commands
    # ================

    def ASYN(self):
        """ASYNchronous message support
        """
        raise NotImplementedError


    def DELE(self, msgnum):
        """DELEte a message

        Takes a message number (plain or long int).

        """
        if not isinstance(msgnum, (int, long)):
            raise TypeError("DELE takes a plain or long integer")
        c, v = self._req(u"DELE %d" % msgnum)
        assert c == 200


    def EMSG(self):
        """Enter a system MeSsaGe
        """
        raise NotImplementedError


    def ENT0(self, post=1, to=u'', anon=0, format=0, subject=u'', name=u'',
                   confirm=0, cc=u'', bcc=u'', message=u''):
        """ENTer message, mode 0

        Takes arguments as described in the protocol, named as follows:

            Name in spec                Our name
            ==========================================
            Post flag                   post
            Recipient (To: field)       to
            Anonymous flag              anon
            Format type                 format
            Subject                     subject
            Post name                   name
            Do Confirmation             confirm
            Recipient (Cc: field)       cc
            Recipient (Bcc: field)      bcc


        Returns an email address, None, or a confirmation tuple.

        """

        # Validate.
        # =========

        if post not in (0,1,2):
            raise ValueError("Post flag must be 0, 1, or 2, not " +
                             "%s." % unicode(post))
        if not isinstance(to, basestring):
            raise TypeError("to must be a string")
        if anon not in (0,1):
            raise ValueError("anon must be 0 or 1, not %s." % unicode(anon))
        if format not in (0,1,4):
            raise ValueError("Format must be 0, 1, or 4, not " +
                             "%s." % unicode(anon))
        if not isinstance(subject, basestring):
            raise TypeError("subject must be a string")
        if not isinstance(name, basestring):
            raise TypeError("name must be a string")
        if confirm not in (0,1):
            raise ValueError("confirm must be 0 or 1, not %s." % unicode(anon))
        if not isinstance(cc, basestring):
            raise TypeError("cc must be a string")
        if not isinstance(bcc, basestring):
            raise TypeError("bcc must be a string")
        if not isinstance(message, basestring):
            raise TypeError("message must be a string")


        # Execute.
        # ========

        args = (post, to, anon, format, subject, name, confirm, cc, bcc)
        c, v = self._req(u"ENT0 %d|%s|%d|%d|%s|%s|%d|%s|%s" % args)


        # Parse.
        # ======

        assert c in (200, 400, 800)
        if c == 200:
            return v
        elif c == 400:
            self._sendlisting(message)
            return
        elif c == 800:
            self._sendlisting(message)
            confirmation = self._readlisting(trim_endings=True)
            return (int(confirmation[0]),) + confirmation[1:]


    def GPEX(self):
        """Get Policy for message EXpiration
        """
        raise NotImplementedError

    def GTSN(self):
        """GeT the list of SeeN messages
        """
        raise NotImplementedError

    def FSCK(self):
        """check message base reference counts
        """
        raise NotImplementedError

    def MESG(self):
        """read system MESsaGe
        """
        raise NotImplementedError

    def MOVE(self):
        """MOVE or copy a message to a different room
        """
        raise NotImplementedError


    def MSGS(self, scope='all', num='', q=None, headers=False):
        """get pointers to MeSsaGeS in this room

        Takes four arguments:

            scope   'all', 'old', 'new', 'last', 'first', 'gt'       [optional]
            num     int, long              [required for 'last', 'first', 'gt']
            q       a dictionary of search query parameters          [optional]
            headers 0/False, 1/True                                  [optional]

        Returns a list of integers when headers is 0, or a list of tuples when
        it is 1.

        """

        # Validate.
        # =========

        scope = scope.lower()
        if scope not in ('all', 'old', 'new', 'last', 'first', 'gt'):
            raise ValueError("Bad scope: %s." % scope)
        need_int = scope in ('last', 'first', 'gt')
        have_int = isinstance(num, (int, long))
        if need_int and not have_int:
            raise ValueError("Scope %s needs a second int arg." % unicode(scope))
        else:
            num = unicode(num)

        if not q:
            _search = 0
        else:
            _search = 1
            if not isinstance(q, dict):
                raise TypeError("Search params must be a dictionary.")
            params = []
            for k, v in q.items():
                params.append(u"%s|%s" % (unicode(k), unicode(v)))

        if headers not in (0, 1, True, False):
            raise ValueError("Headers must be 0, 1, True, or False, got " +
                             "%s." % unicode(headers))


        # Execute.
        # ========

        args = (scope, num, _search, int(headers))
        c, v = self._req(u"MSGS %s|%s|%d|%d" % args)


        # Parse.
        # ======

        assert c in (100, 800)

        if c == 800:
            self._sendlisting(params)

        listing = self._readlisting()
        if not headers:
            return [int(msgnum) for msgnum in listing]
        else:
            for msg in listing:
                msg[0] = int(msg[0]) # msgnum
                msg[1] = int(msg[1]) # timestamp
            return [tuple(msg) for msg in listing]


    def _MSGx(self, x, msgnum, gimme=0):
        """read MeSsaGe, mode x

        Takes a message id and a flag indicating whether to return headers,
        body, or both.

        """

        # Validate.
        # =========

        if x not in (0,2,4):
            raise ValueError(u"mode must be 0, 2, or 4, not %s." % unicode(x))
        if not isinstance(msgnum, (int, long)):
            raise TypeError(u"msgnum must be a plain or long int.")
        if gimme not in (0,1,2,3):
            raise ValueError(u"gimme must be 0, 1, 2, or 3, not " +
                             u"%s." % unicode(gimme))


        # Execute.
        # ========

        c, v = self._req(u"MSG%d %d|%d" % (x, msgnum, gimme))


        # Parse.
        # ======

        assert c == 100
        message = self._readlisting()
        in_text = False
        fields = {}
        text = []
        for line in message:
            if line == 'text\n':
                in_text = True
                continue
            if not in_text:
                line = line.strip('\n')
                key, val = line.split('=',1)
                fields[key] = val
            else:
                text.append(line)
        text = ''.join(text)
        return (fields, text)


    def MSG0(self, msgnum, gimme=0):
        """read MeSsaGe, mode 0
        """
        return self._MSGx(0, msgnum, gimme)

    def MSG1(self):
        """read MeSsaGe, mode 1
        """
        raise CitError(530)

    def MSG2(self):
        """read MeSsaGe, mode 2
        """
        raise NotImplementedError

    def MSG3(self):
        """read MeSsaGe, mode 3 - internal command
        """
        raise CitError(530)

    def MSG4(self, msgnum, gimme=0):
        """read MeSsaGe, mode 4 - output in preferred MIME format
        """
        raise NotImplementedError

    def MSGP(self):
        """set MeSsaGe Preferred MIME format
        """
        raise NotImplementedError

    def OPNA(self):
        """OPeN Attachment
        """
        raise NotImplementedError

    def SEEN(self):
        """set or clear the SEEN flag for a message
        """
        raise NotImplementedError

    def SPEX(self):
        """Set Policy for message EXpiration
        """
        raise NotImplementedError

    def SRCH(self):
        """SeaRCH the message base
        """
        raise NotImplementedError



    # Instant Message Commands
    # ========================

    def DEXP(self):
        """Disable receiving instant messages
        """
        raise NotImplementedError

    def GEXP(self):
        """Get instant messages
        """
        raise NotImplementedError

    def PEXP(self):
        """Print instant messages
        """
        raise NotImplementedError

    def SEXP(self):
        """Send instant message
        """
        raise NotImplementedError



    # Chat Commands
    # =============

    def CHAT(self):
        """enter CHAT mode
        """
        raise NotImplementedError



    # Mail Commands
    # =============

    def AUTO(self):
        """AUTOcompletion of email addresses
        """
        raise NotImplementedError

    def IGAB(self):
        """Initialize Global Address Book
        """
        raise NotImplementedError

    def ISME(self):
        """find out if an e-mail address IS ME
        """
        raise NotImplementedError

    def QDIR(self):
        """Query global DIRectory
        """
        raise NotImplementedError

    def SMTP(self):
        """utility commands for the SMTP gateway
        """
        raise NotImplementedError



    # Calendar Commands
    # =================

    def ICAL(self):
        """Internet CALendaring commands
        """
        raise NotImplementedError



    # File Commands
    # =============

    def CLOS(self):
        """CLOSe the download file
        """
        raise NotImplementedError

    def DELF(self):
        """DELete a File
        """
        raise NotImplementedError

    def MOVF(self):
        """MOVe a File
        """
        raise NotImplementedError

    def NDOP(self):
        """Network Download OPen file
        """
        raise NotImplementedError

    def NETF(self):
        """NETwork send a File
        """
        raise NotImplementedError

    def NUOP(self):
        """Network Upload OPen file
        """
        raise NotImplementedError

    def OIMG(self):
        """Open an IMaGe file
        """
        raise NotImplementedError

    def OPEN(self):
        """OPEN a file for download
        """
        raise NotImplementedError

    def READ(self):
        """READ from the download file
        """
        raise NotImplementedError

    def UCLS(self):
        """CLoSe the Upload file
        """
        raise NotImplementedError

    def UIMG(self):
        """Upload an IMaGe file
        """
        raise NotImplementedError

    def UOPN(self):
        """OPeN a file for Uploading
        """
        raise NotImplementedError

    def WRIT(self):
        """WRITe to the upload file
        """
        raise NotImplementedError