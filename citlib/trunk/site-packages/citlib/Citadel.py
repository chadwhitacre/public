from citlib.CitConn import CitConn


class CitadelError(StandardError):
    pass




#class Message:
#
#    def __init__(self, format, msgn, path, time_, from_, rcpt, room, node, hnode, zaps, part):
#        format      = ''
#        msgn        = ''
#        path        = ''
#        timestamp   = ''
#        from        = ''
#        rcpt        = ''
#        room        = ''
#        node        = ''
#        hnode       = ''
#        zaps        = ''
#        part        = ''
#        pref        = ''
#        suff        = ''
#        text        = ''
#
#        self.cit = cit


class Room:
    """Represent a Citadel room.
    """

    def __init__(self, cit, name):
        self.cit = cit
        self.name = name

    def __repr__(self):
        return u"<%s>" % self.name
    __str__ = __repr__

    def post(self, msg):
        """Given a message object, post it to the room.
        """
        self.cit.GOTO(self.name)

    def search(self):
        self.cit.GOTO(self.name)
        return Messages(self.cit.MSGS())




class Floor:
    """Represent a Citadel floor.

    Rooms can be accessed by name as attributes or keys.

    """

    def __init__(self, cit, name, num):
        self.cit = cit
        self.name = name
        self.num = num

    def __repr__(self):
        return u"<%s>" % self.name
    __str__ = __repr__

    def rooms(self, d=False):
        raw = self.cit.LKRA(self.num)
        rooms = {}
        for room in raw:
            rooms[room[0]] = room[1:]
        return d and rooms or rooms.keys()

    def __getattr__(self, name):
        """Return a room object.
        """
        rooms = self.rooms(1)
        if name in rooms:
            return Room(self.cit, name)
        else:
            raise AttributeError(u"No known room named %s" % name)

    def __getitem__(self, key):
        """Return a room object.
        """
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError(u"No known room named %s" % name)



class Citadel:
    """Represent a citadel server.

    This offers a higher level of abstraction than CitConn.

    """

    def __init__(self, host=u'localhost', port=504):
        self.host = host
        self.port = port
        self.cit = CitConn(host, port)

    def __repr__(self):
        return u"<Citadel at %s:%d>" % (self.host, self.port)
    __str__ = __repr__


    # Users
    # =====

    def login(self, username, password):
        self.cit.USER(username)
        self.cit.PASS(password)

    def logout(self):
        self.cit.LOUT()

    def keep_alive(self):
        self.cit.NOOP()

    def close(self):
        self.cit.QUIT()


    # Floors
    # ======

    def floors(self, d=False):
        raw = self.cit.LFLR()
        floors = {}
        for floor in raw:
            floors[floor[1]] = (floor[0], floor[2])
        return d and floors or floors.keys()

    def __getattr__(self, name):
        """Return a floor object.
        """
        floors = self.floors(1)
        if name in floors:
            return Floor(self.cit, name, floors[name][0])
        else:
            raise AttributeError(u"No known floor named %s" % name)

    def __getitem__(self, key):
        """Return a floor object.
        """
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError(u"No known floor named %s" % name)




if __name__ == '__main__':
    from pprint import pprint as pp
    cit = Citadel()
    cit.login('test', 'testing')
    main = cit['Main Floor']
    mail = main.Mail
    import code
    code.interact(local=locals())

    """
    cit.floors()
    ['Lobby','Etc.']
    lobby = cit.Lobby
    lobby.rooms()
    ['Mail','etc.']
    lobby.Mail.messages
    1120
    lobby.mail.messages.search()

    cit.logout()
    """