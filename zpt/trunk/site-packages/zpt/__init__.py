"""Standalone Zope Page Templates implementation.

    - PageTemplate
    - TemplateCache
    - httpyTemplateCache
    - httpyFrameCache

    The httpy caches only cache in deployment mode. The PageTemplate class is
    renamed from PageTemplateFile. Its API is as follows:

    def __init__(path):
        '''Takes the filesystem path to a Page Template.
        '''

    def render(context):
        '''Takes a dictionary that provides the template with its namespace.
        '''

"""

__author__ = "Chad Whitacre <chad@zetaweb.com>"
__version__ = "1.0"
__all__ = [ 'PageTemplate'
          , 'TemplateCache'
          , 'httpyTemplateCache'
          , 'httpyFrameCache'
           ]



# Import the main class and tweak its API.
# ========================================

from zpt._zope.pagetemplate.pagetemplatefile import PageTemplateFile as \
                                                    PageTemplate
PageTemplate.render = PageTemplate.pt_render


# Provide some caches as well.
# ============================

import logging
import os
import stat

from _lehuen import Cache, NOT_INITIALIZED


logger = logging.getLogger('zpt')


class TemplateCache(Cache):
    """Cache for filesystem-based Zope Page Templates.
    """

    def __init__(self):
        """Extend to hardwire size and adapt to mode.

        The max_size is just a safety belt. If you have that many page templates
        on your filesystem, then your app needs a different architecture. :^)

        In modes other than deployment, we are just a passthrough.

        """
        Cache.__init__(self, max_size=1000)


    def __call__(self):
        """Singleton.
        """
        return self


    def check(self, key, name, entry):
        """Compares the mod time of the file with the timestamp of our version.
        """
        timestamp = os.stat(key)[stat.ST_MTIME]
        if entry._value is NOT_INITIALIZED:
            entry._timestamp = timestamp
            return key
        elif entry._timestamp != timestamp:
            entry._timestamp = timestamp
            return key
        else:
            return None


    def build(self, key, name, opened, entry):
        """The key is a filesystem path; returns a template object.
        """
        logger.debug("Loading template from %s" % key)
        prefix, path = os.path.split(key)
        return PageTemplate(path, prefix)

TemplateCache = TemplateCache()



class httpyTemplateCache(Cache):
    """Return a fs-based Zope Page Template, caching it in deployment mode.
    """

    def __init__(self):
        """Extend to hardwire size and adapt to mode.

        The max_size is just a safety belt. If you have that many page templates
        on your filesystem, then your app needs a different architecture. :^)

        In modes other than deployment, we are just a passthrough.

        """
        Cache.__init__(self, max_size=1000)
        mode = os.environ.get('HTTPY_MODE', 'deployment')
        self.deploy_mode = mode == 'deployment'


    def __call__(self):
        """Singleton.
        """
        return self


    def check(self, key, name, entry):
        """Compares the mod time of the file with the timestamp of our version.
        """

        if not self.deploy_mode:
            # Only cache in deployment mode.
            return key

        timestamp = os.stat(key)[stat.ST_MTIME]
        if entry._value is NOT_INITIALIZED:
            entry._timestamp = timestamp
            return key
        elif entry._timestamp != timestamp:
            entry._timestamp = timestamp
            return key
        else:
            return None


    def build(self, key, name, opened, entry):
        """The key is a filesystem path; returns a template object.
        """
        logger.debug("Loading template from %s" % key)
        prefix, path = os.path.split(key)
        return PageTemplate(path, prefix)

httpyTemplateCache = httpyTemplateCache()



class httpyFrameCache:
    """Return a 'frame' macro, caching it in deployment mode.
    """

    def __init__(self):
        mode = os.environ.get('HTTPY_MODE', 'deployment')
        self.deploy_mode = mode == 'deployment'
        self.frame = None # gets primed on the first call

    def __call__(self):
        """Singleton.
        """
        return self

    def get(self, __):
        return self.deploy_mode and self.frame or self._get(__)

    def _get(self, __):
        """If available, return a `frame' macro.

        We look for it in the file `__/templates/frame.pt'.

        """
        logger.debug("loading frame")
        frame = None
        frame_path = os.path.join(__, 'templates', 'frame.pt')
        if os.path.exists(frame_path):
            if not os.stat(frame_path)[stat.ST_SIZE]:
                logger.warning("empty frame.pt: %s" % frame_path)
            else:
                template = TemplateCache[frame_path]
                template._cook_check()
                if template._v_errors:
                    template._v_errors.insert(0, "Unable to compile " +
                                                 "%s." % frame_path)
                    raise Response(500, '\r\n'.join(template._v_errors))
                frame = template.macros.get(u'frame', None)
                if frame is None:
                    logger.warning("no macro `frame' in %s" % frame_path)
        return frame

httpyFrameCache = httpyFrameCache()
