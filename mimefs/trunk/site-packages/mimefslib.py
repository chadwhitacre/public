"""This module defines objects for working with mimefs.

mimefs is a networked database filesystem. The fundamental idea is that you dump
arbitrary MIME messages onto this filesystem, and then find messages based on
their headers, rather than via a path as with traditional filesystems.

Logically speaking, mimefs recognizes three kinds of objects: filesystems,
volumes, and MIME messages. A filesystem is a single mimefs XMLRPC server. A
volume is a logical container within a single filesystem, allowing multiple
client applications to use a single server. Volumes contain MIME messages. Each
volume and each message are identified by a UUID, called a vid for volumes and a
mid for messages.

    filesystem -> volume -> message


mimefs 0 is defined as an XMLRPC API with %d callables.

"""
import codecs
from xmlrpclib import ServerProxy

__version__ = 0
__author__ = 'Chad Whitacre <chad@zetaweb.com>'
__all__ = ['FileSystem', 'Volume', 'Message']


# Helpers
# =======

KEY = open('/etc/mimefs.key').read() # TODO: add protection checks
OPERATORS = ('>', '>=', '=', '!=', '<=', '<', 'startswith', 'endswith')
MIMEfsError = StandardError


# Client classes.
# ===============

class _MethodWithArgs:
    """Represent a callable on an XMLRPC server with boilerplate arguments.
    """

    def __init__(self, method, *args):
        """Takes a callable, and positional arguments.
        """
        self.__method = method
        self.__args = args

    def __call__(self, *args):
        """Override to add the auth token as the first argument to the call.
        """
        args = self.__args + args
        return self.__method(*args)


class FileSystem:
    """Represent a MIME filesystem.
    """

    __all__ = ('exists', 'listvols', 'newvol', 'ping', 'rmvol')

    def __init__(self, uri, key):
        """Takes the URI of the mimefs server, and a master key.
        """
        self._uri = uri
        self._fs = ServerProxy(uri)
        self._key = key

    def __repr__(self):
        return "mimefs filesystem at %s" % self._uri
    __str__ = __repr__

    def __getattr__(self, name):
        if name not in self.__all__:
            raise AttributeError("'%s' not found" % name)
        base_method = getattr(self._fs, name)
        return _MethodWithArgs(base_method, self._key)


class Volume:
    """Represent a single mimefs volume.
    """

    __all__ = ('exists', 'list', 'open', 'remove')

    def __init__(self, uri):
        """Takes the URI of a mimefs volume.
        """
        self.uri = uri
        base, vid = uri.rsplit('/', 1)
        self._fs = ServerProxy(base+'/')
        self._vid = vid

    def __repr__(self):
        return "mimefs volume at %s" % (self.uri)
    __str__ = __repr__

    def __getattr__(self, name):
        if name not in self.__all__:
            raise AttributeError("'%s' not found" % name)
        base_method = getattr(self._fs, name)
        return _MethodWithArgs(base_method, self._vid)


class Message:
    """Represent a message off of a mimefs.
    """

    __all__ = ('read', 'write')

    def __init__(self, uri):
        """Takes the URI of a mimefs volume: http://host:5370/vid/mid
        """
        self.uri = uri
        base, vid, mid = uri.rsplit('/', 2)
        self._fs = ServerProxy(base+'/')
        self._vid = vid
        self._mid = mid

    def __repr__(self):
        return "mimefs message at %s" % (self.uri)
    __str__ = __repr__

    def __getattr__(self, name):
        if name not in self.__all__:
            raise AttributeError("'%s' not found" % name)
        base_method = getattr(self._fs, name)
        return _MethodWithArgs(base_method, self._vid, self._mid)





"""
        if isinstance(msg, basestring):
            pass
        elif isinstance(msg, Message):
            fp = StringIO()
            g = Generator(fp, mangle_from_=False, maxheaderlen=0)
            g.flatten(msg)
            msg = fp.getvalue()
"""



# Server class.
# =============

class Server:


    # Fundaments
    # ==========

    def ping(self):
        """Always return 'pong.'
        """
        return 'pong'


    def _check_key(self, key):
        """Given the master key, verify that it is correct.
        """
        self._check_uuid(key)
        if key != KEY:
            raise MIMEfsError("Bad key: '%s'" % key)


    def _check_uuid(self, uuid):
        """Given a string, return a boolean.
        """
        if not isinstance(uuid, basestring):
            raise MIMEfsError("Bad uuid: '%s'" % uuid)
        if len(uuid) != 36:
            raise MIMEfsError("Bad uuid: '%s'" % uuid)
        acceptable_chars = string.hexdigits + '-'
        for c in uuid:
            if c not in acceptable_chars:
                raise MIMEfsError("Bad uuid: '%s'" % uuid)


    def _check_vid(self, vid):
        """Given a vid, raise an error if it is invalid or doesn't exist.
        """
        self._check_uuid(vid)
        conn = self._connect()
        curs = conn.cursor()

        SQL = "SELECT vid FROM volume WHERE vid=%s;"
        curs.execute(SQL, (vid,))
        if curs.rowcount == 0:
            raise MIMEfsError("Bad vid: '%s'" % vid)
        elif curs.rowcount == 1:
            return None
        else:
            raise MIMEfsError("Wacky rowcount: '%s'" % curs.rowcount)


    def _connect(self):
        """Given a database name, return a database connection.
        """
        return psycopg.connect('dbname=mimefs_0')


    def _uuidgen(self):
        """Return a universally unique identifier, version 4 (RFC 4122).

        Currently we depend on uuid(1) in the OS; should change to uuidgen?

        """
        proc = subprocess.Popen(('uuid','-v4'), stdout=subprocess.PIPE)
        return proc.stdout.read().strip('\n')


    # Volumes
    # =======

    def listvols(self, key):
        """Given the master key, return a list of all vids.
        """
        self._check_key(key)
        conn = self._connect()
        curs = conn.cursor()

        SQL = "SELECT vid FROM volume;"
        curs.execute(SQL)
        vids = [row[0] for row in curs.fetchall()]

        conn.commit()
        conn.close()
        return vids


    def newvol(self, key):
        """Given the master key, return the vid of a new volume.
        """
        self._check_key(key)
        conn = self._connect()
        curs = conn.cursor()

        vid = self._uuidgen()
        SQL = "INSERT INTO volume (vid) VALUES (%s);"
        curs.execute(SQL, (vid,))

        conn.commit()
        conn.close()
        return vid


    def rmvol(self, key, vid):
        """Given the master key and a vid, remove the referenced volume.

        When a volume is removed, all messages in that volume are also removed,
        both from the message store and from the index.

        """

        self._check_key(key)
        self._check_vid(vid)

        conn = self._connect()
        curs = conn.cursor()

        SQL = "DELETE FROM volume WHERE vid=%s;" # This delete cascades down to
                                                 # message and field tables.
        curs.execute(SQL, (vid,))

        conn.commit()
        conn.close()



    # Message location and removal.
    # =============================
    # The following all operate on a single volume.

    def exists(self, vid, mid=None):
        """Given a vid and an optional mid, return True or False.

        If no mid is given, only the vid is checked.

        """

        # vid
        # ===

        try:
            self._check_vid(vid)
        except MIMEfsError:
            return False
        if mid is None:
            return True


        # mid
        # ===

        try:
            self._check_uuid(mid)
        except MIMEfsError:
            return False

        conn = self._connect()
        curs = conn.cursor()

        SQL = "SELECT mid FROM message WHERE vid=%s AND mid=%s;"
        curs.execute(SQL, (vid, mid))
        if curs.rowcount == 0:
            val = False
        elif curs.rowcount == 1:
            val = True
        else:
            raise MIMEfsError("Wacky rowcount: %s" % curs.rowcount)

        conn.commit()
        conn.close()
        return val


    def list(self, vid, WHERE='', LIMIT='ALL', OFFSET=0, ORDER_BY=''):
        """Given optional constraints, return mids.
        """
        """
        This is brute force unoptimized. You have been warned. :^)

        One idea for optimization is to require certain metadata, such as
        Content-Type and Modification-Time. Think of the most common listing
        cases. Another idea is to push the filtering logic down into a
        PostgreSQL procedure. The more radical idea is to actually create
        columns for metadata and use native SQL joins, etc. rather than
        reimplementing all of this set malarky at a higher level.
        """
        self._check_vid(vid)
        conn = self._connect()
        curs = conn.cursor()


        # Parse and validate constraints.
        # ===============================

        criteria = []
        for criterion in WHERE.splitlines():
            tokens = criterion.split(None, 2)
            if len(tokens) != 3:
                MIMEfsError( "Bad criterion (too few tokens): " +
                              "'%s'" % criterion
                             )
            else:
                tokens[1] = tokens[1].lower()
                if tokens[1] not in OPERATORS:
                    MIMEfsError( "Bad criterion (bad operator): " +
                                  "'%s'" % criterion
                                 )
                else:
                    criteria.append(tokens)
        if (LIMIT != 'ALL') and not isinstance(LIMIT, int):
            raise MIMEfsError("Bad limit: '%s'" % LIMIT)
        if OFFSET and not isinstance(OFFSET, int):
            raise MIMEfsError("Bad offset: '%s'" % OFFSET)


        # Find all matching messages.
        # ===========================

        if not criteria:

            SQL = "SELECT mid FROM message ORDER BY mid;"
            curs.execute(SQL)
            mids = [row[0] for row in curs.fetchall()]

        else:

            filters = []

            for name, op, sought in criteria:
                mids = sets.Set()

                # Massage our input.
                # ==================

                name = name.lower() # case-insensitive
                if op == '=':
                    op = '=='
                if len(op) > 2: # startswith, endswith
                    condition_tmpl = '%(body)s.%(op)s(%(sought)s)'
                else:
                    condition_tmpl = '%(body)s%(op)s%(sought)s'
                sought = repr(codecs.escape_encode(sought)[0])


                # Get candidate fields.
                # =====================

                SQL = """\
                    SELECT f.mid, f.body
                      FROM field f
                      JOIN message m
                        ON f.mid = m.mid
                     WHERE m.vid = %s
                       AND f.name = %s;
                     """
                curs.execute(SQL, (vid, name))


                # Loop through and find matches.
                # ==============================

                for mid, body in curs.fetchall():
                    vals = {}
                    vals['sought'] = sought
                    vals['op'] = op
                    vals['body'] = repr(codecs.escape_encode(body)[0])
                    condition = condition_tmpl % vals
                    logger.debug('evaluating: %s' % condition)
                    if eval(condition):
                        mids.add(mid)

                filters.append(mids)

            for filt in filters:
                mids &= filt
            mids = tuple(mids)


        # Slice, dice, and return.
        # ========================

        if LIMIT == 'ALL':
            LIMIT = len(mids)
        mids = mids[OFFSET:OFFSET+LIMIT]
        conn.commit()
        conn.close()
        return mids


    def open(self, vid, headers='', create=True, exclusive=True,
             truncate=False):
        """Given a vid, and an optional header block and flags, return a mid.

        In mimefs, a set of headers is parallel to a path on traditional
        filesystems: it identifies a particular point in the datastore. On that
        parallel, this call mimics stdio's open(), behaving as follows based on
        the number of messages matched by the given headers:

            0 messages matched
                If create is True, create a new message with the given headers
                and return its mid. Otherwise, raise an error.

            1 message matched
                Return the message's mid. If truncate is True, truncate the
                message body to zero length. If both exclusive and create are
                True, raise an error.

            >1 messages matched
                Raise an error.


        mimefs does not implement caching, linking, locking or protection.

        """
        self._check_vid(vid)
        conn = self._connect()
        curs = conn.cursor()


        # Branch based on matched messages.
        # =================================

        mids = self.list(vid, headers, LIMIT=2)
        matches = len(mids)

        if matches == 0:
            if create:
                mid = self._uuidgen()
                SQL = "INSERT INTO message (vid, mid) VALUES (%s, %s)"
                curs.execute(SQL, (vid, mid, headers))

            else:
                raise MIMEfsError("Message does not exist.")

        elif matches == 1:
            if create and exclusive:
                raise MIMEfsError("Message already exists.")
            if truncate:
                mid = mids[0]
                self.write(vid, mid, '')

        elif matches == 2:
            raise MIMEfsError("More than one message.")

        else:
            raise MIMEfsError("Total botch.")


        conn.commit()
        conn.close()
        return mid


    def remove(self, mid):
        """Given a mid, remove a message, returning None.

        The metadata unindexing is handled by a constraint in the table
        definition.

        """
        self._check_vid(vid)
        conn = self._connect()
        conn.close()

        SQL = "DELETE FROM message WHERE mid=%s;"
        curs.execute(SQL, (mid,))

        conn.commit()
        conn.close()
        return None



    # Message access and storage.
    # ===========================
    # The following all operate on a single message.

    def read(self, mid, headers_only=False):
        """Given a mid, return the referenced message as a string.

        If headers_only is True, only the message's header block is returned.

        """
        self._check_vid(vid)
        conn = self._connect()
        curs = conn.cursor()


        # Get data.
        # =========

        what = 'headers, body'
        if headers_only:
            what = 'headers'
        SQL = "SELECT %s FROM message WHERE vid=%%s AND mid=%%s;" % what
        curs.execute(SQL, (vid, mid))


        # Validate.
        # =========

        if curs.rowcount == -1:
            raise MIMEfsError("Error running query.")
        if curs.rowcount == 0:
            raise MIMEfsError("No message found.")
        elif curs.rowcount > 1:
            raise MIMEfsError( "mid matched %s " % str(curs.rowcount) +
                                "messages; probable data corruption!"
                               )

        # Return.
        # =======

        if headers_only:
            message = curs.fetchone()[0]
        else:
            message = '\r\n\r\n'.join(curs.fetchone()[0])
        conn.commit()
        conn.close()
        return message


    def write(self, mid, msg, headers_only=False):
        """Given a mid and a MIME message, store and index.

        If headers_only is False, then a msg without two line breaks is
        interpreted as a body part, which is stored without changing the index.

        If headers_only is True, then a msg without two line breaks is
        interpreted as a header block, and any body part in msg is optional and
        will be ignored.

        """
        self._check_vid(vid)
        conn = self._connect()
        curs = conn.cursor()


        # Break msg into headers and body.
        # ================================
        # Convert all newlines to \r\n per RFC 822/2045, and make sure a
        # body-less or header-less message has two line breaks. Then split it.

        msg = '\r\n'.join(msg.splitlines())
        if '\r\n\r\n' not in msg:
            if flags[W_HDONLY]:
                msg += '\r\n\r\n'
            else:
                msg = '\r\n\r\n' + msg
        headers, body = msg.split('\r\n\r\n', 1)


        # Determine the mid.
        # ==================
        # If given a valid mid, unindex it.

        if not mid:
            mid = self._uuidgen()
        else:
            SQL = "SELECT mid FROM message WHERE mid=%s;"
            curs.execute(SQL, (mid,))
            if curs.rowcount == 1:
                SQL = "DELETE FROM field WHERE mid=%s;"
                curs.execute(SQL, (mid,))
            else:
                raise MIMEfsError("Bad mid: '%s'" % mid)


        # Now store and index the message.
        # ================================

        if headers_only:
            # Note that we don't want to overwrite any existing body.
            SQL = ( "INSERT INTO message (vid, mid, headers) " +
                    "VALUES (%s, %s, %s);"
                   )
            curs.execute(SQL, (vid, mid, headers))
        else:
            SQL = ( "INSERT INTO message (vid, mid, headers, body) " +
                    "VALUES (%s, %s, %s, %s);"
                   )
            curs.execute(SQL, (vid, mid, headers, body))

        for name, body in message_from_string(headers).items():
            name = name.lower() # case insensitive
            SQL = "INSERT INTO field (mid, name, body) VALUES (%s, %s, %s);"
            curs.execute(SQL, (mid, name, body))


        # Wrap up and return.
        # ===================

        conn.commit()
        conn.close()
        return mid
