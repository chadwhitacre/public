class Plugin(file):
    """Represents a file to be boilerplated.

    Plugin is intended to be subclassed for different types of files. There
    are four attributes that a subclass may want to override:

      first_line
        a string used to delimit the start of a boilerplate

      line_template
        a string used to construct the body of a boilerplate

      last_line
        a string used to delimit the end of a boilerplate

      get_appropriate_spot
        a method that tells where to insert a boilerplate

    Usage:

      >>> import Plugin
      >>> l = Plugin('BoilerplateMe.py')
      >>>

    """

    # These are meant to be overriden by subclasses, but are not meant to be
    # changed across instances of a particular Plugin class. Don't forget the
    # trailing newlines!
    first_line    = '#BOILERPLATE%s\n' % ('#'*66)
    line_template = '#  %s  #\n'
    last_line     = '%sBOILERPLATE#\n' % ('#'*66)

    _filepath = ''
    _boilerplate = ''

    def __init__(self, filepath):
        """On construction, insert an empty boilerplate if not already present.

        We need to do this because Boilerplater assumes that plugin instances
        have a spot for boilerplate ready to be pasted over.

        """
        file.__init__(self, filepath, 'r+')
        self._boilerplate = self.read_boilerplate()
        if not self._boilerplate:
            self.prepare()

    def __repr__(self):
        return "<%s @ %s>" % (self.__name__, self.name)

    def read_boilerplate(self):
        """Return the current boilerplate or the empty string.
        """
        boilerplate = ''
        in_boilerplate = False
        for line in self:
            if line == self.first_line:
                in_boilerplate = True
            elif line == self.last_line:
                boilerplate += line
                break
            if in_boilerplate:
                boilerplate += line
        self.seek(0)
        return boilerplate

    def prepare(self):
        """Insert an empty boilerplate at the appropriate spot.
        """
        lines = self.readlines()
        if len(lines) > 0:
            i = self.get_appropriate_spot(lines)
        else:
            i = 0

        lines[i:i] = [self.first_line, self.last_line]

        data = ''.join(lines)
        self.save(data)

    def save(self, data):
        """Given a new file body, save it to disk and reset the cursor.
        """
        self.seek(0)
        self.truncate()
        self.write(data)
        self.seek(0)
        self._boilerplate = self.read_boilerplate()
        self.seek(0)

    def update(self, boilerplate):
        """Given some new boilerplate, format it and save it.
        """

        # Format it.
        formatted = ''
        if boilerplate <> '':
            lines = [''] + boilerplate.split('\n') + ['']
            for line in lines:
                pre, post = self.line_template.split('%s')
                width = 80 - len(pre) - len(post)
                formatted += self.line_template % line.ljust(width)[:width]
        formatted = self.first_line + formatted + self.last_line

        # Save it.
        text = self.read().replace(self._boilerplate, formatted)
        self.save(text)

    def get_appropriate_spot(self, lines):
        """Given a non-empty list of lines, return an int indicating the point
        in the sequence at which a boilerplate should be inserted.

        This is the primary method to override in Plugin subclasses. In our
        reference implementation, we insert the boilerplate after an initial
        hashbang line.

        """
        if lines[0].startswith('#!'):
            return 1
        else:
            return 0
