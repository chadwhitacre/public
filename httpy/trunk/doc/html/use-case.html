<html>
<head>
  <title>httpy documentation &mdash; use case</title>
  <style>@import url("_styles/main.css");</style>
</head>

<body><div id="hack">

  <h1>httpy</h1>
  <h2>a sane Python webserver</h2>

  <ul id="nav">

    <li><a href="./">Introduction</a></li>
    <li>Use Case</li>
    <li><a href="installation.html">Installation</a></li>
    <li><a href="configuration.html">Configuration</a></li>
    <li><a href="api.html">API</a></li>

  </ul>

  <div id="body">

    <h3 class="first">Use Case</h3>

    <p>httpy exists to bridge your Python application with other HTTP
    applications.

    <span class="sidebar">
      <img src="_images/the-rock.jpg" />
      <span>"Know your damn role." &mdash
      <a href="http://www.wwe.com/superstars/raw/therock/">The Rock</a></span>
    </span>

    Its primary use case is as an HTTP origin server for a cluster of
    Python-based websites numbering into the hundreds or thousands.</p>

    <p>Therefore, httpy shares its design aesthetic with toilet paper: instances
    of httpy must be instantly available to solidly perform a single function
    and then be cast away without a thought.

    <p>With that in mind, here's some httpy zen:</p>

    <ul>

      <li>httpy should make simple sites dead simple, and complex sites
      possible.</li>

      <li>Development, deployment, and upgrading should be equally easy, since
      all will need to happen constantly.</li>

      <li>The performance hit of an interpreted server will be offset by easy
      replication.</li>

      <li>Configuration should be kept to a minimum.</li>

      <li>Libraries are saner than frameworks.</li>

    </ul>

    <p>httpy's job is to get HTTP requests into your Python application, and to
    get HTTP responses from your app back onto the network. Here are some things
    that are explicitly not httpy's job, along with links to tools that do these
    jobs well:</p>

    <dl>

        <dt>
          daemonization,<br />
          complex error logging,<br />
          uid/gid manipulations
        </dt>

        <dd>You want <a href="http://cr.yp.to/daemontools.html">Dan Bernstein's
        daemontools</a>. httpy logs everything to the standard output, so use <a
        href="http://cr.yp.to/daemontools/multilog.html">multilog</a> to pick up
        from there, and use <a
        href="http://cr.yp.to/daemontools/setuidgid.html">setuidgid</a> to run
        httpy under a certain account.</dd>


        <dt>
          access logging,<br />
          ssl encryption,<br />
          virtual hosting,<br />
          load-balancing
        </dt>

        <dd>Use an HTTP proxy server such as <a
        href="http://www.apsis.ch/pound/">Pound</a>. You could also do these
        things with a general-purpose HTTP server such as <a
        href="http://httpd.apache.org/">Apache</a> or <a
        href="http://www.lighttpd.net/">lighttpd</a>.</dd>


        <dt>
          caching<br />
        </dt>

        <dd>Use a caching proxy such as
        <a href="http://www.squid-cache.org/">Squid</a>, or, again, <a
        href="http://httpd.apache.org/">Apache</a>. Your application should also
        do its own internal caching, of course.</dd>


        <dt>
          authentication,<br />
          authorization,<br />
          sessioning,<br />
          storage,<br />
          templating,<br />
          etc.
        </dt>

        <dd>These are your application's responsibility. There are plenty of <a
        href="http://cheeseshop.python.org/pypi">Python packages</a> available
        to help you.</dd>

      </dl>

      <p>A future version of httpy is expected to be at least conditionally
      compliant with HTTP/1.1.</p>

    </dl>

    <br style="clear: both;" />

  </div>

</div></body>
</html>