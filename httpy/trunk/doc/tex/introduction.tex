\chapter{Introduction}

\module{httpy} is a Python library for building websites and web applications.



\section{Relation to Existing Packages}

\module{httpy} is a Python library for building websites and web applications.
To understand how it differs from the glut of Python web programming libraries
and frameworks already on the market, consider for a moment this diagram of the
web stack:

\begin{verbatim}

                   The Web Stack

  ^                    etc.
  |                 JavaScript
                       CSS
client                XHTML

network                HTTP

server                 [  ]

  |                   Python
  |                  database
  v              operating system
                       etc.

\end{verbatim}

Python web programming packages fit in the empty spot in this diagram. Now,
other packages are born out of Joe Geek's love of Python, and his notion of how
a website should be modeled in Python. \module{httpy} takes the opposite tack.
Since every web application is an HTTP application at heart, \module{httpy}
starts there, and develops a simple object model based on the HyperText
Transmission Protocol itself. The premise is that HTTP -- mature,
well-documented, ubiquitous -- is a much surer foundation than any one
individual's notion of how your website should be modeled.

Here's another way to think about it: websites are complex! Ask 10 people to
model a website using Python objects, and we end up with 20 different answers.
Ok, so let's try to narrow the problem down slightly: what are the relatively
fixed points in this discussion? HTTP coming from the client, and Python waiting
on the server. Well, then, if we can give HTTP a compelling Python object
representation, then we will have squeezed out that much complexity from the
problem.



\section{Overview}

\module{httpy}'s job is to get HTTP requests off the wire into your Python
program, and to get HTTP responses from your program back onto the wire. Within
this narrow ambit, we intend to include batteries: you shouldn't have to resort
to another library for anything between the wire and your app. At the same time,
we aim for a sane and satisfying API. Beyond the basic modeling of HTTP Request
and Response messages, \module{httpy} is organized around just two types of
Python objects:

\begin{description}

\item[responders]
    {A responder is a module or class with a callable, \method{respond()}, that
    takes a single argument, an \class{httpy.Request} object. This callable is
    expected to raise (!) an \class{httpy.Response} object.}

\item[couplers]
    {A coupler puts a responder onto the network.}

\end{description}

\module{httpy}'s \class{Request} and \class{Response} objects are fairly literal
representations of their HTTP counterparts. Likewise, couplers are rather
pedestrian: that's where the socket and gateway programming happens.
\module{httpy}'s chief innovation is in overloading Python's \code{raise}
statement to represent the end of an HTTP transaction. This turns out to be a
natural fit: HTTP transactions usually see requests pass through multiple layers
on their way to an origin server -- routers, gateways, proxies, caches -- before
ending abruptly at any of a number of places on this stack, with a response
zipping back up the stack to the client. \module{httpy} turns the Python
interpreter's call stack into an extension of the HTTP stack.



\section{An Example}

To whet your whistle, here is \module{httpy}'s hello world:

\begin{verbatim}
>>> import httpy
>>> class Responder:
...   def respond(self, request):
...     response = httpy.Response(200)
...     response.body = "Greetings, program!"
...     response.headers = {'Content-Type':'text/html'}
...     raise response
...
>>>
\end{verbatim}

Besides being a subclass of \class{StandardError}, \class{httpy.Response} is
bone simple: its constructor takes an integer HTTP code, a body, and a
dictionary of headers -- all optional. These are stored in attributes, as seen
here. At the end of the transaction, this response is raised back up the stack
towards the client. Your responder will generally raise responses from more than
one place. For example, you could add this check to the above Responder class:

\begin{verbatim}
...     if request.method != 'GET':
...       raise httpy.Response(501)
\end{verbatim}

In any case, after defining a responder, here is how to put it on the network:

\begin{verbatim}
>>> httpy.couplers.StandAlone(Responder())
httpy.server     INFO     httpy started on port 8080
\end{verbatim}

At this point, your program is blocking, waiting for requests on
http://localhost:8080/. Visit it there, and you will see the text "Greetings,
program!" in your browser, and log output in your console. Congratulations!


\section{Batteries Included}

Out of the box, \module{httpy} includes four responders, to be found in the
\module{httpy.responders} subpackage:

\begin{description}

\item[\class{Doc}]
    {This serves documentation for Python site-packages.}

\item[\class{Multiple}]
    {This responder allows you to define a website with multiple responders,
    using the filesystem for the site's hierarchy. It also has a "framework"
    concept for implementing site-wide in- and outbound hooks.}

\item[\class{Static}]
    {The \class{Multiple} responder depends on this to serve static files from
    the filesystem; it can also be used independently.}

\item[\class{XMLRPC}]
    {With this you can easily implement a robust XMLRPC server.}

\end{description}

\module{httpy} also comes with one coupler, \class{StandAlone}, which implements
a portable, multi-threaded, standalone web server (for the interested, it is
built on the Zope 3 HTTP server). In addition, the \module{httpy} distribution
includes an executable, also named \code{httpy}, that instantiates this
\class{StandAlone} coupler with the \class{Multiple} responder. Thus, out of the
box, \module{httpy} provides a robust and sane foundation for your Python
websites and web applications.


\section{Some Items Sold Separately}

Below are some things that are explicitly not \module{httpy}'s job, with
pointers to tools that do these jobs well. Where non-Python tools are mentioned,
Python substitutes can almost certainly be found or built. Such substitutes can
be used either above or below \module{httpy} on your stack.

\begin{description}

\item[daemonization, complex error logging]
    {You probably want \ulink{Dan Bernstein's
    daemontools}{http://cr.yp.to/daemontools.html}. httpy logs everything to the
    standard output, so use
    \ulink{multilog}{http://cr.yp.to/daemontools/multilog.html} to pick up from
    there.}

\item[access logging, ssl encryption, virtual hosting, load-balancing]
    {Use an HTTP proxy server such as \ulink{Pound}{http://www.apsis.ch/pound/}.
    You could also do these things with a general-purpose HTTP server such as
    \ulink{Apache}{http://httpd.apache.org/} or
    \ulink{lighttpd}{http://www.lighttpd.net/}.}

\item[caching]
    {Use a caching proxy such as \ulink{Squid}{http://www.squid-cache.org/}, or,
    again, \ulink{Apache}{http://httpd.apache.org/}.}

\item[authentication, authorization, sessioning, storage, templating, etc.]
    {These are your responsibility. Lucky for you, there are plenty of
    \ulink{Python packages}{http://cheeseshop.python.org/pypi} available to help
    you.}

\end{description}
