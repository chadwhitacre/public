\chapter{Introduction}

\module{httpy} is a Python library for building websites and web applications.



\section{Relation to Existing Options}

\subsection{Libraries and Frameworks}

\module{httpy} is a Python library for building websites and web applications.
To understand how it differs from the glut of Python web programming libraries
and frameworks already on the market, consider for a moment this diagram of the
web stack:

\begin{verbatim}

                   The Web Stack
                   =============

  ^                    etc.
  |                 JavaScript
                       CSS
client                XHTML

network                HTTP

server            compiled server
                      gateway
  |
application --->       [  ], security, templating, persistence, etc.
  |
  |                   Python
  |                  database
  v              operating system
                       etc.

\end{verbatim}

Python web programming packages fit in the empty spot in this diagram. Now,
other packages generally start out on the "application" arm of this diagram. In
other words, they start with the concept of the \b{application}, and give that
concept expression as a Python object model.

\module{httpy} takes the opposite tack. Instead of starting with a variable --
the application -- \module{httpy} starts with the constants: HTTP above us, and
Python below us. (The "compiled server" and "gateway" are also variables, of
course, and may not be present at all.)

In other words, since every web application is an HTTP application at heart,
\module{httpy} starts there, and develops a simple object model based on the
HyperText Transmission Protocol itself. The premise here is that HTTP -- mature,
well-documented, ubiquitous -- is a much surer foundation than any one
individual's notion of how your website should be modeled.

Here's another way to think about it: websites are complex! Ask 10 people to
model a website using Python objects, and we end up with 20 different answers.
Ok, so let's try to narrow the problem down slightly: what are the relatively
fixed points in this discussion? HTTP coming from the client, and Python waiting
on the server. Well, then, if we can give HTTP a compelling Python object
representation, then we will have squeezed out that much complexity from the
problem.


\subsection{WSGI}

The Web Server Gateway Interface (WSGI; \pep{333}) is "a proposed standard
interface between web servers and Python web applications or frameworks." Its
primary goal is straightforward: to make any Python web app work with any web
server (Apache, lighttpd, BaseHTTPServer, etc.). Its secondary goal is to enable
web apps to be built from decoupled components. The idea is that if the various
parts of a web app -- security, templating, persistence -- are each modeled as
WSGI apps themselves, then they can be strung together in a "middleware stack."
Ultimately, it is hoped that WSGI will spur innovation by busting up the
monolithic Python web frameworks into smaller components from which one may
freely pick and choose.

\module{httpy} occupies roughly the same space as WSGI. Each models HTTP within
Python by specifying an interface to which your application ought to conform in
order to be portable between webservers, given some glue code:

\begin{description}

\item[WSGI]
    {\code{app(environ, start_response)} calls \code{start_response} and returns
    an iterator}

\item[httpy]
    {\code{responder.respond(request)} raises a \code{Response} object}

\end{description}


Furthermore, each wants to recast Python web programming in terms of smaller
components rather than monolithic frameworks. But whereas the choice of
interfaces is largely a matter of taste, the difference in componentization
strategy is more significant.

Under WSGI, the basic building-block for website authors is \emph{WSGI
middleware}. The WSGI vision is of a middleware marketplace, where various
subsystems of the web application problem domain -- security, templating,
persistence, etc. -- are packaged and offered as more or less independent WSGI
apps. Inter-app communication is handled by extensions to the WSGI protocol:
think CGI environment variables set to Python objects instead of strings.

With \module{httpy}, on the other hand, the basic building-blocks are
\emph{Python libraries}. Instead of a "middleware stack," you have the standard
Python call stack. And instead of "inter-app communication," you simply have
APIs. Python is a mature, well-documented, ubiquitous tool. As with HTTP, the
premise is that the closer one sticks to bare Python, the better.


\section{Interface Overview}

\module{httpy}'s job is to get HTTP requests off the wire into your Python
program, and to get HTTP responses from your program back onto the wire. Within
this narrow ambit, we intend to include batteries: you shouldn't have to resort
to another library for anything between the wire and your app. At the same time,
we aim for a sane and satisfying API. Beyond the basic modeling of HTTP Request
and Response messages, \module{httpy} is organized around just two types of
Python objects:

\begin{description}

\item[responders]
    {A responder is a module or class with a callable, \method{respond()}, that
    takes a single argument, an \class{httpy.Request} object. This callable is
    expected to raise (!) an \class{httpy.Response} object.}

\item[couplers]
    {A coupler puts a responder onto the network.}

\end{description}

\module{httpy}'s \class{Request} and \class{Response} objects are fairly literal
representations of their HTTP counterparts. Likewise, couplers are rather
pedestrian: that's where the socket and gateway programming happens.
\module{httpy}'s chief innovation is in overloading Python's \code{raise}
statement to represent the end of an HTTP transaction. This turns out to be a
natural fit: HTTP transactions usually see requests pass through multiple layers
on their way to an origin server -- routers, gateways, proxies, caches -- before
ending abruptly at any of a number of places on this stack, with a response
zipping back up the stack to the client. \module{httpy} turns the Python
interpreter's call stack into an extension of the HTTP stack.

Programming with \module{httpy} means writing responders.



\section{An Example}

To whet your whistle, here is \module{httpy}'s hello world:

\begin{verbatim}
>>> import httpy
>>> class Responder:
...   def respond(self, request):
...     response = httpy.Response(200)
...     response.body = "Greetings, program!"
...     response.headers = {'Content-Type':'text/html'}
...     raise response
...
>>>
\end{verbatim}

Besides being a subclass of \class{StandardError}, \class{httpy.Response} is
bone simple: its constructor takes an integer HTTP code, a body, and a
dictionary of headers -- all optional. These are stored in attributes, as seen
here. At the end of the transaction, this response is raised back up the stack
towards the client. Your responder will generally raise responses from more than
one place. For example, you could add this check to the above Responder class:

\begin{verbatim}
...   def respond(self, request):
...     if request.method != 'GET':
...       raise httpy.Response(501)
\end{verbatim}

In any case, after defining a responder, here is how to put it on the network:

\begin{verbatim}
>>> httpy.couplers.StandAlone(Responder())
httpy.server     INFO     httpy started on port 8080
\end{verbatim}

At this point, your program is blocking, waiting for requests on
http://localhost:8080/. Visit it there, and you will see the text "Greetings,
program!" in your browser, and log output in your console. Congratulations!


\section{Batteries Included}

Out of the box, \module{httpy} includes four responders, to be found in the
\module{httpy.responders} subpackage:

\begin{description}

\item[\class{Doc}]
    {This serves documentation for Python site-packages.}

\item[\class{Multiple}]
    {This responder allows you to define a website with multiple responders,
    using the filesystem for the site's hierarchy. It also has a "framework"
    concept for implementing site-wide in- and outbound hooks.}

\item[\class{Static}]
    {The \class{Multiple} responder depends on this to serve static files from
    the filesystem; it can also be used independently.}

\item[\class{XMLRPC}]
    {With this you can easily implement a robust XMLRPC server.}

\end{description}


\module{httpy} also comes with three couplers:

\begin{description}

\item[\class{CGI}]
    {This reconstructs an httpy.Request from a CGI environment.}

\item[\class{FastCGI}]
    {Built on the \module{jonpy} package.}

\item[\class{StandAlone}]
    {A portable, multi-threaded, standalone web server (for the interested, it
    is built on zope.server).}

\end{description}


In addition, the \module{httpy} distribution includes an executable, also named
\program{httpy}, that instantiates the \class{StandAlone} coupler with the
\class{Multiple} responder. Thus, out of the box, \module{httpy} provides a
robust and sane foundation for your Python websites and web applications.


\section{Some Items Sold Separately}

Below are some things that are explicitly not \module{httpy}'s job, with
pointers to tools that do these jobs well. Where non-Python tools are mentioned,
Python substitutes can almost certainly be found or built. Such substitutes can
be used either above or below \module{httpy} on your stack.

\begin{description}

\item[daemonization, complex error logging]
    {You probably want \ulink{Dan Bernstein's
    daemontools}{http://cr.yp.to/daemontools.html}. httpy logs everything to the
    standard output, so use
    \ulink{multilog}{http://cr.yp.to/daemontools/multilog.html} to pick up from
    there.}

\item[access logging, ssl encryption, virtual hosting, load-balancing]
    {Use an HTTP proxy server such as \ulink{Pound}{http://www.apsis.ch/pound/}.
    You could also do these things with a general-purpose HTTP server such as
    \ulink{Apache}{http://httpd.apache.org/} or
    \ulink{lighttpd}{http://www.lighttpd.net/}.}

\item[caching]
    {Use a caching proxy such as \ulink{Squid}{http://www.squid-cache.org/}, or,
    again, \ulink{Apache}{http://httpd.apache.org/}.}

\item[authentication, authorization, sessioning, storage, templating, etc.]
    {These are your responsibility. Lucky for you, there are plenty of
    \ulink{Python packages}{http://cheeseshop.python.org/pypi} available to help
    you.}

\end{description}
