\section{Couplers \label{couplers}}

Couplers put responders on the network. Our goal is to include ...
\module{httpy} includes three couplers out of the box. I think couplers are
boring, but you might get a kick out of them. There are multiple Python
webservers available, and a couple FastCGI options too. I've tried to pick the
single most mature option in each category, and build the couplers on top of
those. If better options become available, I will switch.


\begin{classdesc}{CGI}{responder} Constructs a new \class{CGI} coupler object.
\var{responder} is a responder \end{classdesc}

\begin{classdesc}{FastCGI}{responder} Constructs a new \class{FastCGI} coupler
object. \var{responder} is a responder \end{classdesc}

\begin{classdesc}{StandAlone}{responder\optional{, argv}} Constructs a new
\class{StandAlone} coupler object. \var{responder} is a responder. \var{argv} is
a list of arguments. If omitted or \class{None}, \code{sys.argv} is used.
\end{classdesc}

All couplers provide the following method:

\begin{methoddesc}{go}{} For \class{CGI} instances, this responds to a single
request. For \class{FastCGI} and \class{StandAlone}, this enters a blocking
loop.\end{methoddesc}

As an example, here is what a CGI script looks like with \module{httpy}:

\begin{verbatim}
#!/usr/local/bin/python
"""This is a CGI script.
"""
import httpy
import responder

coupler = httpy.couplers.CGI(responder)
coupler.go()
\end{verbatim}



\subsection{\class{CGI/FastCGI} Couplers \label{cgi}}
\subsection{\class{StandAlone} Couplers \label{standalone}}
\input{coupler}