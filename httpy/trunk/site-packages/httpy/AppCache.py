import sys

from httpy import DefaultApp
from httpy.NicolasLehuen import Cache
from httpy.utils import log


class AppCache(Cache):
    """A cached mapping of magic directory paths to app objects.
    """

    def __init__(self, mode):
        """Takes a mode per httpy.Config.

        The maxsize of 1000 is just a safety belt. If you trip it on purpose,
        you are blowing my mind. Why on earth are you building a website with
        more than a thousand distinct applications?

        """

        Cache.__init__(self, max_size=1000)
        self.dev_mode = mode == 'development'


    def check(self, __, entry):
        """Given a magic dir and an entry, return an app or None.

        In development mode, this cache is just a pass-through for get_app.

        """

        if not self.dev_mode:
            if hasattr(entry, 'loaded'):
                return None
            else:
                setattr(entry, 'loaded', True)
                return self.get_app(__)
        else:
            return self.get_app(__)


    def build(self, __, app, entry):
        """Given a magic directory, an app, and an entry, return an app.

        This should only ever get called once per app in deployment mode, since
        in that mode we never invalidate cache entries once they are loaded, and
        they therefore never get rebuilt.

        We could do better validation here (do __init__ and process take the
        right arguments?), and could probably even use zope interfaces.

        """

        if not hasattr(app, 'Transaction'):
            raise Exception("Unable to import Transaction from app at " +
                            "%s." % __)
        if not hasattr(app.Transaction, 'process'):
            raise Exception("The app.Transaction in %s does not " % __ +
                            "have a `process' method.")
        if not callable(app.Transaction.process):
            raise Exception("app.Transaction.process from %s is " % __ +
                            "not callable.")

        return app


    def get_app(self, __):
        """Get an app object to represent this application.

        For the root directory, we support automatically falling back to
        DefaultApp. Otherwise, we fail if there is no importable app. Also note
        that we influence sys.path here at import time to ensure that the
        correct app is found. We do this again at run time to ensure that any
        imports in Transaction.process are also interpreted properly.

        """

        if __ is None: # guaranteed by Config to only be true for the root
            return DefaultApp

        _path = None
        if __ not in sys.path:
            log(98, "Influencing sys.path at import time.")
            _path = sys.path[:]
            sys.path.insert(0, __)

        try:
            import app
            log(98, "Successfully imported app from %s." % __)
        except:
            log(90, "Failed to import app from %s." % __)
            raise

        if _path:
            sys.path = _path
            log(98, "sys.path restored at import time.")

        return app
