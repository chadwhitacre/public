import imp
import linecache
import sys

from zope.interface.verify import verifyClass, verifyObject

from httpy import DefaultApp
from httpy.interfaces import IApp, ITransaction
from httpy.NicolasLehuen import Cache
from httpy.utils import log, Gaoler


gaoler = Gaoler()


class AppCache(Cache):
    """A cached mapping of magic directory paths to app objects.
    """

    def __init__(self, mode):
        """Takes a mode per httpy.Config.

        The maxsize of 1000 is just a safety belt. If you trip it on purpose,
        you are blowing my mind. Why on earth are you building a website with
        more than a thousand distinct applications?

        """

        Cache.__init__(self, max_size=1000)
        self.dev_mode = mode == 'development'
        if self.dev_mode:
            self._modules = sys.modules.keys()


    def check(self, __, entry):
        """Given a magic dir and an entry, return an app or None.

        In development mode, this cache is just a pass-through for get_app.

        """

        if not self.dev_mode:
            if hasattr(entry, 'loaded'):
                return None
            else:
                setattr(entry, 'loaded', True)
                return self.get_app(__)
        else:
            for module in sys.modules.keys():
                if module not in self._modules:
                    del(sys.modules[module])
            linecache.clearcache()
            log(98, "Force modules to reload.")
            return self.get_app(__)


    def build(self, __, app, entry):
        """Given a magic directory, an app, and an entry, return an app.

        This should only ever get called once per app in deployment mode, since
        in that mode we never invalidate cache entries once they are loaded, and
        they therefore never get rebuilt.

        The calls to verify* will raise an error if the objects do not implement
        the names interfaces. However, they can implement them implicitly; they
        don't need to use the zope machinery to explicitly assert that they
        implement them.

        """

        verifyObject(IApp, app, tentative=True)
        verifyClass(ITransaction, app.Transaction, tentative=True)

        return app


    def get_app(self, __):
        """Get an app object to represent this application.

        For the root directory, we support automatically falling back to
        DefaultApp. Otherwise, we fail if there is no importable app. Also note
        that we snapshot available modules and then roll them back to force a
        reload next time they are imported. Since this is only called in
        development mode we should be golden.

        """

        if __ is None: # guaranteed by Config to only be true for the root
            return DefaultApp

        try:
            fp, pathname, description = imp.find_module('app', [__])
            app = imp.load_module('app', fp, pathname, description)
            log(98, "Successfully imported %s from %s." % (app, __))
        except:
            raise ImportError("Failed to import app from %s." % __)

        return app
