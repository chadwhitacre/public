import linecache
import os
import pdb
import sys
import traceback

from zope.interface import implements
from zope.server.interfaces import ITask

import httpy
from httpy.utils import log
from httpy.DefaultApp import DefaultTransaction
from httpy.Response import Response
from httpy.Response import STATUS_CODES


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""


class Task:
    """Represents the task of serving a single HTTP Request.

    The zope.server machinery instantiates this once for each HTTP request, and
    calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        self.server = channel.server
        self.config = self.server.config
        self.apps = self.server.apps
        self.channel = channel
        self.request = request
        if int(os.environ.get('HTTPY_VERBOSITY', 0)) >= 99:
            request_lines = request.raw.splitlines()
            raw_request = os.linesep.join(request_lines)
            log(99, raw_request)


    # Fulfill our contracts as an ITask implementor.
    # ==============================================

    def service(self):

        self.out = self.channel

        try:
            self.process()
        except Response, response:
            self.respond(response)
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        pass


    def defer(self):
        pass




    # Read-side methods.
    # ==================
    # process, get_transaction, map_path

    def process(self):
        """Execute one transaction.

        Transaction.process is expected to raise a Response or other exception.

        """

        # Do extra work in development mode.
        # ==================================
        # We want to see changes made during development without restarting the
        # server, so we track all modules that the app imports and remove them
        # again after app has been instantiated. The call to clearcache prevents
        # the accuracy of line numbers in tracebacks from degrading over time.

        dev_mode = self.config['mode'] == 'development'
        if dev_mode:
            log(97, "Snapshotting available modules.")
            base_modules = sys.modules.keys()
            linecache.clearcache()


        # Setup per-request configuration.
        # ================================
        # If the app to be used for the request does not have a magic
        # directory, and it is not the site root, then raise a 500.
        # For the site root we will revert to the DefaultApp.

        site_fs_root = self.config['root']
        apps = self.config['apps']

        app_uri_root, app_fs_root, __  = self.map_path( site_fs_root
                                                      , apps
                                                      , self.request.path
                                                       )

        log(97, "Found site_fs_root: %s" % site_fs_root)
        log(97, "Found app_uri_root: %s" % app_uri_root)
        log(97, "Found app_fs_root: %s" % app_fs_root)
        log(97, "Found magic directory: %s" % __)

        _config = {}
        _config['mode'] = self.config['mode']
        _config['verbosity'] = self.config['verbosity']
        _config['site_fs_root'] = site_fs_root
        _config['app_uri_root'] = app_uri_root
        _config['app_fs_root'] = app_fs_root
        _config['__'] = __
        config = _config


        # Get the app and instantiate its Transaction.
        # ============================================

        transaction = self.apps[__].Transaction(config)
        log(98, "Successfully instantiated a transaction.")


        # Take over sys.path so that __ functions like site-packages.
        # ===========================================================
        # A single website may have multiple applications, and therefore
        # multiple magic directories. We want these to be isolated per-request
        # for both deployment and development situations, so that applications
        # don't get confused importing from each other. We also do this at
        # import time in AppCache.

        _path = None
        if __ and __ not in sys.path:
            log(98, "Influencing sys.path at run time.")
            _path = sys.path[:]
            sys.path.insert(0, __)


        # Hand off the request to Transaction.process.
        # ============================================
        # The flow is somewhat complicated by our manipulations of sys.path
        # and sys.modules, and the fact that in development mode we want to
        # drop into the post-mortem debugger when there is an exception.

        if not dev_mode:
            try:
                transaction.process(self.request)
            finally:
                if _path:
                    sys.path = _path
                    log(98, "sys.path restored at run time.")
        else:
            try:
                try:
                    transaction.process(self.request)
                finally:
                    for module in sys.modules.keys():
                        if module not in base_modules:
                            del(sys.modules[module])
                    log(97, "Reverted to original modules.")
                    if _path:
                        sys.path = _path
                        log(98, "sys.path restored at run time.")
            except Response:
                raise
            except:
                log(90, traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        log(90, "%s.process did not raise anything." % str(transaction))
        raise Response(500)


    def map_path(self, site_root, apps, path):
        """Map the requested URI-path to the filesystem path of an application.

        This method takes a website's filesystem root, a list of application URI
        roots, and the requested URI path. It returns the filesystem root of the
        application to be used for this request, and the filesystem path of the
        application's magic directory. If the application does not have a magic
        directory, an error is raised, unless the app is the root app, in which
        case None is returned for the magic directory.

        """

        # Find an application directory that matches the requested URI-path.
        # ==================================================================
        # The last element in apps is always '/', so we are guaranteed of at
        # least one match.

        for _app in apps:
            if path.startswith(_app):
                app = _app
                break
        app_root = os.path.realpath(os.path.join(site_root, app.lstrip('/')))
        path = os.path.realpath(os.path.join(app_root, path.lstrip('/')))

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(403)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================
        # If there is no magic directory, then we raise an error, unless we
        # are serving from the site root.

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            if app_root == site_root:
                __ = None
            else:
                response = Response(500)
                response.body = ("The non-root application at %s " % app_root +
                                 "does not contain a magic directory.")
                response.app_root = app_root
        if __ and path.startswith(__):
            raise Response(404)


        return (app, app_root, __)




    # Write-side methods.
    # ==================
    # respond, fail

    def respond(self, response):
        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase, reason_message = STATUS_CODES.get(response.code)

        if not response.body:
            response.body = reason_message
        status_line = "%s %s %s\r\n" % ( self.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.out.write(status_line)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if not str(response.code).startswith('2'):
                # Error messages default to text/plain.
                headers['content-type'] = 'text/plain'
            else:
                # But setting this header for successful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write("\r\n")


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if response.code == 304:
            pass
        elif not hasattr(self, 'request_'):
            # We are handling a parsing error in Request().
            self.out.write(response.body)
        elif self.request_.method != 'HEAD':
            self.out.write(response.body)

        log(94, "Responded to %s with %d %s" % ( self.request.raw_line
                                               , response.code
                                               , reason_phrase)
                                                )
        log(99, "%s\n\n" % ("="*76))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.server.config['mode'] == 'development':
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.items():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
