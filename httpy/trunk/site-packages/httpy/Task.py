import linecache
import os
import pdb
import sys
import traceback

from zope.interface import implements
from zope.server.interfaces import ITask

import httpy
from httpy.utils import log
from httpy.DefaultApp import DefaultTransaction
from httpy.Request import Request
from httpy.Response import Response
from httpy.Response import STATUS_CODES


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""


class Task:
    """Represents the task of serving a single HTTP Request.

    The zope.server machinery instantiates this once for each HTTP request, and
    calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        """Takes a zope.server.channel and an httpy.Request.
        """
        self.channel = channel
        self.request = Request(request)

        self.config = self.configure(self.channel.server.config.copy())
        self.dev_mode = self.config['mode'] == 'development'

        if int(os.environ.get('HTTPY_VERBOSITY', 0)) >= 99:
            request_lines = request.raw.splitlines()
            raw_request = os.linesep.join(request_lines)
            log(99, raw_request)


    def configure(self, server_config):
        """Build a config dict for a Transaction rather than a Server.
        """

        site_fs_root = server_config['root']
        apps = server_config['apps']
        app_uri_root, app_fs_root, __  = self.map_path( site_fs_root
                                                      , apps
                                                      , self.request.path
                                                       )

        log(97, "Found site_fs_root: %s" % site_fs_root)
        log(97, "Found app_uri_root: %s" % app_uri_root)
        log(97, "Found app_fs_root: %s" % app_fs_root)
        log(97, "Found magic directory: %s" % __)

        config = {}
        config['mode'] = server_config['mode']
        config['verbosity'] = server_config['verbosity']
        config['site_fs_root'] = site_fs_root
        config['app_uri_root'] = app_uri_root
        config['app_fs_root'] = app_fs_root
        config['__'] = __

        return config


    def map_path(self, site_root, apps, path):
        """Map the requested URI-path to the filesystem path of an application.

        This method takes a website's filesystem root, a list of application URI
        roots, and the requested URI path. It returns the following:

            - the URI-root of the application to be used for this request
            - the filesystem root of said application
            - the filesystem path of said application's magic directory

        If the application does not have a magic directory, an error is raised,
        unless the app is the root app, in which case None is returned for the
        magic directory.

        """

        # Find an application directory that matches the requested URI-path.
        # ==================================================================
        # The last element in apps is always '/', so we are guaranteed of at
        # least one match.

        for _app in apps:
            if path.startswith(_app):
                app = _app
                break
        app_root = os.path.realpath(os.path.join(site_root, app.lstrip('/')))
        path = os.path.realpath(os.path.join(app_root, path.lstrip('/')))

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(403)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================
        # If there is no magic directory, then we raise an error, unless we
        # are serving from the site root.

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            if app_root == site_root:
                __ = None
            else:
                response = Response(500)
                response.body = ("The non-root application at %s " % app_root +
                                 "does not contain a magic directory.")
                response.app_root = app_root
                raise response
        if __ and path.startswith(__):
            raise Response(404)


        return (app, app_root, __)




    # Read-side methods
    # =================
    # Be sure to fulfill our contracts as an ITask implementor.

    def service(self):
        """ITask
        """

        self.out = self.channel

        try:
            self.process()
        except Response, response:
            self.respond(response)
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        """ITask
        """
        pass


    def defer(self):
        """ITask
        """
        pass


    def process(self):
        """Execute one transaction.

        The call to Transaction.process is complicated by our manipulations of
        sys.path and sys.modules, and the fact that in development mode we want
        to drop into the post-mortem debugger when there is an exception (other
        than Response, of course).

        Transaction.process is expected to raise a Response or other exception.

        """

        transaction = self.apps[__].Transaction(self.config)
        log(96, "Successfully instantiated a transaction.")

        def go():
            gaoler.capture_path(__)
            try:
                transaction.process(self.request)
            finally:
                gaoler.release_path()

        if not dev_mode:
            go()
        else:
            try:
                go()
            except Response:
                raise
            except:
                log(90, traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        log(90, "%s.process did not raise anything." % str(transaction))
        raise Response(500)




    # Write-side methods.
    # ==================
    # respond, fail

    def respond(self, response):
        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase, reason_message = STATUS_CODES.get(response.code)

        if not response.body:
            response.body = reason_message
        status_line = "%s %s %s\r\n" % ( self.channel.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.out.write(status_line)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if not str(response.code).startswith('2'):
                # Error messages default to text/plain.
                headers['content-type'] = 'text/plain'
            else:
                # But setting this header for successful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.channel.server.response_header

        for header in headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write("\r\n")


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if response.code == 304:
            pass
        elif not hasattr(self, 'request_'):
            # We are handling a parsing error in Request().
            self.out.write(response.body)
        elif self.request_.method != 'HEAD':
            self.out.write(response.body)

        log(94, "Responded to %s with %d %s" % ( self.request.raw_line
                                               , response.code
                                               , reason_phrase)
                                                )
        log(99, "%s\n\n" % ("="*76))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.channel.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.dev_mode:
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.items():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
