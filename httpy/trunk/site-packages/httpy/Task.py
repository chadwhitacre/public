import os
import pdb
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.server.interfaces import ITask

import httpy
from httpy.Config import TransactionConfig
from httpy.Request import Request
from httpy.Response import Response, STATUS_CODES
from httpy.utils import log, uri_to_fs


class Task:
    """Represents the task of serving a single HTTP Request.

    The httpy._zope.server machinery instantiates this once for each HTTP
    request, and calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        """Takes an IServerChannel (httpy._zope) and an IRequest (httpy).
        """

        try:
            # Set these early in case we fail.
            self.channel        = channel
            self.server_config  = self.channel.server.config
            self.dev_mode       = self.server_config.mode == 'development'
            self.mtimes         = {}

            # This is where we are likely to fail.
            self.request    = Request(request)
            self.app        = self.find_app()

            if int(os.environ.get('HTTPY_VERBOSITY', 0)) >= 99:
                request_lines = request.raw.splitlines()
                raw_request = os.linesep.join(request_lines)
                log(99, raw_request)

        except:
            self.fail()


    def find_app(self):
        """Find an app with which to serve the requested URI.
        """

        app = None
        for _app in self.server_config.apps:
            if self.request.path.startswith(_app.uri_root):
                app = _app
                break
        if app is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Exception("Unable to find an application to serve " +
                            "%s." % self.request.path)

        log(98, "Using %s for this request" % app)
        return app


    # ITask contracts
    # ===============
    # service, cancel, defer

    def service(self):

        try:
            self.process()
        except Response, response:
            self.respond(response)
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        self.channel.close_when_done()


    def defer(self):
        pass


    # Process
    # =======

    def process(self):
        """Execute one transaction.

        The call to Transaction.process is complicated by the fact that in
        development mode we want to drop into the post-mortem debugger when
        there is an exception (other than Response, of course).

        Transaction.process is expected to raise a Response or other exception.

        """

        config = TransactionConfig(self.app, self.server_config)


        # Do some late validation so we can use Response.
        # ===============================================

        resource_fs_path = uri_to_fs(config, self.request.path, raw=True)

        # Is the app still on the filesystem?
        if not os.path.isdir(config.app_fs_root):
            raise Response(404)

        if config.__:

            # Is the app's magic directory still on the filesystem?
            if not os.path.isdir(config.__):
                response = Response(500)
                response.body = ("The application's magic directory has " +
                                 "disappeared.")
                raise response

            # Protect the magic directory from direct access.
            if resource_fs_path.startswith(config.__):
                raise Response(404)


        # Get out of the way.
        # ===================

        transaction = self.app.module.Transaction(config)
        if not self.dev_mode:
            transaction.process(self.request)
        else:
            try:
                transaction.process(self.request)
            except Response:
                raise
            except:
                log(90, traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        response = Response(500)
        response.body = "%s.process did not raise anything." % str(transaction)
        raise response


    # Write-side methods
    # ==================
    # respond, fail

    def respond(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            raise Exception("Bad response code: %r" % response.code)
        reason_phrase, reason_message = STATUS_CODES.get(response.code)
        if not response.body:
            response.body = reason_message
        status_line = ' '.join(( str(self.channel.server.http_version_string)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.channel.write(status_line + '\r\n')


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.iteritems():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[header] = v

        if 'content-length' not in headers: # always true
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if str(response.code).startswith('2'):
                # Setting this header for successful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
            else:
                # But error messages default to text/plain.
                headers['content-type'] = 'text/plain'
        if 'server' not in headers:
            headers['server'] = self.channel.server.response_header

        for header in headers.iteritems():
            self.channel.write("%s: %s\r\n" % header)

        self.channel.write('\r\n')


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if (response.code != 304) and (self.request.method != 'HEAD'):
            self.channel.write(response.body)

        log(94, "Responded to %s with %d %s" % ( self.request.raw_line
                                               , response.code
                                               , reason_phrase)
                                                )
        log(99, "%s\n\n" % ("="*76))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.channel.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        failure = "Internal Server Error\r\n\r\n%s"
        if self.dev_mode:
            body = failure % traceback.format_exc()
        else:
            body = failure % ''

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'


        # Send the response.
        # ==================

        self.channel.write(status_line)
        for header in sorted(headers.items()):
            self.channel.write('%s: %s\r\n' % header)
        self.channel.write('\r\n')
        self.channel.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
