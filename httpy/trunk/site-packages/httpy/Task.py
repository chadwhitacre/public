import os
import pdb
import pprint
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.server.interfaces import ITask

import httpy
from httpy.Request import Request
from httpy.Response import Response, StatusCodes
from httpy.utils import log, uri_to_fs


class Task:
    """Represents the task of serving a single HTTP Request.

    The httpy._zope.server machinery instantiates this once for each HTTP
    request, and calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        """Takes an IServerChannel (httpy._zope) and an IRequest (httpy).
        """

        try:
            # Set these early in case we fail.
            self.channel    = channel
            self.server     = self.channel.server

            # This is where we are likely to fail.
            self.request    = Request(request)
            self.app        = self.get_app()

            if int(os.environ.get('HTTPY_VERBOSITY', 0)) >= 99:
                request_lines = request.raw.splitlines()
                raw_request = os.linesep.join(request_lines)
                log(99, raw_request)

        except:
            self.fail()


    def get_app(self):
        """Get an application with which to serve the requested URI.
        """

        app = None
        for _app in self.server.config.apps:
            if self.request.path.startswith(_app.uri_root):
                app = _app
                break
        if app is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise StandardError("Unable to find an application to serve " +
                                "%s." % self.request.path)

        log(98, "Using %s for this request" % app)
        return app


    # ITask contracts
    # ===============
    # service, cancel, defer

    def service(self):

        try:
            self.respond()
        except Response, response:
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        self.channel.close_when_done()


    def defer(self):
        pass


    # Process
    # =======

    def respond(self):
        """Execute one transaction.

        The call to Application.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        Application.respond is expected to raise a Response or other exception.

        """


        # Do some late validation so we can use Response.
        # ===============================================

        resource_fs_path = uri_to_fs( self.app.site_root
                                    , self.app.fs_root
                                    , self.app.uri_root
                                    , self.request.path
                                    , raw=True
                                     )

        # Is the app still on the filesystem?
        if not os.path.isdir(self.app.fs_root):
            raise Response(404)

        if self.app.__:

            # Is the app's magic directory still on the filesystem?
            if not os.path.isdir(self.app.__):
                raise Response(500, "The application's magic directory has " +
                                    "disappeared.")

            # Protect the magic directory from direct access.
            if resource_fs_path.startswith(self.app.__):
                raise Response(404)


        # Get out of the way.
        # ===================

        if not self.server.debug_mode:
            self.app.respond(self.request)
        else:
            try:
                self.app.respond(self.request)
            except Response:
                raise
            except:
                log(90, traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        raise Response(500, "%s.respond did not raise " % str(application) +
                            "anything.")


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in StatusCodes:
            raise StandardError("Bad response code: %r" % response.code)
        elif (response.code == 537) and self.server.deploy_mode:
            raise StandardError("Won't serve 537 in deployment mode.")
        reason_phrase, reason_message = StatusCodes.get(response.code)
        status_line = ' '.join(( str(self.server.http_version_string)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.channel.write(status_line + '\r\n')


        # Generate the body.
        # ==================
        # We do this here so we can calculate the content-length.

        if (not response.body) and (response.code not in (200, 537)):
            response.body = reason_message
        if response.code == 537:
            if not isinstance(response.body, basestring):
                response.body = pprint.pformat(response.body)
        response.body = str(response.body)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.iteritems():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[header] = v

        if 'content-length' not in headers: # always true
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if str(response.code).startswith('2'):
                # Setting this header for successful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
            else:
                # But error messages default to text/plain.
                headers['content-type'] = 'text/plain'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.channel.write("%s: %s\r\n" % header)

        self.channel.write('\r\n')


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if (response.code != 304) and (self.request.method != 'HEAD'):
            self.channel.write(response.body)

        log(94, "Responded to %s with %d %s" % ( self.request.raw_line
                                               , response.code
                                               , reason_phrase)
                                                )
        log(99, "%s\n\n" % ("="*76))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.server.deploy_mode:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback.format_exc()

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'


        # Send the response.
        # ==================

        self.channel.write(status_line)
        for header in sorted(headers.items()):
            self.channel.write('%s: %s\r\n' % header)
        self.channel.write('\r\n')
        self.channel.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
