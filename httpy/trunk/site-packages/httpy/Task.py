import imp
import linecache
import os
import sys
import traceback

from zope.interface import implements
from zope.server.interfaces import ITask

import httpy
from httpy import DefaultApp
from httpy import log
from httpy.Response import Response
from httpy.Response import STATUS_CODES
from httpy.RollbackImporter import RollbackImporter


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""


class Task:
    """Represents the task of serving a single HTTP Request.

    The zope.server machinery instantiates this once for each HTTP request, and
    calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        self.server = channel.server
        self.channel = channel
        self.request = request


    # Fulfill our contracts as an ITask implementor.
    # ==============================================

    def service(self):

        self.out = self.channel

        try:
            self.process()
        except Response, response:
            self.respond(response)
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        pass


    def defer(self):
        pass


    # Read-side methods.
    # ==================
    # process, get_transaction, translate

    def process(self):
        """Execute one transaction.

        Transaction.process is expected to raise a Response or other exception.

        """

        # If we are in development mode, refresh all modules.
        # ===================================================
        # We want to see changes made during development without restarting
        # the server. The call to clearcache prevents the accuracy of line
        # numbers in tracebacks from degrading over time.

        if self.server.config['mode'] == 'development':
            log(97, "Snapshotting available modules.")
            self.rollbackImporter = RollbackImporter()
            linecache.clearcache()


        # Instantiate and invoke a Transaction.
        # =====================================

        transaction = self.get_transaction( self.server.config.copy()
                                          , self.request.path
                                           )
        log(98, "Successfully instantiated a transaction.")
        try:
            transaction.process(self.request)
        finally:
            if self.server.config['mode'] == 'development':
                log(97, "Resetting available modules.")
                self.rollbackImporter.uninstall()


        # Bad process! No soup for you!
        # =============================

        log(90, "%s.process did not raise anything." % str(transaction))
        raise Response(500)


    def get_transaction(self, config, uri_path):
        """Return an instance of a Transaction appropriate to the request.

        This method takes a copy of the server's configuration dictionary, and
        the requested URI-path. It then translates the requested URI to one of
        the pre-registered app paths. If the following conditions are met, we
        use a Transaction from the registered app. Otherwise we default to
        httpy.app.Transaction.

            - The directory at app_root must have a subdirectory named `__'.
            - There must be a module `app.py', or a package `app', in `__'.
            - The app module/package must have a `Transaction' class.
            - app.Transaction must have a callable named `process'.

        We could certainly do better validation here: make sure that Transaction
        is a class, and that __init__ and process take the right number of
        arguments, etc.

        FWIW, this method started life as the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        # Setup per-request configuration.
        # ================================

        root = config['root']
        apps = config['apps']

        app_root, __  = self.translate(root, apps, uri_path)

        _config = {}
        _config['mode'] = config['mode']
        _config['verbosity'] = config['verbosity']
        _config['root'] = app_root
        _config['__'] = __
        config = _config


        # Find a usable app.
        # ==================
        # We should prolly keep an app cache on self.server.

        if not __:
            log(95, "No magic directory found in %s. Falling " % app_root +
                    "back to httpy.DefaultApp")
            app = DefaultApp
        else:
            log(98, "Found magic directory at %s; will look for app." % __)


            # Take over sys.path so that __ functions like site-packages.
            # ===========================================================
            # A single website may have multiple applications, and therefore
            # multiple magic directories. We want these to be isolated per-
            # request, so that applications don't get confused importing from
            # each other.

            _path = sys.path[:]
            sys.path.insert(0, __)


            # Attempt to import an application from the magic directory.
            # ==========================================================
            # Having a magic directory is a promise that there is an
            # application in there.

            try:
                try:
                    import app
                    log(98, "app has been imported.")
                finally:
                    sys.path = _path
                    log(98, "sys.path restored.")
            except:
                log(90, "Failed to import app from %s." % __)
                raise


            # Validate the app.
            # =================
            # I'm guessing this could be done with interfaces.

            if not hasattr(app, 'Transaction'):
                raise Exception("Unable to import Transaction from app at " +
                                "%s." % __)

            if not hasattr(app.Transaction, 'process'):
                raise Exception("The app.Transaction in %s does not " % __ +
                                "have a `process' method.")

            if not callable(app.Transaction.process):
                raise Exception("app.Transaction.process from %s is " % __ +
                                "not callable.")


        # Return an instance of the Transaction.
        # ======================================

        log(98, "Found a transaction to use: %s." % str(app.Transaction))
        return app.Transaction(config)


    def translate(self, root, apps, path):
        """Map the requested path to the filesystem path of an application.

        This method takes a website's filesystem-root, a list of application
        URI-roots, and the requested URI-path. It returns the filesystem-root of
        the application to be used for this request, and the filesystem-path of
        the application's magic directory, or None if the application does not
        have a magic directory.

        """

        # Find an application directory that matches the requested URI-path.
        # ==================================================================
        # The website root is always an implicit application. The first-named
        # app will match first.

        app = '/'
        for _app in apps:
            if path.startswith(_app):
                app = _app
                break
        app_root = os.path.realpath(os.path.join(root, app.lstrip('/')))
        path = os.path.realpath(os.path.join(app_root, path.lstrip('/')))

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(403)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            __ = None
        if __ and path.startswith(__):
            raise Response(404)


        return (app_root, __)


    # Write-side methods.
    # ==================
    # respond, fail

    def respond(self, response):
        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase, reason_message = STATUS_CODES.get(response.code)

        if not response.body:
            response.body = reason_message
        status_line = "%s %s %s\r\n" % ( self.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.out.write(status_line)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if not str(response.code).startswith('2'):
                # Error messages default to text/plain.
                headers['content-type'] = 'text/plain'
            else:
                # But setting this header for succesful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write("\r\n")


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if response.code == 304:
            pass
        elif not hasattr(self, 'request_'):
            # We are handling a parsing error in Request().
            self.out.write(response.body)
        elif self.request_.method != 'HEAD':
            self.out.write(response.body)

        log(94, "Responded with %d %s" % (response.code, reason_phrase))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.server.config['mode'] == 'development':
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.items():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
