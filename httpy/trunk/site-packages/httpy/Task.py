import imp
import linecache
import os
import pdb
import sys
import traceback

from zope.interface import implements
from zope.server.interfaces import ITask

import httpy
from httpy import DefaultApp
from httpy import log
from httpy.Response import Response
from httpy.Response import STATUS_CODES


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""


class Task:
    """Represents the task of serving a single HTTP Request.

    The zope.server machinery instantiates this once for each HTTP request, and
    calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        self.server = channel.server
        self.config = self.server.config
        self.channel = channel
        self.request = request


    # Fulfill our contracts as an ITask implementor.
    # ==============================================

    def service(self):

        self.out = self.channel

        try:
            self.process()
        except Response, response:
            self.respond(response)
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        pass


    def defer(self):
        pass


    # Read-side methods.
    # ==================
    # process, get_transaction, map_path

    def process(self):
        """Execute one transaction.

        Transaction.process is expected to raise a Response or other exception.

        """

        # Do extra work in development mode.
        # ==================================
        # We want to see changes made during development without restarting the
        # server, so we track all modules that the app imports and remove them
        # again after app has been instantiated. The call to clearcache prevents
        # the accuracy of line numbers in tracebacks from degrading over time.

        dev_mode = self.config['mode'] == 'development'
        if dev_mode:
            log(97, "Snapshotting available modules.")
            base_modules = sys.modules.keys()
            linecache.clearcache()


        # Setup per-request configuration.
        # ================================

        root = self.config['root']
        apps = self.config['apps']

        app_root, __  = self.map_path(root, apps, self.request.path)

        _config = {}
        _config['mode'] = self.config['mode']
        _config['verbosity'] = self.config['verbosity']
        _config['root'] = app_root
        _config['__'] = __
        config = _config


        # Take over sys.path so that __ functions like site-packages.
        # ===========================================================
        # A single website may have multiple applications, and therefore
        # multiple magic directories. We want these to be isolated per-request,
        # so that applications don't get confused importing from each other.

        log(98, "Influencing sys.path.")
        _path = sys.path[:]
        sys.path.insert(0, __)


        # Instantiate and invoke a Transaction.
        # =====================================

        Transaction = self.get_transaction(__)
        transaction = Transaction(config)
        log(98, "Successfully instantiated a transaction.")

        if not dev_mode:
            try:
                transaction.process(self.request)
            finally:
                sys.path = _path
                log(98, "sys.path restored.")
        else:
            try:
                try:
                    transaction.process(self.request)
                finally:
                    for module in sys.modules.keys():
                        if module not in base_modules:
                            del(sys.modules[module])
                    log(97, "Reverted to original modules.")
                    sys.path = _path
                    log(98, "sys.path restored.")
            except Response:
                raise
            except:
                log(90, traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # Bad process! No soup for you!
        # =============================

        log(90, "%s.process did not raise anything." % str(transaction))
        raise Response(500)


    def get_transaction(self, __):
        """Given a magic directory, return a Transaction class.

        If the following conditions are met, we use a Transaction from the
        registered app. Otherwise we default to httpy.app.Transaction.

            - There must be a module `app.py', or a package `app', in __.
            - The app module/package must have a `Transaction' class.
            - app.Transaction must have a callable named `process'.

        We could certainly do better validation here: make sure that Transaction
        is a class, and that __init__ and process take the right number of
        arguments, etc.

        """

        # Find a usable app.
        # ==================
        # We should prolly keep an app cache on self.server.

        if not __:
            log(95, "No magic directory found; falling back to default app.")
            app = DefaultApp
        else:
            log(98, "Found magic directory at %s; will look for app." % __)


            # Attempt to import an application from the magic directory.
            # ==========================================================
            # Having a magic directory is a promise that there is an
            # application in there.

            try:
                import app
                log(98, "app has been imported.")
            except:
                log(90, "Failed to import app from %s." % __)
                raise


            # Validate the app.
            # =================
            # I'm guessing this could be done with interfaces.

            if not hasattr(app, 'Transaction'):
                raise Exception("Unable to import Transaction from app at " +
                                "%s." % __)

            if not hasattr(app.Transaction, 'process'):
                raise Exception("The app.Transaction in %s does not " % __ +
                                "have a `process' method.")

            if not callable(app.Transaction.process):
                raise Exception("app.Transaction.process from %s is " % __ +
                                "not callable.")


        # Return the app's Transaction.
        # =============================

        log(98, "Found a transaction to use: %s." % str(app.Transaction))
        return app.Transaction


    def map_path(self, root, apps, path):
        """Map the requested path to the filesystem path of an application.

        This method takes a website's filesystem-root, a list of application
        URI-roots, and the requested URI-path. It returns the filesystem-root of
        the application to be used for this request, and the filesystem-path of
        the application's magic directory, or None if the application does not
        have a magic directory.

        """

        # Find an application directory that matches the requested URI-path.
        # ==================================================================
        # The website root is always an implicit application. The first-named
        # app will match first.

        app = '/'
        for _app in apps:
            if path.startswith(_app):
                app = _app
                break
        app_root = os.path.realpath(os.path.join(root, app.lstrip('/')))
        path = os.path.realpath(os.path.join(app_root, path.lstrip('/')))

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(403)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            __ = None
        if __ and path.startswith(__):
            raise Response(404)


        return (app_root, __)




    # Write-side methods.
    # ==================
    # respond, fail

    def respond(self, response):
        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase, reason_message = STATUS_CODES.get(response.code)

        if not response.body:
            response.body = reason_message
        status_line = "%s %s %s\r\n" % ( self.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.out.write(status_line)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if not str(response.code).startswith('2'):
                # Error messages default to text/plain.
                headers['content-type'] = 'text/plain'
            else:
                # But setting this header for successful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write("\r\n")


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if response.code == 304:
            pass
        elif not hasattr(self, 'request_'):
            # We are handling a parsing error in Request().
            self.out.write(response.body)
        elif self.request_.method != 'HEAD':
            self.out.write(response.body)

        log(94, "Responded with %d %s" % (response.code, reason_phrase))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.server.config['mode'] == 'development':
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.items():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
