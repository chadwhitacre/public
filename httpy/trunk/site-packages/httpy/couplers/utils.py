"""Centralize some coupler logic.
"""
import logging
import pdb
import pprint
import sys
import time
import traceback
from email.Utils import formatdate

import httpy
from httpy._zope.interface.verify import verifyObject
from httpy._zope.server.http.http_date import monthname
from httpy.interfaces import IResponder
from httpy.request import Request
from httpy.response import Response, StatusCodes
from httpy.utils import isiter


class AccessLogger:
    """Based on zope.server.http.commonaccesslogger.CommonAccessLogger.
    """

    def compute_timezone_for_log(self, tz):
        if tz > 0:
            neg = 1
        else:
            neg = 0
            tz = -tz
        h, rem = divmod (tz, 3600)
        m, rem = divmod (rem, 60)
        if neg:
            return '-%02d%02d' % (h, m)
        else:
            return '+%02d%02d' % (h, m)

    tz_for_log = None
    tz_for_log_alt = None

    def log_date_string(self, when):
        logtime = time.localtime(when)
        Y, M, D, h, m, s = logtime[:6]

        if not time.daylight:
            tz = self.tz_for_log
            if tz is None:
                tz = self.compute_timezone_for_log(time.timezone)
                self.tz_for_log = tz
        else:
            tz = self.tz_for_log_alt
            if tz is None:
                tz = self.compute_timezone_for_log(time.altzone)
                self.tz_for_log_alt = tz

        return '%d/%s/%02d:%02d:%02d:%02d %s' % (
            D, monthname[M], Y, h, m, s, tz)

    def log(self, IP, request, response):
        """Given an IP, a Request and a Response, log the resource access.
        """
        now = time.time()

        user_name = '-' # task.auth_user_name or 'anonymous'
        user_agent = request.headers.get('USER_AGENT', '')
        referer = request.headers.get('REFERER', '')

        args = ( IP
               , user_name
               , self.log_date_string(now)
               , request.raw_line
               , response.code
               , response.headers['Content-Length']
               , request.headers.get('Referer', '')
               , request.headers.get('User-Agent', '')
                )

        sys.stdout.write('%s - %s [%s] "%s" %s %d "%s" "%s"\n' % args)
        sys.stdout.flush()


access_logger = AccessLogger()
error_logger = logging.getLogger('httpy.couplers.utils')


class Deliver:
    """Construct a 'deliver' callable.

    This is a convenience method for couplers, centralizing basic HTTP logic.
    Couplers differentiate on how to construct a Request and how to decide which
    wire to write to. Couplers should instantiate this once per request, and
    call the instance to capture responses and write them out to the wire.

    Coupler authors will generally have to know what they're doing. However, we
    need to be ready to get just about anything from a responder.

    """

    def __init__(self, make_request, responder, out):
        """Takes a function, an IResponder, and an output buffer.

        We take a make_request function instead of an actual Request object so
        that coupler authors can raise Response(400) errors in their Request
        constructor.

        """
        self.make_request = make_request
        self.responder = responder
        self.out = out


    def __call__(self, *args, **kwargs):
        """All arguments are passed through to make_request.
        """
        try:
            self.request = self.make_request(*args, **kwargs)
            response = self.respond(self.request)
            self.deliver(response)
        except Response, response:
            error_logger.error( "Error response raised from:\n"
                              + traceback.format_exc()
                               )
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()


    def respond(self, request):
        """Execute one transaction.

        The call to responder.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        responder.respond is expected to return a Response. It may also raise a
        Response or other exception.

        """

        if not httpy.mode.IS_DEBUG:
            response = self.responder.respond(request)
        else:
            try:
                response = self.responder.respond(request)
            except Response, response:
                pass # move along
            except:
                error_logger.debug(traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise

        if response is None:
            error_logger.warning('Responder %s returned None' % str(self.responder))
            return Response(500)
        elif isinstance(response, Response):
            return response
        else:
            response = Response(200, unicode(response).encode('UTF-8'))
            response.headers = {'Content-Type':'text/html; charset=UTF-8'}
            return response


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        # Generate the body and output the Status-Line.
        # =============================================

        reason_phrase = '<no phrase>'
        if response.code in StatusCodes:
            reason_phrase, reason_message = StatusCodes.get(response.code)
            if (not response.body) and (response.code != 200):
                response.body = reason_message
        status_line = ' '.join(( str(httpy.HTTP_VERSION_STRING)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.out.write(status_line + '\r\n')



        # Output the headers.
        # ===================
        # Make sure we have Content-Type, Content-Length, Date, and Server.

        if 'Content-Type' not in response.headers:
            if 200 <= response.code <= 299:
                # Content-Type defaults to text/html for successful requests
                response.headers['Content-Type'] = 'text/html'
            else:
                # ... and to text/plain for errors.
                response.headers['Content-Type'] = 'text/plain'
        if 'Content-Length' not in response.headers:
            if isiter(response.body):
                response.body = ''.join(list(response.body))
            response.headers['Content-Length'] = len(response.body)
        if 'Date' not in response.headers:
            response.headers['Date'] = formatdate(usegmt=True)
        if 'Server' not in response.headers:
            response.headers['Server'] = httpy.RESPONSE_HEADER

        for header in response.headers.items():
            self.out.write("%s: %s\r\n" % header)

        self.out.write('\r\n')
        if hasattr(self.out, 'flush'):
            self.out.flush()


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        want_body = (   (response.code != 304)
                    and (hasattr(self, 'request'))
                    and (self.request.method != 'HEAD')
                       )

        if want_body:
            if isinstance(response.body, basestring):
                self.out.write(response.body)
            elif isiter(response.body):
                for n in response.body:
                    self.out.write(n)
            else:
                raise StandardError( "Bad response body type: " +
                                     "'%s'" % type(response.body)
                                    )

        if hasattr(self.out, 'flush'):
            self.out.flush()


        # Log the resource access.
        # ========================

        access_logger.log(self.out.addr[0], self.request, response)


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        traceback_ = traceback.format_exc()
        error_logger.critical("Traceback follows.\n%s" % traceback_)


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( httpy.HTTP_VERSION_STRING
                                       , 500
                                       , "Internal Server Error"
                                        )

        if httpy.mode.IS_DEPLOYMENT or httpy.mode.IS_STAGING:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback_

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'
        try:
            headers['Date'] = formatdate(usegmt=True)
            headers['Server'] = httpy.RESPONSE_HEADER
        except:
            pass


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.iteritems():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)
        if hasattr(self.out, 'flush'):
            self.out.flush()


        # Log the failure.
        # ================

        response = Response(500)
        response.headers['Content-Length'] = len(body)
        access_logger.log(self.out.addr[0], self.request, response)
