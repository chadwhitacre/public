"""Centralize some coupler logic.
"""
import logging
import pdb
import pprint
import traceback
from email.Utils import formatdate

import httpy
from httpy._zope.interface.verify import verifyObject
from httpy.interfaces import IResponder
from httpy.request import Request
from httpy.response import Response, StatusCodes
from httpy.utils import isiter


logger = logging.getLogger('httpy.couplers.utils')


def add_api(responder, root, uri):
    """Given a responder, a filesystem path, and a URI, return the responder.
    """
    try:
        verifyObject(IResponder, responder, tentative=True)
    except:
        logger.debug("%s is not valid." % responder)
        raise
    if not hasattr(responder, 'uri'):
        responder.uri = uri
    if not hasattr(responder, 'root'):
        responder.root = root
    return responder


class make_deliver:
    """Construct a 'deliver' callable.

    This is a convenience method for couplers, centralizing basic HTTP logic.
    Couplers differentiate on how to construct a Request and how to decide which
    wire to write to. Couplers should instantiate this once per request, and
    call the instance to capture responses and write them out to the wire.

    Coupler authors will generally have to know what they're doing. However, we
    need to be ready to get just about anything from a responder.

    """

    def __init__(self, make_request, responder, out):
        """Takes a function, an IResponder, and an output buffer.

        We take a make_request function instead of an actual Request object so
        that coupler authors can raise Response(400) errors in their Request
        constructor.

        """
        self.make_request = make_request
        self.responder = responder
        self.out = out


    def __call__(self, *args, **kwargs):
        """All arguments are passed through to make_request.
        """
        try:
            self.request = self.make_request(*args, **kwargs)
            self.respond(self.request)
        except Response, response:
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()


    def respond(self, request):
        """Execute one transaction.

        The call to responder.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        responder.respond is expected to raise a Response or other exception.

        """

        if not httpy.mode.IS_DEBUG:
            self.responder.respond(request)
        else:
            try:
                self.responder.respond(request)
            except Response:
                raise # move along
            except:
                logger.debug(traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        raise Response(500, "%s.respond did not " % str(self.responder) +
                            "raise anything.")


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        logger.debug("Attempting to send a response.")
        logger.debug("Response lineage as follows:" +
                          "\n%s" % traceback.format_exc())


        # Generate the body and output the Status-Line.
        # =============================================

        reason_phrase = '<no phrase>'
        if response.code in StatusCodes:
            reason_phrase, reason_message = StatusCodes.get(response.code)
            if (not response.body) and (response.code != 200):
                response.body = reason_message
        status_line = ' '.join(( str(httpy.HTTP_VERSION_STRING)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.out.write(status_line + '\r\n')



        # Output the headers.
        # ===================
        # Make sure we have Content-Type, Content-Length, Date, and Server.

        lowered = [f.lower() for f in response.headers]
        if 'content-type' not in lowered:
            if 200 <= response.code <= 299:
                # Content-Type defaults to text/html for successful requests
                response.headers['Content-Type'] = 'text/html'
            else:
                # ... and to text/plain for errors.
                response.headers['Content-Type'] = 'text/plain'
        if 'content-length' not in lowered:
            if isiter(response.body):
                response.body = ''.join(list(response.body))
            response.headers['Content-Length'] = len(response.body)
        if 'date' not in lowered:
            response.headers['Date'] = formatdate(usegmt=True)
        if 'server' not in lowered:
            response.headers['Server'] = httpy.RESPONSE_HEADER

        for header in response.headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write('\r\n')
        if hasattr(self.out, 'flush'):
            self.out.flush()


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        want_body = (   (response.code != 304)
                    and (hasattr(self, 'request'))
                    and (self.request.method != 'HEAD')
                       )

        if want_body:
            if isinstance(response.body, basestring):
                self.out.write(response.body)
            elif isiter(response.body):
                for n in response.body:
                    self.out.write(n)
            else:
                raise StandardError( "Bad response body type: " +
                                     "'%s'" % type(response.body)
                                    )

        line = ''
        if hasattr(self, 'request'):
            line = self.request.raw_line
        args = (line, response.code, reason_phrase)
        logger.debug("Responded to %s with %d %s" % args)
        if hasattr(self.out, 'flush'):
            self.out.flush()


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        traceback_ = traceback.format_exc()
        logger.critical("Traceback follows.\n%s" % traceback_)


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( httpy.HTTP_VERSION_STRING
                                       , 500
                                       , "Internal Server Error"
                                        )

        if httpy.mode.IS_DEPLOYMENT or httpy.mode.IS_STAGING:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback_

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'
        try:
            headers['Date'] = formatdate(usegmt=True)
            headers['Server'] = httpy.RESPONSE_HEADER
        except:
            pass


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.iteritems():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)
        if hasattr(self.out, 'flush'):
            self.out.flush()



"""
TODO

range requests?
keep alive?

"""
