"""Centralize the logic for writing responses out to the wire.
"""
import logging
import pdb
import pprint
import traceback

import httpy
from httpy.request import Request
from httpy.response import Response, StatusCodes
from httpy.utils import Path


logger = logging.getLogger('httpy.couplers.utils')


try:
    # http://tautology.org/software/python-modules/sendfile
    # Note that sendfile.so is GPL! So be careful.
    import sendfile
    SENDFILE = True
except ImportError:
    SENDFILE = False

def isiter(foo):
    return hasattr(foo, '__iter__') and hasattr(foo, 'next')



class Deliver:
    """This guy gets responses and writes them out to the wire.
    """

    def __init__(self, make_request, responder, out):
        """Takes a function, a responder, and an output buffer.

        We take a make_request function instead of an actual Request object
        so that we can use raise Response(400) errors in the Request
        constructor.

        """
        self.make_request = make_request
        self.responder = responder
        self.out = out


    def __call__(self, *args, **kwargs):
        """All arguments are passed through to make_request.
        """
        try:
            self.request = self.make_request(*args, **kwargs)
            self.respond(self.request)
        except Response, response:
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()


    def respond(self, request):
        """Execute one transaction.

        The call to responder.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        responder.respond is expected to raise a Response or other exception.

        """

        # Get out of the way.
        # ===================

        if not httpy.mode.IS_DEBUG:
            self.responder.respond(request)
        else:
            try:
                self.responder.respond(request)
            except Response:
                raise # move along
            except:
                logger.debug(traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        raise Response(500, "%s.respond did not " % str(self.responder) +
                            "raise anything.")


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        logger.debug("Attempting to send a response.")
        logger.debug("Response lineage as follows:" +
                          "\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in StatusCodes:
            raise StandardError("Bad response code: %r" % response.code)
        elif (response.code == 537) and httpy.mode.IS_DEPLOYMENT:
            raise StandardError("Won't serve 537 in deployment mode.")
        reason_phrase, reason_message = StatusCodes.get(response.code)
        status_line = ' '.join(( str(httpy.HTTP_VERSION_STRING)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.out.write(status_line + '\r\n')


        # Generate the body.
        # ==================
        # We do this here so we can calculate the content-length.

        if (not response.body) and (response.code not in (200, 537)):
            response.body = reason_message
        if response.code == 537:
            if not isinstance(response.body, basestring):
                response.body = pprint.pformat(response.body)


        # Output the headers.
        # ===================
        # Make sure we have a Content-Type, Content-Length and Server.

        lowered = [f.lower() for f in response.headers]
        if 'content-type' not in lowered:
            if str(response.code).startswith('2'):
                # This is per the spec.
                response.headers['Content-Type'] = 'application/octet-stream'
            else:
                # But error messages default to text/plain.
                response.headers['Content-Type'] = 'text/plain'
        if 'content-length' not in lowered:
            if isinstance(response.body, Path):
                response.body = open(response.body).read()
            elif isiter(response.body):
                response.body = ''.join(list(response.body))
            response.headers['Content-Length'] = len(response.body)
        if 'server' not in lowered:
            response.headers['Server'] = httpy.RESPONSE_HEADER

        for header in response.headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write('\r\n')
        self.out.flush()


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        want_body = (   (response.code != 304)
                    and (hasattr(self, 'request'))
                    and (self.request.method != 'HEAD')
                       )

        if want_body:
            if isinstance(response.body, Path):
                # Path is a subclass of basestring, so test this first!
                if SENDFILE:
                    logger.info('sending %s with sendfile(2)' % response.body)


                    # Send the file.
                    # ==============
                    # I have observed that sendfile only transmits 32768 bytes
                    # at a time. Therefore, we need to loop.

                    content_length = None
                    for header in response.headers:
                        if header.lower() == 'content-length':
                            content_length = response.headers[header]
                    if content_length is None:
                        raise StandardError( "Bad content length: "
                                             "'%s'" % content_length
                                            )

                    sent = 0

                    fp = open(response.body, 'rb')
                    in_fd = fp.fileno()
                    out_fd = self.out.fileno()

                    while sent < content_length:
                        self.out.flush()
                        [f, n] = sendfile.sendfile( out_fd
                                                  , in_fd
                                                  , sent
                                                  , 0
                                                   )
                        sent += n

                    self.out.flush()
                    fp.close()

                else:
                    self.out.write(response.body.file.read())
            elif isinstance(response.body, basestring):
                self.out.write(response.body)
            elif isiter(response.body):
                for n in response.body:
                    self.out.write(n)
            else:
                raise StandardError( "Bad response body type: " +
                                     "'%s'" % type(response.body)
                                    )

        line = ''
        if hasattr(self, 'request'):
            line = self.request.raw_line
        args = (line, response.code, reason_phrase)
        logger.debug("Responded to %s with %d %s" % args)
        self.out.flush()


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        logger.critical("Traceback follows.\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( httpy.HTTP_VERSION_STRING
                                       , 500
                                       , "Internal Server Error"
                                        )

        if httpy.mode.IS_DEPLOYMENT:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback.format_exc()

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in sorted(headers.items()):
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)
        self.out.flush()



"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
