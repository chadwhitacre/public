"""Centralize the logic for writing responses out to the wire.
"""
import logging
import pdb
import pprint
import traceback
from email.Utils import formatdate

import httpy
from httpy.request import Request
from httpy.response import Response, StatusCodes
from httpy.utils import isiter, Path


logger = logging.getLogger('httpy.couplers.utils')


try:
    # http://tautology.org/software/python-modules/sendfile
    # Note that sendfile.so is GPL! We need to package up a version of
    # httpy without this dependency.
    import sendfile
    SENDFILE = True
except ImportError:
    SENDFILE = False


class make_deliver:
    """This is a factory class for 'deliver' callables.

    The deliver callable gets responses and writes them out to the wire.

    """

    def __init__(self, make_request, responder, out):
        """Takes a function, a responder, and an output buffer.

        We take a make_request function instead of an actual Request object
        so that we can use raise Response(400) errors in the Request
        constructor.

        """
        self.make_request = make_request
        self.responder = responder
        self.out = out


    def __call__(self, *args, **kwargs):
        """All arguments are passed through to make_request.
        """
        try:
            self.request = self.make_request(*args, **kwargs)
            self.respond(self.request)
        except Response, response:
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()


    def respond(self, request):
        """Execute one transaction.

        The call to responder.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        responder.respond is expected to raise a Response or other exception.

        """

        if not httpy.mode.IS_DEBUG:
            self.responder.respond(request)
        else:
            try:
                self.responder.respond(request)
            except Response:
                raise # move along
            except:
                logger.debug(traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        raise Response(500, "%s.respond did not " % str(self.responder) +
                            "raise anything.")


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        logger.debug("Attempting to send a response.")
        logger.debug("Response lineage as follows:" +
                          "\n%s" % traceback.format_exc())


        # Generate the body and output the Status-Line.
        # =============================================

        reason_phrase = '<no phrase>'
        if response.code in StatusCodes:
            reason_phrase, reason_message = StatusCodes.get(response.code)
            if (not response.body) and (response.code != 200):
                response.body = reason_message
        status_line = ' '.join(( str(httpy.HTTP_VERSION_STRING)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.out.write(status_line + '\r\n')



        # Output the headers.
        # ===================
        # Make sure we have Content-Type, Content-Length, Date, and Server.

        lowered = [f.lower() for f in response.headers]
        if 'content-type' not in lowered:
            if 200 <= response.code <= 299:
                # Content-Type defaults to text/html for successful requests
                response.headers['Content-Type'] = 'text/html'
            else:
                # ... and to text/plain for errors.
                response.headers['Content-Type'] = 'text/plain'
        if 'content-length' not in lowered:
            if isinstance(response.body, Path):
                response.body = open(response.body).read()
            elif isiter(response.body):
                response.body = ''.join(list(response.body))
            response.headers['Content-Length'] = len(response.body)
        if 'date' not in lowered:
            response.headers['Date'] = formatdate(usegmt=True)
        if 'server' not in lowered:
            response.headers['Server'] = httpy.RESPONSE_HEADER

        for header in response.headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write('\r\n')
        if hasattr(self.out, 'flush'):
            self.out.flush()


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        want_body = (   (response.code != 304)
                    and (hasattr(self, 'request'))
                    and (self.request.method != 'HEAD')
                       )

        if want_body:
            if isinstance(response.body, Path):
                # Path is a subclass of basestring, so test this first!
                if SENDFILE:
                    logger.info('sending %s with sendfile(2)' % response.body)


                    # Send the file.
                    # ==============
                    # I have observed that sendfile only transmits 32768 bytes
                    # at a time. Therefore, we need to loop.

                    content_length = None
                    for header in response.headers:
                        if header.lower() == 'content-length':
                            content_length = response.headers[header]
                    if content_length is None:
                        raise StandardError( "Bad content length: "
                                             "'%s'" % content_length
                                            )

                    sent = 0

                    fp = open(response.body, 'rb')
                    in_fd = fp.fileno()
                    out_fd = self.out.fileno()

                    while sent < content_length:
                        if hasattr(self.out, 'flush'):
                            self.out.flush()
                        [f, n] = sendfile.sendfile( out_fd
                                                  , in_fd
                                                  , sent
                                                  , 0
                                                   )
                        sent += n

                    if hasattr(self.out, 'flush'):
                        self.out.flush()
                    fp.close()

                else:
                    self.out.write(response.body.file.read())
            elif isinstance(response.body, basestring):
                self.out.write(response.body)
            elif isiter(response.body):
                for n in response.body:
                    self.out.write(n)
            else:
                raise StandardError( "Bad response body type: " +
                                     "'%s'" % type(response.body)
                                    )

        line = ''
        if hasattr(self, 'request'):
            line = self.request.raw_line
        args = (line, response.code, reason_phrase)
        logger.debug("Responded to %s with %d %s" % args)
        if hasattr(self.out, 'flush'):
            self.out.flush()


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        logger.critical("Traceback follows.\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( httpy.HTTP_VERSION_STRING
                                       , 500
                                       , "Internal Server Error"
                                        )

        if httpy.mode.IS_DEPLOYMENT or httpy.mode.IS_STAGING:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback.format_exc()

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in sorted(headers.items()):
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)
        if hasattr(self.out, 'flush'):
            self.out.flush()



"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
