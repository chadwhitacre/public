import logging
import os
import pdb
import pprint
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.server.interfaces import ITask

import httpy
from httpy.request import Request
from httpy.response import Response, StatusCodes
from httpy.utils import uri_to_fs


logger = logging.getLogger('httpy.task')


class Task:
    """Represents the task of serving a single HTTP Request.

    The httpy._zope.server machinery instantiates this once for each HTTP
    request, and calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        """Takes an IServerChannel (httpy._zope) and an IRequest (httpy).
        """

        try:
            self.channel    = channel
            self.server     = self.channel.server
            self.responder  = self.channel.server.responder
            self.request    = Request(request)

            if 0: # turned off cause it eats CPU even when not printed
                request_lines = request.raw.splitlines()
                raw_request = os.linesep.join(request_lines)
                logger.debug(raw_request)

        except:
            self.fail()


    # ITask contracts
    # ===============
    # service, cancel, defer

    def service(self):

        try:
            self.respond(self.request)
        except Response, response:
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        self.channel.close_when_done()


    def defer(self):
        pass


    # Process
    # =======

    def respond(self, request):
        """Execute one transaction.

        The call to responder.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        responder.respond is expected to raise a Response or other exception.

        """

        # Get out of the way.
        # ===================

        if not httpy.mode.IS_DEBUG:
            self.responder.respond(request)
        else:
            try:
                self.responder.respond(request)
            except ResponseFlag:
                raise # move along
            except:
                logger.debug(traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        raise Response(500, "%s.respond did not " % str(self.responder) +
                            "raise anything.")


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        logger.debug("Attempting to send a response.")
        logger.debug("Response lineage as follows:" +
                          "\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in StatusCodes:
            raise StandardError("Bad response code: %r" % response.code)
        elif (response.code == 537) and httpy.mode.IS_DEPLOYMENT:
            raise StandardError("Won't serve 537 in deployment mode.")
        reason_phrase, reason_message = StatusCodes.get(response.code)
        status_line = ' '.join(( str(self.server.http_version_string)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.channel.write(status_line + '\r\n')


        # Generate the body.
        # ==================
        # We do this here so we can calculate the content-length.

        if (not response.body) and (response.code not in (200, 537)):
            response.body = reason_message
        if response.code == 537:
            if not isinstance(response.body, basestring):
                response.body = pprint.pformat(response.body)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.iteritems():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[header] = v

        if 'content-length' not in headers: # always true
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if str(response.code).startswith('2'):
                # Setting this header for successful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
            else:
                # But error messages default to text/plain.
                headers['content-type'] = 'text/plain'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.channel.write("%s: %s\r\n" % header)

        self.channel.write('\r\n')


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if (response.code != 304) and (self.request.method != 'HEAD'):
            self.channel.write(response.body)

        args = (self.request.raw_line, response.code, reason_phrase)
        logger.debug("Responded to %s with %d %s" % args)


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        logger.critical("Traceback follows.\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if httpy.mode.IS_DEPLOYMENT:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback.format_exc()

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'


        # Send the response.
        # ==================

        self.channel.write(status_line)
        for header in sorted(headers.items()):
            self.channel.write('%s: %s\r\n' % header)
        self.channel.write('\r\n')
        self.channel.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
