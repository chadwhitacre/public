import inspect
import logging
import os
import pdb
import pprint
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.server.interfaces import ITask

import httpy
from httpy.request import Request
from httpy.response import Response, StatusCodes
from httpy.utils import uri_to_fs, Path

try:
    # http://tautology.org/software/python-modules/sendfile
    # Note that sendfile.so is GPL! So be careful.
    import sendfile
    SENDFILE = True
except ImportError:
    SENDFILE = False


logger = logging.getLogger('httpy.task')

def isiter(foo):
    return hasattr(foo, '__iter__') and hasattr(foo, 'next')


class Task:
    """Represents the task of serving a single HTTP Request.

    The httpy._zope.server machinery instantiates this once for each HTTP
    request, and calls service in its own thread.

    """

    implements(ITask)


    def __init__(self, channel, request):
        """Takes an IServerChannel (httpy._zope) and an IRequest (httpy).
        """

        try:
            self.channel    = channel
            self.server     = self.channel.server
            self.responder  = self.channel.server.responder
            self.request    = Request(request)

            if 0: # turned off cause it eats CPU even when not printed
                request_lines = request.raw.splitlines()
                raw_request = os.linesep.join(request_lines)
                logger.debug(raw_request)

        except:
            self.fail()


    # ITask contracts
    # ===============
    # service, cancel, defer

    def service(self):

        try:
            self.respond(self.request)
        except Response, response:
            try:
                self.deliver(response)
            except:
                self.fail()
        except:
            self.fail()

        self.channel.close_when_done()


    def cancel(self):
        self.channel.close_when_done()


    def defer(self):
        pass


    # Process
    # =======

    def respond(self, request):
        """Execute one transaction.

        The call to responder.respond is complicated by the fact that in
        debugging mode we want to drop into the post-mortem debugger when there
        is an exception (other than Response, of course).

        responder.respond is expected to raise a Response or other exception.

        """

        # Get out of the way.
        # ===================

        if not httpy.mode.IS_DEBUG:
            self.responder.respond(request)
        else:
            try:
                self.responder.respond(request)
            except Response:
                raise # move along
            except:
                logger.debug(traceback.format_exc())
                pdb.post_mortem(sys.exc_info()[2])
                raise


        # You know something? No soup for you!
        # ====================================

        raise Response(500, "%s.respond did not " % str(self.responder) +
                            "raise anything.")


    # Write-side methods
    # ==================
    # deliver, fail

    def deliver(self, response):
        """Given an httpy.Response, write it out to the wire.
        """

        logger.debug("Attempting to send a response.")
        logger.debug("Response lineage as follows:" +
                          "\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in StatusCodes:
            raise StandardError("Bad response code: %r" % response.code)
        elif (response.code == 537) and httpy.mode.IS_DEPLOYMENT:
            raise StandardError("Won't serve 537 in deployment mode.")
        reason_phrase, reason_message = StatusCodes.get(response.code)
        status_line = ' '.join(( str(self.server.http_version_string)
                               , str(response.code)
                               , reason_phrase
                                ))
        self.channel.write(status_line + '\r\n')


        # Generate the body.
        # ==================
        # We do this here so we can calculate the content-length.

        if (not response.body) and (response.code not in (200, 537)):
            response.body = reason_message
        if response.code == 537:
            if not isinstance(response.body, basestring):
                response.body = pprint.pformat(response.body)


        # Output the headers.
        # ===================
        # Make sure we have a Content-Type, Content-Length and Server.

        lowered = [f.lower() for f in response.headers]
        if 'content-type' not in lowered:
            if str(response.code).startswith('2'):
                # This is per the spec.
                response.headers['Content-Type'] = 'application/octet-stream'
            else:
                # But error messages default to text/plain.
                response.headers['Content-Type'] = 'text/plain'
        if 'content-length' not in lowered:
            if isinstance(response.body, Path):
                response.body = open(response.body).read()
            elif isiter(response.body):
                response.body = ''.join(list(response.body))
            response.headers['Content-Length'] = len(response.body)
        if 'server' not in lowered:
            response.headers['Server'] = self.server.response_header

        for header in response.headers.iteritems():
            self.channel.write("%s: %s\r\n" % header)

        self.channel.write('\r\n')


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if (response.code != 304) and (self.request.method != 'HEAD'):
            if isinstance(response.body, Path):
                # Path is a subclass of basestring, so test this first!
                if SENDFILE:
                    logger.info('sending %s with sendfile(2)' % response.body)


                    # Send the file.
                    # ==============
                    # I have observed that sendfile only transmits 32768 bytes
                    # at a time. Therefore, we need to loop.

                    content_length = None
                    for header in response.headers:
                        if header.lower() == 'content-length':
                            content_length = response.headers[header]
                    if content_length is None:
                        raise 'heck'

                    sent = 0

                    fp = open(response.body, 'rb')
                    in_fd = fp.fileno()
                    out_fd = self.channel.fileno()

                    while sent < content_length:
                        self.channel.flush()
                        [f, n] = sendfile.sendfile( out_fd
                                                  , in_fd
                                                  , sent
                                                  , 0
                                                   )
                        sent += n

                    fp.close()

                else:
                    self.channel.write(response.body.file.read())
            elif isinstance(response.body, basestring):
                self.channel.write(response.body)
            elif isiter(response.body):
                for n in response.body:
                    self.channel.write(n)
            else:
                raise StandardError( "Bad response body type: " +
                                     "'%s'" % type(response.body)
                                    )

        args = (self.request.raw_line, response.code, reason_phrase)
        logger.debug("Responded to %s with %d %s" % args)


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        logger.critical("Traceback follows.\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if httpy.mode.IS_DEPLOYMENT:
            body = "Internal Server Error"
        else:
            body = "Internal Server Error\r\n\r\n%s" % traceback.format_exc()

        headers = {}
        headers['Content-Length'] = len(body)
        headers['Content-Type'] = 'text/plain'


        # Send the response.
        # ==================

        self.channel.write(status_line)
        for header in sorted(headers.items()):
            self.channel.write('%s: %s\r\n' % header)
        self.channel.write('\r\n')
        self.channel.write(body)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
