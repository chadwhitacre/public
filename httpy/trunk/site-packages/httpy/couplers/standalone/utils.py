import os
import socket
import sys
from optparse import OptionParser

try:
    import pwd
    WINDOWS = False
except:
    WINDOWS = True

import httpy
from httpy._zope.interface import implements


class ConfigError(StandardError):
    """This is an error in any part of our configuration.
    """

    def __init__(self, msg):
        StandardError.__init__(self)
        self.msg = msg

    def __str__(self):
        return self.msg


class Configure:
    """Configure a standalone httpy server from three sources:

        - defaults  hard-wired defaults
        - env       environment variables
        - opts      command line options

    All options may be specified on the command line. Additionally, mode and
    threads may be set in the environment. Environment variables override
    defaults, and command line options override both. Here's what the options
    mean:

        address     A socket address, the format of which depends on the socket
                    type: if the address begins with a forward-slash (/) or dot
                    (.), it is interpreted as an AF_UNIX address (i.e., a path),
                    otherwise it is interpreted as an AF_INET address; AF_INET6
                    is not supported.

        mode        See httpy.utils.mode.

        threads     The number of worker threads to maintain.

        user        The user account to switch to after binding to the socket;
                    this option is necessary in order to bind to TCP port 80
                    without continuing as root.

    """

    options = ( 'address'
              , 'mode'
              , 'threads'
              , 'user'
               )


    # Defaults
    # ========

    address     = ('', 8080)
    mode        = httpy.mode.default
    threads     = 10
    uid         = ''


    def __call__(self, argv=None):
        """Given an argv list, return a 3-tuple: (address, threads, uid)

        This method also sets the HTTPY_MODE environment variable.

        """

        if argv is None:
            argv = sys.argv[1:]


        # Environment
        # ===========

        for key in ('mode', 'threads'):
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                value = os.environ.get(envvar)
                validate = getattr(self, '_validate_%s' % key)
                setattr(self, key, validate('environment', value))


        # Command-line
        # ============

        usage = "for details: man 1 httpy or http://www.zetadev.com/"
        parser_ = OptionParser(usage=usage)
        parser_.add_option("-a", "--address", dest="address",
                           help="the address to listen on [<INADDR_ANY>:8080]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="one of: deployment, staging, development, " +
                                "debugging [deployment]")
        parser_.add_option("-t", "--threads", dest="threads",
                           help="the number of worker threads to use [10]")
        parser_.add_option("-u", "--user", dest="user",
                           help="the user account to run as []")
        opts, args = parser_.parse_args(args=argv)

        if opts:
            for key in self.options:
                if hasattr(opts, key):
                    value = getattr(opts, key)
                    if value is not None:
                        validate = getattr(self, '_validate_%s' % key)
                        setattr(self, key, validate('command line', value))


        # Set HTTPY_MODE and return.
        # ==========================

        os.environ['HTTPY_MODE'] = self.mode
        return (self.address, self.threads, self.uid)


    # Validators
    # ==========

    def _validate_address(self, context, candidate):
        """Must be a valid address for the given socket family.
        """

        def const2name(n):
            if n==1: return 'AF_UNIX'
            if n==2: return 'AF_INET'
            if n==28: return 'AF_INET6'

        msg = "Found bad address `%s'."
        msg = msg % candidate
        err = ConfigError(msg)


        if not isinstance(candidate, basestring):
            raise err

        if candidate[0] in ('/','.'):
            if WINDOWS:
                raise ConfigError("Can't use an AF_UNIX socket on Windows.")
            # We could test to see if the path exists or is creatable, etc.
            candidate = os.path.realpath(candidate)

        else:
            # Here we need a tuple: (str, int). The string must be a valid
            # IPv4 address or the empty string, and the int -- the port --
            # must be between 0 and 65535, inclusive.


            # Break out IP and port.
            # ======================

            if isinstance(candidate, (tuple, list)):
                if len(candidate) != 2:
                    raise err
                ip, port = candidate
            elif isinstance(candidate, basestring):
                if candidate.count(':') != 1:
                    raise err
                ip_port = candidate.split(':')
                ip, port = [i.strip() for i in ip_port]
            else:
                raise err


            # IP
            # ==

            if not isinstance(ip, basestring):
                raise err
            elif ip != '': # Blank ip is ok, just don't try to validate it.
                try:
                    socket.inet_aton(ip)
                except socket.error:
                    raise err


            # port
            # ====
            # Coerce to int. Must be between 0 and 65535, inclusive.

            if isinstance(port, basestring):
                if not port.isdigit():
                    raise err
                else:
                    port = int(port)
            elif isinstance(port, int) and not (port is False):
                # already an int for some reason (called interactively?)
                pass
            else:
                raise err

            if not(0 <= port <= 65535):
                raise err


            # Success!
            # ========

            candidate = (ip, port)


        return candidate


    def _validate_mode(self, context, candidate):
        """We expand abbreviations to the full term.
        """

        msg = ("Found bad mode `%s' in context `%s'. Mode must be " +
               "either `deployment,' `staging,' `development' or " +
               "`debugging.' Abbreviations are fine.")
        msg = msg % (str(candidate), context)

        if not isinstance(candidate, basestring):
            raise ConfigError(msg)

        mode = httpy.mode._interpret(candidate)
        if not mode:
            raise ConfigError(msg)
        return mode


    def _validate_root(self, context, candidate):
        """Must be a valid directory (also check perms?)
        """

        msg = "Found bad root `%s' in context `%s'. " +\
              "Root must point to a directory."
        msg = msg % (str(candidate), context)

        if isinstance(candidate, basestring):
            candidate = os.path.realpath(candidate)
        else:
            raise ConfigError(msg)

        if not os.path.isdir(candidate):
            raise ConfigError(msg)

        return candidate


    def _validate_threads(self, context, candidate):
        """Must be an integer greater than or equal to 1.
        """

        msg = ("Found bad thread count `%s' in context `%s'. " +
               "Threads must be an integer greater than or equal to one.")
        msg = msg % (str(candidate), context)

        if not isinstance(candidate, (int, long)):
            isstring = isinstance(candidate, basestring)
            if not isstring or not candidate.isdigit():
                raise ConfigError(msg)
        candidate = int(candidate)
        if not candidate >= 1:
            raise ConfigError(msg)

        return candidate


    def _validate_user(self, context, candidate):
        """Must be a valid user account on this system.
        """

        if WINDOWS:
            raise ConfigError("This option is not available on Windows.")

        msg = ("Found bad user `%s' in context `%s'. " +
               "User must be a valid user account on this system.")
        msg = msg % (str(candidate), context)

        try:
            candidate = pwd.getpwnam(candidate)[2]
        except KeyError:
            raise ConfigError(msg)

        return candidate


configure = Configure()