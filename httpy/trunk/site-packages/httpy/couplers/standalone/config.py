import os
import pwd
import socket
import sys
from optparse import OptionParser

import httpy
from httpy._zope.interface import implements


__docformat__ = 'rest'


class ConfigError(StandardError):
    """This is an error in any part of our configuration.
    """

    def __init__(self, msg):
        StandardError.__init__(self)
        self.msg = msg

    def __str__(self):
        return self.msg


class Config:
    """Determine the config for an httpy server from three sources:

        - defaults  hard-wired defaults
        - env       environment variables
        - opts      command line options

    All options may be specified on the command line. Additionally, mode and
    threads may be set in the environment. Environment variables override
    defaults, and command line options override both. See
    httpy.interfaces.IConfig for attribute documentation.

    """

    options = ( 'address'
              , 'mode'
              , 'threads'
              , 'user'
               )


    # Defaults
    # ========
    # We put these out here to make overriding easier for library users.

    address     = ('', 8080)
    mode        = httpy.mode.default
    threads     = 10
    user        = ''


    def __init__(self, argv=None):

        # Environment
        # ===========

        for key in ('mode', 'threads'):
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                value = os.environ.get(envvar)
                validate = getattr(self, '_validate_%s' % key)
                setattr(self, key, validate('environment', value))


        # Command-line
        # ============

        usage = "for details: man 1 httpy or http://www.zetadev.com/"
        parser_ = OptionParser(usage=usage)
        parser_.add_option("-a", "--address", dest="address",
                           help="the address to listen on [<INADDR_ANY>:8080]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="one of: deployment, staging, development, " +
                                "debugging [deployment]")
        parser_.add_option("-t", "--threads", dest="threads",
                           help="the number of worker threads to use [10]")
        parser_.add_option("-u", "--user", dest="user",
                           help="the user account to run as []")
        opts, args = parser_.parse_args(args=argv)

        if opts:
            for key in self.options:
                if hasattr(opts, key):
                    value = getattr(opts, key)
                    if value is not None:
                        validate = getattr(self, '_validate_%s' % key)
                        setattr(self, key, validate('command line', value))


        # Final API cleanup.
        # ==================
        # Move the mode from self to os.environ, and add sockfam to self.

        os.environ['HTTPY_MODE'] = self.mode
        del self.mode
        if self.address[0] in ('/', '.'):
            self.sockfam = socket.AF_UNIX
        else:
            self.sockfam = socket.AF_INET


    # Validators
    # ==========

    def _validate_address(self, context, candidate):
        """Must be a valid address for the given socket family.
        """

        def const2name(n):
            if n==1: return 'AF_UNIX'
            if n==2: return 'AF_INET'
            if n==28: return 'AF_INET6'

        msg = "Found bad address `%s' for address family `%s'."
        msg = msg % (candidate, const2name(self.sockfam))
        err = ConfigError(msg)


        if not isinstance(candidate, basestring):
            raise err

        if candidate[0] in ('/','.'):
            self.sockfam = socket.AF_UNIX
            # We could test to see if the path exists or is creatable, etc.
            candidate = os.path.realpath(candidate)

        else:
            self.sockfam = socket.AF_INET
            # Here we need a tuple: (str, int). The string must be a valid
            # IPv4 address or the empty string, and the int -- the port --
            # must be between 0 and 65535, inclusive.


            # Break out IP and port.
            # ======================

            if isinstance(candidate, (tuple, list)):
                if len(candidate) != 2:
                    raise err
                ip, port = candidate
            elif isinstance(candidate, basestring):
                if candidate.count(':') != 1:
                    raise err
                ip_port = candidate.split(':')
                ip, port = [i.strip() for i in ip_port]
            else:
                raise err


            # IP
            # ==

            if not isinstance(ip, basestring):
                raise err
            elif ip != '': # Blank ip is ok, just don't try to validate it.
                try:
                    socket.inet_aton(ip)
                except socket.error:
                    raise err


            # port
            # ====
            # Coerce to int. Must be between 0 and 65535, inclusive.

            if isinstance(port, basestring):
                if not port.isdigit():
                    raise err
                else:
                    port = int(port)
            elif isinstance(port, int) and not (port is False):
                # already an int for some reason (called interactively?)
                pass
            else:
                raise err

            if not(0 <= port <= 65535):
                raise err


            # Success!
            # ========

            candidate = (ip, port)


        return candidate


    def _validate_mode(self, context, candidate):
        """We expand abbreviations to the full term.
        """

        msg = ("Found bad mode `%s' in context `%s'. Mode must be " +
               "either `deployment,' `staging,' `development' or " +
               "`debugging.' Abbreviations are fine.")
        msg = msg % (str(candidate), context)

        if not isinstance(candidate, basestring):
            raise ConfigError(msg)

        mode = httpy.mode._interpret(candidate)
        if not mode:
            raise ConfigError(msg)
        return mode


    def _validate_root(self, context, candidate):
        """Must be a valid directory (also check perms?)
        """

        msg = "Found bad root `%s' in context `%s'. " +\
              "Root must point to a directory."
        msg = msg % (str(candidate), context)

        if isinstance(candidate, basestring):
            candidate = os.path.realpath(candidate)
        else:
            raise ConfigError(msg)

        if not os.path.isdir(candidate):
            raise ConfigError(msg)

        return candidate


    def _validate_threads(self, context, candidate):
        """Must be an integer greater than or equal to 1.
        """

        msg = ("Found bad thread count `%s' in context `%s'. " +
               "Threads must be an integer greater than or equal to one.")
        msg = msg % (str(candidate), context)

        if not isinstance(candidate, (int, long)):
            isstring = isinstance(candidate, basestring)
            if not isstring or not candidate.isdigit():
                raise ConfigError(msg)
        candidate = int(candidate)
        if not candidate >= 1:
            raise ConfigError(msg)

        return candidate


    def _validate_user(self, context, candidate):
        """Must be a valid user account on this system.
        """

        msg = ("Found bad user `%s' in context `%s'. " +
               "User must be a valid user account on this system.")
        msg = msg % (str(candidate), context)

        try:
            pwd.getpwnam(candidate)
        except KeyError:
            raise ConfigError(msg)

        return candidate
