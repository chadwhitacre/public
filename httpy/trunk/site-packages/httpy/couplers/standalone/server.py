"""This module provides the classes that define our server.

There are two classes here:

    Server -- the main server class

    RestartingServer -- used for development; restarts a child server whenever
                        changes are made to your framework or applications

"""

import asyncore
import imp
import inspect
import logging
import os
import pdb
import popen2
import signal
import socket
import subprocess
import sys
import time
import traceback

from httpy._zope.interface.verify import verifyClass, verifyObject
from httpy._zope.server.adjustments import default_adj
from httpy._zope.server.serverbase import ServerBase
from httpy._zope.server.taskthreads import ThreadedTaskDispatcher

from httpy import responders
from httpy.interfaces import IResponder
from httpy.couplers.standalone.channel import Channel


__all__ = ('Loader', 'Server', 'RestartingServer')
__docformat__ = 'reStructuredText'

logger = logging.getLogger('httpy.server')

STOP_SIGNALS = {
    signal.SIGINT  : 'SIGINT'
  , signal.SIGTERM : 'SIGTERM'
                }


class Server(ServerBase):
    """An httpy server.

    Instantiate with an IConfig and an optional IFramework, and start it with
    start().

    """

    # ServerBase boilerplate
    channel_class = Channel
    SERVER_IDENT = 'httpy'


    def __init__(self, config, responder=None):

        self.config = config
        self.responder = responder or responders.Default
        try:
            verifyObject(IResponder, self.responder, tentative=True)
        except:
            logger.debug("%s is not valid." % self.responder)
            raise


        # Set up signal handling so we can shut down cleanly.
        # ===================================================

        for sig in STOP_SIGNALS:
            signal.signal(sig, self.stop)


        # Satisfy ServerBase requirements.
        # ================================

        asyncore.dispatcher.__init__(self)
        self.adj = default_adj
        if self.config.sockfam == socket.AF_UNIX:
            # The default adjustment doesn't apply here, and triggers an error.
            self.adj.socket_options = []
        self.verbose = False
        task_dispatcher = ThreadedTaskDispatcher()
        task_dispatcher.setThreadCount(self.config.threads)
        self.task_dispatcher = task_dispatcher
        self.logger = logger


        # Bind to an address.
        # ===================

        self.create_socket(config.sockfam, socket.SOCK_STREAM)
        self.set_reuse_addr()
        if config.sockfam == socket.AF_UNIX:
            if os.path.exists(config.address):
                os.unlink(config.address)
                logger.debug("unlinking stale socket")

        timeout = time.time() + 10
        while 1:
            if time.time() < timeout:
                try:
                    self.bind(config.address)
                    break
                except socket.error, err:
                    time.sleep(0.5)
            else:
                raise err


    def start(self):
        """Start the server.
        """
        self.accept_connections()
        if self.config.sockfam == socket.AF_INET:
            addr, port = self.socket.getsockname()
            logger.info("httpy started on port %s" % port)
        elif self.config.sockfam == socket.AF_UNIX:
            logger.info("httpy started on %s" % self.config.address)
        asyncore.loop(timeout=5)


    def stop(self, signum=None, frame=None):
        """Stop the server.
        """
        if signum is not None:
            logger.debug("caught %s" % STOP_SIGNALS[signum])
        logger.info("shutting down...")

        if hasattr(self.responder, 'stop'):
            if inspect.ismethod(self.responder.stop):
                self.responder.stop()

        self.task_dispatcher.shutdown()
        asyncore.close_all()

        if self.config.sockfam == socket.AF_UNIX:
            if not os.path.exists(self.config.address):
                logger.debug("what happened to our socket?")
            os.unlink(self.config.address)

        logger.info("httpy stopped")



class Restart(StandardError):
    """Triggers a restart of the child server process.
    """


class RestartingServer:
    """Instantiate with a Config object, and start it with start().

    This server runs the *real* server in a separate process, restarting it
    whenever modules change on the filesystem. There are actually a number of
    ways to skin this deceptively simple cat. Here's what I've tried:

        Refresh modules directly from within the python process.
        --------------------------------------------------------

        The basic trick is to delete items from sys.modules, forcing a refresh
        the next time they are loaded. However, because modules import from one
        another, you need to make sure you reload enough of them to make it
        worth it. I got pretty far down this road (the place to start is to
        google for RollbackImporter), but at a couple points I started seeing
        very elusive segfaults. My best guess is that I was hitting a bug in
        Python, but I never narrowed it down enough to file it. :-(


        Run the python process within a wrapper that knows how to restart it.
        ---------------------------------------------------------------------

        Since you need to refresh almost all of your modules anyway, it makes a
        lot of sense to deal with the problem at the macro level. I got this
        idea from Ian Bicking via CherryPy. Thanks, guys. :-) Their version of
        this solution is to spawn a process and block for it, and then monitor
        the state of the modules on the filesystem in a separate thread. They
        use the blocked process's exit code to trigger reloading.


        Run within a wrapper but monitor within the process.
        ----------------------------------------------------

        I think it should also work to push the monitoring functionality down
        into the application, but I wasn't able to successfully exit zope.server
        from inside it, because I don't understand threading well enough.


        Run in a non-blocking process, monitor within the main process.
        ---------------------------------------------------------------

        The solution I've settled on here is to start the main server in a
        separate process, but not to block for it. I then monitor the filesystem
        in the main process/thread, and manipulate the worker process via its
        process ID. This solution, therefore, is not Windows-compatible. But,
        boy, is it simpler. :-)  See also: my above comment on me vs. threading.


    """

    def __init__(self, config, responder=None):
        self.config = config
        self.mtimes = {}
        self.pid = -1
        for sig in STOP_SIGNALS:
           signal.signal(sig, self.stop)


        # Load framework and apps so that we can monitor them for changes.
        # ================================================================

        self.responder = responder or responders.Default


    def start(self, args=None):
        logger.info("starting child server ...")
        if args is None:
            args = [sys.executable] + sys.argv
        new_env = os.environ.copy()
        new_env['HTTPY_PLAIN_JANE'] = 'So plain.'
        while 1:
            try:
                try:
                    self.pid = subprocess.Popen(args, env=new_env).pid
                    while 1:
                        self.look_for_changes()
                        time.sleep(1)
                finally:
                    self.stop_child()
            except SystemExit:
                time.sleep(0.5) # Give stdout a chance to flush.
                raise
            except Restart:
                logger.info("restarting child server ...")
            except:
                logger.error("exception while spawning child ...\n" +
                             traceback.format_exc())


    def stop_child(self):
        """Stop the child server process.
        """
        if self.pid > 0:
            try:
                os.kill(self.pid, signal.SIGTERM)
            except OSError:
                logger.warning("OSError killing pid %d" % self.pid)
                logger.warning(traceback.format_exc())
        else:
            logger.error("self.pid is %s; won't kill" % str(self.pid))

        if 0: # this is for debugging the restart-while-debugging bug

            pdb.Pdb().reset()

            print "isatty: %s %s %s" % tuple([x.isatty() for x in ( sys.stdin
                                                                  , sys.stdout
                                                                  , sys.stderr
                                                                  )])

            while 0:
                msg = os.read(0, 8192)
                if msg == 'quit\n':
                    break
                os.write(1, msg)

            #stdin = os.open('/dev/stdin', os.O_WRONLY)
            #os.dup2(stdin, 0)
            #stdout = os.open('/dev/stdout', os.O_WRONLY)
            #os.dup2(stdout, 1)
            #stderr = os.open('/dev/stderr', os.O_WRONLY)
            #os.dup2(stderr, 2)


    def stop(self, signum=-1, frame=None):
        """Stop the child process, then exit ourselves.
        """
        self.stop_child()
        if signum is not None:
            logger.debug("parent caught %s" % STOP_SIGNALS[signum])
        logger.debug("parent shutting down...")
        raise SystemExit


    def look_for_changes(self):
        """See if any of our available modules have changed on the filesystem.
        """

        for module in sys.modules.values():

            # Get out early if we can.
            # ========================

            filename = getattr(module, '__file__', None)
            if filename is None:
                continue
            if filename.endswith(".pyc"):
                filename = filename[:-1]


            # The file may have been removed from the filesystem.
            # ===================================================

            if not os.path.isfile(filename):
                logger.debug("missing: %s" % filename)
                if filename in self.mtimes:
                    del self.mtimes[filename]
                raise Restart


            # Or not.
            # =======

            mtime = os.stat(filename).st_mtime
            if filename not in self.mtimes:
                self.mtimes[filename] = mtime
                continue
            if mtime > self.mtimes[filename]:
                logger.debug("outdated: %s" % filename)
                self.mtimes[filename] = mtime
                raise Restart
