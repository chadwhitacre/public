"""This module provides the classes that define our server.

There are two classes here:

    Server -- the main server class

    RestartingServer -- used for development; restarts a child server whenever
                        changes are made to any loaded modules

"""
import asyncore
import inspect
import logging
import os
import pdb
import signal
import socket
import subprocess
import sys
import time
import traceback

from httpy._zope.interface.verify import verifyClass, verifyObject
from httpy._zope.server.adjustments import default_adj
from httpy._zope.server.serverbase import ServerBase
from httpy._zope.server.taskthreads import ThreadedTaskDispatcher

from httpy.couplers.standalone.channel import Channel


STOP_SIGNALS = {}
STOP_SIGNALS[signal.SIGINT] = 'SIGINT'
STOP_SIGNALS[signal.SIGTERM] = 'SIGTERM'

WINDOWS = 'win' in sys.platform


class Server(ServerBase):
    """A standalone HTTP server.
    """

    # ServerBase boilerplate
    channel_class = Channel
    SERVER_IDENT = 'httpy'


    def __init__(self, responder, address, threads, uid):
        """Takes an IResponder.
        """

        #validate_input(responder, address, threads, uid)

        self.responder = responder
        self.address = address
        if address[0] in ('/', '.'):
            self.sockfam = socket.AF_UNIX
        else:
            self.sockfam = socket.AF_INET
        self.threads = threads
        self.uid = uid


        # Set up signal handling so we can shut down cleanly.
        # ===================================================

        for sig in STOP_SIGNALS:
            signal.signal(sig, self.stop)


        # Satisfy ServerBase requirements.
        # ================================

        asyncore.dispatcher.__init__(self)
        self.adj = default_adj
        if (not WINDOWS) and (self.sockfam == socket.AF_UNIX):
            # The default adjustment doesn't apply here, and triggers an error.
            self.adj.socket_options = []
        self.verbose = False
        task_dispatcher = ThreadedTaskDispatcher()
        task_dispatcher.setThreadCount(self.threads)
        self.task_dispatcher = task_dispatcher
        self.logger = logging.getLogger(self.__class__.__name__)


    def start(self):
        """Start the server.
        """

        # Bind to an address.
        # ===================

        self.create_socket(self.sockfam, socket.SOCK_STREAM)
        self.set_reuse_addr()
        if (not WINDOWS) and (self.sockfam == socket.AF_UNIX):
            if os.path.exists(self.address):
                os.unlink(self.address)

        timeout = time.time() + 10
        while 1:
            if time.time() < timeout:
                try:
                    self.bind(self.address)
                    break
                except socket.error, err:
                    time.sleep(0.5)
            else:
                raise err


        # Switch user accounts.
        # =====================

        if self.uid:
            os.setreuid(self.uid)


        # Start listening.
        # ================

        self.accept_connections()

        if self.sockfam == socket.AF_INET:
            addr, port = self.socket.getsockname()
            msg = "port %s" % port
        elif (not WINDOWS) and (self.sockfam == socket.AF_UNIX):
            msg = "%s" % self.address
        print >> sys.stderr, "HTTP server started on %s" % msg

        asyncore.loop(timeout=5)


    def stop(self, signum=None, frame=None):
        """Stop the server.
        """
        if signum is not None:
            msg = "caught %s, shutting down..." % STOP_SIGNALS[signum]
            sys.stderr.write(msg)
            sys.stderr.flush()

        if hasattr(self.responder, 'stop'):
            if inspect.ismethod(self.responder.stop):
                self.responder.stop()

        self.task_dispatcher.shutdown()
        asyncore.close_all()

        if (not WINDOWS) and (self.sockfam == socket.AF_UNIX):
            if os.path.exists(self.address):
                os.unlink(self.address)
        sys.stderr.write("done\n")
        sys.stderr.flush()



class Restart(StandardError):
    """Triggers a restart of the child server process.
    """


class RestartingServer:
    """Instantiate with a Config object, and start it with start().

    This server runs the *real* server in a separate process, restarting it
    whenever modules change on the filesystem. There are actually a number of
    ways to skin this deceptively simple cat. Here's what I've tried:

        Refresh modules directly from within the python process.
        --------------------------------------------------------

        The basic trick is to delete items from sys.modules, forcing a refresh
        the next time they are loaded. However, because modules import from one
        another, you need to make sure you reload enough of them to make it
        worth it. I got pretty far down this road (the place to start is to
        google for RollbackImporter), but at a couple points I started seeing
        very elusive segfaults. My best guess is that I was hitting a bug in
        Python, but I never narrowed it down enough to file it. :-(


        Run the python process within a wrapper that knows how to restart it.
        ---------------------------------------------------------------------

        Since you need to refresh almost all of your modules anyway, it makes a
        lot of sense to deal with the problem at the macro level. I got this
        idea from Ian Bicking via CherryPy. Thanks, guys. :-) Their version of
        this solution is to spawn a process and block for it, and then monitor
        the state of the modules on the filesystem in a separate thread. They
        use the blocked process's exit code to trigger reloading.


        Run within a wrapper but monitor within the process.
        ----------------------------------------------------

        I think it should also work to push the monitoring functionality down
        into the application, but I wasn't able to successfully exit zope.server
        from inside it, because I don't understand threading well enough.


        Run in a non-blocking process, monitor within the main process.
        ---------------------------------------------------------------

        The solution I've settled on here is to start the main server in a
        separate process, but not to block for it. I then monitor the filesystem
        in the main process/thread, and manipulate the worker process via its
        process ID. This solution, therefore, is not Windows-compatible. But,
        boy, is it simpler. :-)  See also: my above comment on me vs. threading.


    """

    def __init__(self, responder, address, threads, uid):

        self.responder = responder
        self.address = address
        if address[0] in ('/', '.'):
            self.sockfam = socket.AF_UNIX
        else:
            self.sockfam = socket.AF_INET
        self.threads = threads
        self.uid = uid

        self.mtimes = {}
        self.pid = -1
        for sig in STOP_SIGNALS:
           signal.signal(sig, self.stop)


    def start(self, args=None):
        print >> sys.stderr, "starting child server..."
        if args is None:
            args = [sys.executable] + sys.argv
        while 1:
            new_env = os.environ.copy()
            new_env['HTTPY_PLAIN_JANE'] = 'So plain.'
            try:
                try:
                    self.pid = subprocess.Popen(args, env=new_env).pid
                    while 1:
                        self.look_for_changes()
                        time.sleep(1)
                finally:
                    self.stop_child()
            except SystemExit:
                time.sleep(0.5) # Give stdout a chance to flush.
                raise
            except Restart:
                print >> sys.stderr, "restarting child server..."
            except:
                print >> sys.stderr, ( "exception while spawning child:\n"
                                     + traceback.format_exc()
                                      )


    def stop_child(self):
        """Stop the child server process.
        """
        if self.pid > 0:
            try:
                os.kill(self.pid, signal.SIGTERM)
            except OSError: # the pid doesn't exist
                print >> sys.stderr, "OSError killing pid %d" % self.pid
        else:
            print >> sys.stderr, "self.pid is %s; won't kill" % str(self.pid)

        if 0: # this is for debugging the restart-while-debugging bug

            pdb.Pdb().reset()

            print "isatty: %s %s %s" % tuple([x.isatty() for x in ( sys.stdin
                                                                  , sys.stdout
                                                                  , sys.stderr
                                                                  )])

            while 0:
                msg = os.read(0, 8192)
                if msg == 'quit\n':
                    break
                os.write(1, msg)

            #stdin = os.open('/dev/stdin', os.O_WRONLY)
            #os.dup2(stdin, 0)
            #stdout = os.open('/dev/stdout', os.O_WRONLY)
            #os.dup2(stdout, 1)
            #stderr = os.open('/dev/stderr', os.O_WRONLY)
            #os.dup2(stderr, 2)


    def stop(self, signum=-1, frame=None):
        """Stop the child process, then exit ourselves.
        """
        self.stop_child()
        if hasattr(self.responder, 'stop'):
            if inspect.ismethod(self.responder.stop):
                self.responder.stop()
        if signum is not None:
            msg = "parent caught %s; shutting down child..."
            print >> sys.stderr, msg % STOP_SIGNALS[signum]
        raise SystemExit


    def look_for_changes(self):
        """See if any of our available modules have changed on the filesystem.
        """

        for module in sys.modules.values():

            # Get out early if we can.
            # ========================

            filename = getattr(module, '__file__', None)
            if filename is None:
                continue
            if filename.endswith(".pyc"):
                filename = filename[:-1]


            # The file may have been removed from the filesystem.
            # ===================================================

            if not os.path.isfile(filename):
                print >> sys.stderr, "missing: %s" % filename
                if filename in self.mtimes:
                    del self.mtimes[filename]
                raise Restart


            # Or not.
            # =======

            mtime = os.stat(filename).st_mtime
            if filename not in self.mtimes:
                self.mtimes[filename] = mtime
                continue
            if mtime > self.mtimes[filename]:
                print >> sys.stderr, "outdated: %s" % filename
                self.mtimes[filename] = mtime
                raise Restart
