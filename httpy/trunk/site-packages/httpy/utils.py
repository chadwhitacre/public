"""This is a collection of utilities for httpy and httpy applications.
"""

import linecache
import mimetypes
import os
import stat
import sys
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote

from httpy.Response import Response


class Restart(Exception):
    """Signal to the main executable that it should restart the server.

    This is useful in development mode when we want to see changes immediately.

    """



def uri_to_fs(config, resource_uri_path, defaults=[]):
    """Map a requested URI to the filesystem.

    Takes a dictionary of config info (as produced by Task.configure), a URI
    path, and a list of filenames which should be considered default resources.

    The URI path is taken to be rooted literally in the filesystem root (which
    could be a site root or an application root). If it points to a directory,
    we look for a default resource if any are named. If it points to a file, we
    make sure the file exists.

    This method can raise the following Responses:

        301 Moved Permanently
        400 Bad Request
        403 Forbidden
        404 Not Found

    If successful, we return the filesystem path to the particular resource.

    """

    if config.app_fs_root == config.site_fs_root:
        resource_fs_path = os.path.join( config.site_fs_root
                                       , resource_uri_path.lstrip('/')
                                        )
    else:
        uri_below_app = resource_uri_path[len(config.app_uri_root):]
        resource_fs_path = os.path.join( config.app_fs_root
                                       , uri_below_app.lstrip('/')
                                        )


    if os.path.isdir(resource_fs_path):

        if not resource_uri_path.endswith('/'):
            # redirect directory requests to trailing slash
            new_location = '%s/' % resource_uri_path
            response = Response(301)
            response.headers['Location'] = new_location
            log(98, "Redirecting to trailing slash: %s" % resource_uri_path)
            raise response

        log(98, "Looking for these defaults: %s" % str(defaults))
        default = ''
        for name in defaults:
            _path = os.path.join(resource_fs_path, name)
            if os.path.isfile(_path):
                default = _path
                break
        resource_fs_path = default
        if not default:
            log(95, "No default resource in %s" % resource_uri_path)
            raise Response(403)

    else:
        if not os.path.exists(resource_fs_path):
            log(95, "Did not find %s at %s." % ( resource_uri_path
                                               , resource_fs_path
                                                ))
            raise Response(404)

    return resource_fs_path



# Following are some parsers useful for dynamic applications.
#
# While httpy.Request keeps close to the HTTP layer, any dynamic application
# will need to comprehend application-specific information encoded in the
# Request. The functions below return representations of such information as
# objects from the standard library.
#
#   function      uses                    returns
#   =========================================================
#   parse_query   uri['query']            cgi.FieldStorage
#   parse_cookie  message.get('Cookie')   Cookie.SimpleCookie
#   parse_post    raw_body                cgi.FieldStorage
#
#
# These functions are not used in httpy proper and are not unittested.


def parse_query(self, request):
    """Translate request's querystring into a cgi.FieldStorage.
    """

    if request.message is None:
        return None

    querystring = request.uri['query']
    fp = StringIO(querystring)

    headers = {}
    headers['content-type'] = request.message.get('content-type')
    headers['content-length'] = request.message.get('content-length')

    environ = {}
    environ['REQUEST_METHOD'] = request.method

    boundary = request.message.get('boundary')

    query = cgi.FieldStorage( fp = fp
                            , headers = headers
                            , outerboundary = boundary
                            , environ = environ
                            , keep_blank_values = True
                            , strict_parsing = False
                             )

    return query


def parse_cookie(self, request):
    """Translate request's cookie into a Cookie.SimpleCookie.
    """

    if request.message is None:
        return None

    raw_cookie = request.message.get('Cookie','')
    return SimpleCookie(raw_cookie)


def parse_post(self, request):
    """Translate request's body into a cgi.FieldStorage.
    """

    if request.message is None:
        return None

    fp = StringIO(request.raw_body)

    headers = {}
    headers['content-type'] = request.message.get('content-type')
    headers['content-length'] = request.message.get('content-length')

    environ = {}
    environ['REQUEST_METHOD'] = request.method

    boundary = request.message.get('boundary')

    post = cgi.FieldStorage( fp = fp
                           , headers = headers
                           , outerboundary = boundary
                           , environ = environ
                           , keep_blank_values = True
                           , strict_parsing = False
                            )

    return post


# Chad's logging util.

def log(verbosity, message):
    if int(os.environ.get("HTTPY_VERBOSITY", 0)) >= verbosity:
        print "%d  %s" % (verbosity, message)
        import sys; sys.stdout.flush()


# Steve's logging util.

from StringIO import StringIO
import new, threading

class dummy_outputer:
    def __init__(self): pass
    def write(self,*outputs): pass
    def writeln(self,*outputs): pass
    def __call__(self,*outputs): pass
    def dump(self): pass
    def pdump(self): pass

class outputer:
    """
    This is an initial implementation of an outputer class that acts
    like print but adds a couple of features:
        1) verbosity
        2) buffering
        3) output to places other than stdout

    Example usage:

    >>> out = outputer(1)
    >>> out.write('hey')
    >>> out.v2('hey','you')
    >>> out.v1('hey','you')
    >>> out.pdump()
    heyhey you
    >>> out('ack')
    >>> poo = out.dump()
    >>> poo
    'ack '
    """

    def __init__(self,verbosity=0,vlevels=5,parentFirst=None,parentContents=None):
        self.parentContents=parentContents
        self.first=threading.Event()
        self.parentFirst = parentFirst
        self.contents=StringIO()
        if not self.parentContents:
            for i in range(vlevels-1):
                v=i+1
                if v<=verbosity:
                    v_outputer = outputer(parentFirst=self.first,parentContents=self.contents)
                else:
                    v_outputer = dummy_outputer()
                setattr(self,'v%s'%v,v_outputer)

    def write(self,*outputs):
        for output in outputs:
            if self.parentContents:
                self.parentContents.write(str(output))
            self.contents.write(str(output))

    def writeln(self,*outputs):
        if not outputs:
            outputs=['']
        if not self.first.isSet():
            self.first.set()
        else:
            self.contents.write('\n')
        if self.parentContents:
            if not  self.parentFirst.isSet():
                self.parentFirst.set()
            else:
                self.parentContents.write('\n')
        for output in outputs:
            self.write(output)
            self.write(' ')

    def __call__(self,*outputs):
        self.writeln(*outputs)

    def dump(self):
        self.contents.flush()
        self.contents.seek(0)
        output = self.contents.read()
        self.contents=StringIO()
        self.first.clear()
        return output

    def pdump(self):
        print self.dump()
