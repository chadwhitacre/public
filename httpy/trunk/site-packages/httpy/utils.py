"""
"""

import mimetypes
import os
import stat
import sys
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote

from httpy.Response import Response


def log(verbosity, message):
    if int(os.environ.get("HTTPY_VERBOSITY", 0)) >= verbosity:
        print "%d  %s" % (verbosity, message)
        sys.stdout.flush()


def get_transaction(__):
    """Given a magic directory, return its Transaction.

    Having a magic directory is a promise that there is an app in there, with a
    Transaction in there, with a process method. If these aren't true then we
    fail.

    We could do better validation here (do __init__ and process take the right
    arguments?), and could probably even use zope interfaces.

    """

    _path = None
    if __ not in sys.path:
        _path = sys.path[:]
        sys.path.insert(0, __)

    try:
        import pdb; pdb.set_trace()
        import app
        log(98, "app has been imported.")
    except:
        log(90, "Failed to import app from %s." % __)
        raise

    if not hasattr(app, 'Transaction'):
        raise Exception("Unable to import Transaction from app at " +
                        "%s." % __)
    if not hasattr(app.Transaction, 'process'):
        raise Exception("The app.Transaction in %s does not " % __ +
                        "have a `process' method.")
    if not callable(app.Transaction.process):
        raise Exception("app.Transaction.process from %s is " % __ +
                        "not callable.")

    if _path:
        sys.path = _path

    return app.Transaction


def uri_to_fs(fs_root, uri_path, defaults=[]):
    """Given a fs path, a URI path, and a list of filenames, return a fs path.

    The URI path is taken to be rooted literally in the filesystem root. If it
    points to a directory, we look for a default resource if any are named. If
    it points to a file, we make sure the file exists.

    This method can raise the following Responses:

        301 Moved Permanently
        400 Bad Request
        403 Forbidden
        400 Not Found

    If successful, we return the filesystem path to the found resource.

    """

    full_path = os.path.join(config['root'], uri_path.lstrip('/'))

    if os.path.isdir(full_path):

        if not uri_path.endswith('/'):
            # redirect directory requests to trailing slash
            new_location = '%s/' % uri_path
            response = Response(301)
            response.headers = {'Location':new_location}
            log(98, "Redirecting to trailing slash: %s" % uri_path)
            raise response

        default = ''
        for name in config['defaults']:
            _path = os.path.join(full_path, name)
            if os.path.isfile(_path):
                default = _path
                break
        full_path = default

        if not default:
            log(94, "No default resource in %s" % uri_path)
            raise Response(403)

    else:
        if not os.path.exists(full_path):
            log(94, "Not Found: %s" % uri_path)
            raise Response(404)

    return full_path



class DynamicMixin:
    """This class provides API to help with requests for dynamic resources.

    While httpy.Request keeps close to the HTTP layer, any dynamic application
    will need to comprehend application-specific information encoded in the
    Request. The methods in this mixin represent such information as objects
    from the standard library, stored in the host Transaction's config.

        method      from (request)          to (config) type
        =======================================================================
        set_query   querystring             query       cgi.FieldStorage
        set_cookie  message.get('Cookie')   cookie      Cookie.SimpleCookie
        set_post    raw_body                post        cgi.FieldStorage

    """

    def set_query(self, request):
        """Translate request's querystring into a FieldStorage.
        """

        fp = StringIO(request.querystring)

        headers = {}
        headers['content-type'] = request.message.get('content-type')
        headers['content-length'] = request.message.get('content-length')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.message.get('boundary')

        query = cgi.FieldStorage( fp = fp
                                , headers = headers
                                , outerboundary = boundary
                                , environ = environ
                                , keep_blank_values = True
                                , strict_parsing = False
                                 )

        self.config['query'] = query


    def set_cookie(self, request):
        """Translate request's cookie into a SimpleCookie.
        """
        raw_cookie = request.message.get('Cookie','')
        self.config['cookie'] = SimpleCookie(raw_cookie)


    def set_post(self, request):
        """Translate request's body into a FieldStorage.
        """

        fp = StringIO(request.raw_body)

        headers = {}
        headers['content-type'] = request.message.get('content-type')
        headers['content-length'] = request.message.get('content-length')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.message.get('boundary')

        post = cgi.FieldStorage( fp = fp
                               , headers = headers
                               , outerboundary = boundary
                               , environ = environ
                               , keep_blank_values = True
                               , strict_parsing = False
                                )

        self.config['post']= post
'''

'''

from StringIO import StringIO
import new, threading

class dummy_outputer:
    def __init__(self): pass
    def write(self,*outputs): pass
    def writeln(self,*outputs): pass
    def __call__(self,*outputs): pass
    def dump(self): pass
    def pdump(self): pass

class outputer:
    """
    This is an initial implementation of an outputer class that acts
    like print but adds a couple of features:
        1) verbosity
        2) buffering
        3) output to places other than stdout

    Example usage:

    >>> out = outputer(1)
    >>> out.write('hey')
    >>> out.v2('hey','you')
    >>> out.v1('hey','you')
    >>> out.pdump()
    heyhey you
    >>> out('ack')
    >>> poo = out.dump()
    >>> poo
    'ack '
    """

    def __init__(self,verbosity=0,vlevels=5,parentFirst=None,parentContents=None):
        self.parentContents=parentContents
        self.first=threading.Event()
        self.parentFirst = parentFirst
        self.contents=StringIO()
        if not self.parentContents:
            for i in range(vlevels-1):
                v=i+1
                if v<=verbosity:
                    v_outputer = outputer(parentFirst=self.first,parentContents=self.contents)
                else:
                    v_outputer = dummy_outputer()
                setattr(self,'v%s'%v,v_outputer)

    def write(self,*outputs):
        for output in outputs:
            if self.parentContents:
                self.parentContents.write(str(output))
            self.contents.write(str(output))

    def writeln(self,*outputs):
        if not outputs:
            outputs=['']
        if not self.first.isSet():
            self.first.set()
        else:
            self.contents.write('\n')
        if self.parentContents:
            if not  self.parentFirst.isSet():
                self.parentFirst.set()
            else:
                self.parentContents.write('\n')
        for output in outputs:
            self.write(output)
            self.write(' ')

    def __call__(self,*outputs):
        self.writeln(*outputs)

    def dump(self):
        self.contents.flush()
        self.contents.seek(0)
        output = self.contents.read()
        self.contents=StringIO()
        self.first.clear()
        return output

    def pdump(self):
        print self.dump()
