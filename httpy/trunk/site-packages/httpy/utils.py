"""This is a collection of utilities for httpy and httpy applications.
"""

import cgi
import logging
import mimetypes
import os
import stat
import sys
import traceback
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote

from httpy import Response, responders



# main
# ====

def main(responder=None, configurator=None, argv=None):
    """Given an IResponder, an IConfig, and an argv, start an httpy server.

    This main() function is inspired by Guido's:

        http://www.artima.com/weblogs/viewpost.jsp?thread=4829

    """

    from httpy.config import Config
    from httpy.server import Server, RestartingServer


    # Set up top-level logging.
    # =========================
    # Do something smarter with this.

    format = "%(name)-16s %(levelname)-8s %(message)s"
    logging.basicConfig( level=logging.DEBUG
                       , format=format
                        )


    # Read in configuration.
    # ======================

    configurator = configurator or Config
    argv = argv or sys.argv[1:]
    try:
        config = configurator(argv)
    except ConfigError, err:
        print >> sys.stderr, err.msg
        print >> sys.stderr, "`man 1 httpy' for usage."
        return 2


    # Start a server.
    # ===============

    plain_jane = (  (os.environ['HTTPY_MODE'] == 'deployment')
                 or (sys.platform == 'win32')
                 or ('HTTPY_PLAIN_JANE' in os.environ)
                 or (sys.argv == ['']) # called interactively
                   )
    ServerClass = plain_jane and Server or RestartingServer
    responder = responder or responders.Default
    server = ServerClass(config, responder)
    server.start() # wheeeeee!



# mode
# ====

class mode:
    """Provide an API to httpy's runtime mode.

    This API is read-only, but we check os.environ on each call, so we will see
    any changes you make there.

    Usage:

        >>> httpy.mode                  # access to current mode
        development
        >>> httpy.mode.IS_DEVELOPMENT   # exposes flags
        True
        >>> httpy.mode.is_dep           # takes abbrevations; case-insensitive
        False
        >>> httpy.mode.IS_DE            # ambiguous == unknown
        Traceback (most recent call last):
        ...
        AttributeError
        >>> httpy.mode.default          # can see default mode
        'deployment'
        >>>

    """

    __options = ('deployment', 'staging', 'development', 'debugging')
    __longest = ''

    default = 'deployment'

    def __init__(self):
        i = 0
        for o in self.__options:
            if len(o) > i:
                self.__longest = o
                i = len(o)
        self.__range = range(1, len(self.__longest)+1)

    def __repr__(self):
        return os.environ.get('HTTPY_MODE', '')
    __str__ = __repr__

    def interpret(self, mode):
        """Given a possibly abbreviated mode, return the full name.
        """
        mode = mode.lower()
        for i in self.__range:
            matches = [o for o in self.__options if mode.startswith(o[:i])]
            if len(matches) == 1:
                return matches[0]
        return ''

    def __getattr__(self, name):
        """Try to interpret name as a mode, and return a boolean.
        """
        name = name.lower()
        if not name.startswith('is_'):
            raise AttributeError
        mode = self.interpret(name[3:])
        if mode not in self.__options:
            raise AttributeError
        if 'HTTPY_MODE' in os.environ:
            return os.environ['HTTPY_MODE'] == mode
        else:
            return mode == self.default

mode = mode() # Singleton



# Following are some parsers useful for dynamic applications.
#
# While httpy.Request keeps close to the HTTP layer, any dynamic application
# will need to comprehend application-specific information encoded in the
# Request. The functions below return representations of such information as
# objects from the standard library.
#
#   function      uses                    returns
#   =========================================================
#   parse_body    raw_body                cgi.FieldStorage
#   parse_cookie  message.get('Cookie')   Cookie.SimpleCookie
#   parse_query   uri['query']            cgi.FieldStorage


def parse_body(request):
    """Translate request's body into a cgi.FieldStorage.
    """

    if request.raw_body == '':
        body = None
    else:
        fp = StringIO(request.raw_body)

        headers = {}
        headers['content-type'] = request.message.get('content-type')
        headers['content-length'] = request.message.get('content-length')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.message.get('boundary')

        body = cgi.FieldStorage( fp = fp
                               , headers = headers
                               , outerboundary = boundary
                               , environ = environ
                               , keep_blank_values = True
                               , strict_parsing = False
                                )
    return body


def parse_cookie(request):
    """Translate request's cookie into a Cookie.SimpleCookie.
    """

    raw_cookie = request.message.get('Cookie','')
    return SimpleCookie(raw_cookie)


def parse_query(request):
    """Translate request's querystring into a cgi.FieldStorage.
    """

    querystring = request.uri['query']

    headers = {'content-type':'application/x-www-form-urlencoded'}

    environ = {}
    environ['REQUEST_METHOD'] = 'GET' # even for POST requests!
    environ['QUERY_STRING'] = querystring

    query = cgi.FieldStorage( fp = None
                            , headers = headers
                            , outerboundary = ''
                            , environ = environ
                            , keep_blank_values = True
                            , strict_parsing = False
                             )
    return query
