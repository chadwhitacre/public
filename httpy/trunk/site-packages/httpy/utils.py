"""This is a collection of utilities for httpy and httpy applications.
"""
import cgi
import logging
import os
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote


# mode
# ====

class mode:
    """Provide an API to httpy's runtime mode.

    This API is read-only, but we check os.environ on each call, so we will see
    any changes you make there.

    Usage:

        >>> httpy.mode                  # access to current mode
        development
        >>> httpy.mode.IS_DEVELOPMENT   # exposes flags
        True
        >>> httpy.mode.is_dep           # takes abbrevations; case-insensitive
        False
        >>> httpy.mode.IS_DE            # ambiguous == unknown
        Traceback (most recent call last):
        ...
        AttributeError
        >>> httpy.mode.default          # can see default mode
        'development'
        >>>


    The default is development, so that you don't accidentally connect to a live
    data source or something.

    """

    __options = ('debugging', 'deployment', 'development', 'staging')
    __longest = ''

    default = 'development'

    def __init__(self):
        i = 0
        for o in self.__options:
            if len(o) > i:
                self.__longest = o
                i = len(o)
        self.__range = range(1, len(self.__longest)+1)

    def __repr__(self):
        return self._current()
    __str__ = __repr__

    def _current(self):
        return os.environ.get('HTTPY_MODE', self.default)

    def _interpret(self, mode):
        """Given a possibly abbreviated mode, return the full name.
        """
        mode = mode.lower()
        for i in self.__range:
            matches = [o for o in self.__options if mode.startswith(o[:i])]
            if len(matches) == 1:
                return matches[0]
        return ''

    def __getattr__(self, name):
        """Try to interpret name as a mode, and return a boolean.
        """
        name = name.lower()
        if not name.startswith('is_'):
            raise AttributeError
        mode = self._interpret(name[3:])
        if mode not in self.__options:
            raise AttributeError
        return mode == self._current()

mode = mode() # Singleton


def isiter(foo):
    return hasattr(foo, '__iter__') and hasattr(foo, 'next')


# Following are some parsers useful for dynamic applications.
#
# While httpy.couplers.standalone.request keeps close to the HTTP layer, any dynamic application
# will need to comprehend application-specific information encoded in the
# Request. The functions below return representations of such information as
# objects from the standard library.
#
#   function      uses                    returns
#   =========================================================
#   parse_body    raw_body                cgi.FieldStorage
#   parse_cookie  headers.get('Cookie')   Cookie.SimpleCookie
#   parse_query   uri['query']            cgi.FieldStorage


def parse_body(request):
    """Translate request's body into a cgi.FieldStorage.
    """

    if request.raw_body == '':
        body = None
    else:
        fp = StringIO(request.raw_body)

        headers = {}
        headers['content-type'] = request.headers.get('content-type', '')
        headers['content-length'] = request.headers.get('content-length', '')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.headers.get('boundary')

        body = cgi.FieldStorage( fp = fp
                               , headers = headers
                               , outerboundary = boundary
                               , environ = environ
                               , keep_blank_values = True
                               , strict_parsing = False
                                )
    return body


def parse_cookie(request):
    """Translate request's cookie into a Cookie.SimpleCookie.
    """

    raw_cookie = request.headers.get('Cookie','')
    return SimpleCookie(raw_cookie)


def parse_query(request):
    """Translate request's querystring into a cgi.FieldStorage.
    """

    querystring = request.uri['query']

    headers = {'content-type':'application/x-www-form-urlencoded'}

    environ = {}
    environ['REQUEST_METHOD'] = 'GET' # even for POST requests!
    environ['QUERY_STRING'] = querystring

    query = cgi.FieldStorage( fp = None
                            , headers = headers
                            , outerboundary = ''
                            , environ = environ
                            , keep_blank_values = True
                            , strict_parsing = False
                             )
    return query


def parse_fieldstorage(fieldstorage):
    """Given a cgi.FieldStorage object, return a dictionary.

    The values in the dictionary will be whitespace-stripped and HTML-escaped.

    """
    d = {}
    if fieldstorage is not None:
        for k in fieldstorage:
            d[k] = cgi.escape(fieldstorage.getfirst(k).strip())
    return d
