"""This is a collection of utilities for httpy and httpy applications.
"""

import cgi
import logging
import mimetypes
import os
import stat
import sys
import traceback
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote

from httpy import Response
from httpy.config import Config
from httpy.server import Server, RestartingServer
from httpy import responders


def main(argv, ConfigClass=Config, responder=None):
    """Given an argv, an IConfig and an IFramework, start an httpy server.

    This main() function is inspired by Guido's:

        http://www.artima.com/weblogs/viewpost.jsp?thread=4829

    """

    # Set up top-level logging.
    # =========================
    # Do something smarter with this.

    format = "%(name)-16s %(levelname)-8s %(message)s"
    logging.basicConfig( level=logging.DEBUG
                       , format=format
                        )


    # Read in configuration.
    # ======================

    if argv is None:
        argv = sys.argv[1:]
    try:
        config = ConfigClass(argv)
    except ConfigError, err:
        print >> sys.stderr, err.msg
        print >> sys.stderr, "`man 1 httpy' for usage."
        return 2


    # Start a server.
    # ===============

    plain_jane = (  (os.environ['HTTPY_MODE'] == 'deployment')
                 or (sys.platform == 'win32')
                 or ('HTTPY_PLAIN_JANE' in os.environ)
                   )
    ServerClass = plain_jane and Server or RestartingServer
    responder = responder or responders.Default
    server = ServerClass(config, responder)
    server.start() # wheeeeee!


def get_framework(self, paths):
    """Given a list of paths to check, return an IFramework.
    """

    try:
        logger.debug("loading framework ...")
        fp, pathname, description = imp.find_module('framework', paths)
        framework = imp.load_module('framework', fp, pathname, description)
    except ImportError:
        logger.warning("framework import failed:\n" +
                       traceback.format_exc())
        logger.info("falling back to passthrough")
        framework = default.Framework


    # Add API and return.
    # ===================

    #framework.__ = self.config.__
    #framework.site_root = self.config.root

    return framework



class mode:
    """Provide a read-only API to httpy's runtime mode.

    Usage:

        >>> httpy.mode.DEVELOPMENT
        True
        >>> httpy.mode.DEP
        True
        >>> httpy.mode.DE
        False

    """

    __options = ('deployment', 'staging', 'development', 'debugging')
    __longest = ''

    default = 'deployment'

    def __init__(self):
        i = 0
        for o in self.__options:
            if len(o) > i:
                self.__longest = o
        self.__range = range(1, len(self.__longest)+1)

    def interpret(self, mode):
        """Given a possibly abbreviated mode, return the full name.
        """
        mode = mode.lower()
        for i in self.__range:
            matches = [o for o in self.__options if mode.startswith(o[:i])]
            if len(matches) == 1:
                return matches[0]
        return ''

    def __getattr__(self, name):
        """Try to interpret name as a mode, and return a boolean.
        """
        mode = interpret(name)
        if mode not in self.__options:
            return self.default
        elif 'HTTPY_MODE' not in os.environ:
            return self.default
        else:
            return os.environ['HTTPY_MODE'] == mode

mode = mode() # Singleton



def uri_to_fs(site_root, app_fs_root, app_uri_root, resource_uri_path,
              defaults=[], raw=False):
    """Map a requested URI to the filesystem.

    Takes a few paths, a list of filenames which should be considered default
    resources, and a flag indicating whether to return the path before doing any
    validation or defaults.

    The URI path is taken to be rooted literally in the filesystem root (which
    could be a site root or an application root). If it points to a directory,
    we look for a default resource if any are named. If it points to a file, we
    make sure the file exists.

    This method can raise the following Responses:

        301 Moved Permanently
        400 Bad Request
        403 Forbidden
        404 Not Found

    If successful, we return the filesystem path to the particular resource.

    """

    logger = logging.getLogger('httpy.utils.uri_to_fs')


    # Knit the requested URI onto the application root.
    # =================================================

    if app_fs_root == site_root:
        _parts = resource_uri_path.lstrip('/').split('/')
    else:
        uri_below_app = resource_uri_path[len(app_uri_root):]
        _parts = uri_below_app.lstrip('/').split('/')

    _parts.insert(0, app_fs_root)
    resource_fs_path = os.sep.join(_parts)
    resource_fs_path = os.path.realpath(resource_fs_path)


    if raw:
        return resource_fs_path


    if os.path.isdir(resource_fs_path):

        # Process the request as a directory.
        # ===================================

        if not resource_uri_path.endswith('/'):
            # redirect directory requests to trailing slash
            new_location = '%s/' % resource_uri_path
            response = Response(301)
            response.headers['Location'] = new_location
            logger.debug("redirecting to trailing slash: %s" % resource_uri_path)
            raise response

        logger.debug("looking for these defaults: %s" % str(defaults))
        default = ''
        for name in defaults:
            _path = os.path.join(resource_fs_path, name)
            if os.path.isfile(_path):
                default = _path
                break
        resource_fs_path = default
        if not default:
            logger.debug("no default resource in: %s" % resource_fs_path)
            raise Response(403)

    else:

        # Process the request as a file.
        # ==============================

        if not os.path.exists(resource_fs_path):
            logger.debug("did not find %s at %s" % ( resource_uri_path
                                               , resource_fs_path
                                                ))
            raise Response(404)


    return resource_fs_path



# Following are some parsers useful for dynamic applications.
#
# While httpy.Request keeps close to the HTTP layer, any dynamic application
# will need to comprehend application-specific information encoded in the
# Request. The functions below return representations of such information as
# objects from the standard library.
#
#   function      uses                    returns
#   =========================================================
#   parse_body    raw_body                cgi.FieldStorage
#   parse_cookie  message.get('Cookie')   Cookie.SimpleCookie
#   parse_query   uri['query']            cgi.FieldStorage


def parse_body(request):
    """Translate request's body into a cgi.FieldStorage.
    """

    if request.raw_body == '':
        body = None
    else:
        fp = StringIO(request.raw_body)

        headers = {}
        headers['content-type'] = request.message.get('content-type')
        headers['content-length'] = request.message.get('content-length')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.message.get('boundary')

        body = cgi.FieldStorage( fp = fp
                               , headers = headers
                               , outerboundary = boundary
                               , environ = environ
                               , keep_blank_values = True
                               , strict_parsing = False
                                )
    return body


def parse_cookie(request):
    """Translate request's cookie into a Cookie.SimpleCookie.
    """

    raw_cookie = request.message.get('Cookie','')
    return SimpleCookie(raw_cookie)


def parse_query(request):
    """Translate request's querystring into a cgi.FieldStorage.
    """

    querystring = request.uri['query']

    headers = {'content-type':'application/x-www-form-urlencoded'}

    environ = {}
    environ['REQUEST_METHOD'] = 'GET' # even for POST requests!
    environ['QUERY_STRING'] = querystring

    query = cgi.FieldStorage( fp = None
                            , headers = headers
                            , outerboundary = ''
                            , environ = environ
                            , keep_blank_values = True
                            , strict_parsing = False
                             )
    return query
