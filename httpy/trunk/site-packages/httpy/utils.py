"""This is a collection of utilities for httpy and httpy applications.
"""
import cgi
import logging
import os
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote


__all__ = ('translate', 'parse_body', 'parse_cookie', 'parse_query')


# mode
# ====

class mode:
    """Provide an API to httpy's runtime mode.

    This API is read-only, but we check os.environ on each call, so we will see
    any changes you make there.

    Usage:

        >>> httpy.mode                  # access to current mode
        development
        >>> httpy.mode.IS_DEVELOPMENT   # exposes flags
        True
        >>> httpy.mode.is_dep           # takes abbrevations; case-insensitive
        False
        >>> httpy.mode.IS_DE            # ambiguous == unknown
        Traceback (most recent call last):
        ...
        AttributeError
        >>> httpy.mode.default          # can see default mode
        'development'
        >>>


    The default is development, so that you don't accidentally connect to a live
    data source or something.

    """

    __options = ('debugging', 'deployment', 'development', 'staging')
    __longest = ''

    default = 'development'

    def __init__(self):
        i = 0
        for o in self.__options:
            if len(o) > i:
                self.__longest = o
                i = len(o)
        self.__range = range(1, len(self.__longest)+1)

    def __repr__(self):
        return self._current()
    __str__ = __repr__

    def _current(self):
        return os.environ.get('HTTPY_MODE', self.default)

    def _interpret(self, mode):
        """Given a possibly abbreviated mode, return the full name.
        """
        mode = mode.lower()
        for i in self.__range:
            matches = [o for o in self.__options if mode.startswith(o[:i])]
            if len(matches) == 1:
                return matches[0]
        return ''

    def __getattr__(self, name):
        """Try to interpret name as a mode, and return a boolean.
        """
        name = name.lower()
        if not name.startswith('is_'):
            raise AttributeError
        mode = self._interpret(name[3:])
        if mode not in self.__options:
            raise AttributeError
        return mode == self._current()

mode = mode() # Singleton


# couple
# ======

def couple(Responder):
    """Given a responder, put it on the network.
    """
    if os.environ.has_key("GATEWAY_INTERFACE"):
        from httpy.couplers.cgi import Coupler
    elif os.environ.has_key("FCGI_WEB_SERVER_ADDRS"): # not working
        # see http://antony.lesuisse.org/qweb/trac/browser/trunk/python/qweb/qweb.py#L1314
        from httpy.couplers.fastcgi import Coupler
    else:
        from httpy.couplers.standalone import Coupler
    coupler = Coupler(Responder)
    coupler.go()



# translate
# =========

def translate(uri_path, fs_root, defaults=[], raw=False):
    """Translate a requested URI to the filesystem.

    Takes a URI path, a filesystem path, and a list of filenames which should be
    considered default resources. The URI path is taken to be rooted in the
    filesystem path. If raw is True, then we perform no validation and look for
    no defaults.

    If raw is False, and the requested path points to a directory, we ensure
    that the URI ends with a slash, and we look for a default resource if any
    are named. If the URI points to a file, we make sure the file exists.

    This method can raise the following Responses:

        301 Moved Permanently
        403 Forbidden
        404 Not Found

    If successful, we return the filesystem path to the particular resource.

    """

    from httpy import Response

    logger = logging.getLogger('httpy.utils.translate')


    # Knit the requested URI onto the filesystem path.
    # ================================================

    _parts = [fs_root] + uri_path.lstrip('/').split('/')
    fs_path = os.sep.join(_parts)
    fs_path = os.path.realpath(fs_path)

    if raw:
        return fs_path


    # Interpret it.
    # =============

    if os.path.isdir(fs_path):

        # Process the request as a directory.
        # ===================================

        if not uri_path.endswith('/'):
            # redirect directory requests to trailing slash
            new_location = '%s/' % uri_path
            response = Response(301)
            response.headers['Location'] = new_location
            logger.debug("redirecting to trailing slash: %s" % new_location)
            raise response

        logger.debug("looking for these defaults: %s" % str(defaults))
        default = None
        for name in defaults:
            _path = os.path.join(fs_path, name)
            if os.path.isfile(_path):
                default = _path
                break
        if default is None:
            logger.debug("no default resource in: %s" % fs_path)
            raise Response(403)
        fs_path = default

    else:

        # Process the request as a file.
        # ==============================

        if not os.path.exists(fs_path):
            logger.debug("did not find %s at %s" % (uri_path, fs_path))
            raise Response(404)


    return fs_path


def isiter(foo):
    return hasattr(foo, '__iter__') and hasattr(foo, 'next')


# Following are some parsers useful for dynamic applications.
#
# While httpy.couplers.standalone.request keeps close to the HTTP layer, any dynamic application
# will need to comprehend application-specific information encoded in the
# Request. The functions below return representations of such information as
# objects from the standard library.
#
#   function      uses                    returns
#   =========================================================
#   parse_body    raw_body                cgi.FieldStorage
#   parse_cookie  headers.get('Cookie')   Cookie.SimpleCookie
#   parse_query   uri['query']            cgi.FieldStorage


def parse_body(request):
    """Translate request's body into a cgi.FieldStorage.
    """

    if request.raw_body == '':
        body = None
    else:
        fp = StringIO(request.raw_body)

        headers = {}
        headers['content-type'] = request.headers.get('content-type', '')
        headers['content-length'] = request.headers.get('content-length', '')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.headers.get('boundary')

        body = cgi.FieldStorage( fp = fp
                               , headers = headers
                               , outerboundary = boundary
                               , environ = environ
                               , keep_blank_values = True
                               , strict_parsing = False
                                )
    return body


def parse_cookie(request):
    """Translate request's cookie into a Cookie.SimpleCookie.
    """

    raw_cookie = request.headers.get('Cookie','')
    return SimpleCookie(raw_cookie)


def parse_query(request):
    """Translate request's querystring into a cgi.FieldStorage.
    """

    querystring = request.uri['query']

    headers = {'content-type':'application/x-www-form-urlencoded'}

    environ = {}
    environ['REQUEST_METHOD'] = 'GET' # even for POST requests!
    environ['QUERY_STRING'] = querystring

    query = cgi.FieldStorage( fp = None
                            , headers = headers
                            , outerboundary = ''
                            , environ = environ
                            , keep_blank_values = True
                            , strict_parsing = False
                             )
    return query


def parse_fieldstorage(fieldstorage):
    """Given a cgi.FieldStorage object, return a dictionary.

    The values in the dictionary will be whitespace-stripped and HTML-escaped.

    """
    d = {}
    if fieldstorage is not None:
        for k in fieldstorage:
            d[k] = cgi.escape(fieldstorage.getfirst(k).strip())
    return d
