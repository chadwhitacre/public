"""This is a collection of utilities for httpy and httpy applications.
"""

import cgi
import imp
import mimetypes
import os
import stat
import sys
import traceback
from Cookie import SimpleCookie
from StringIO import StringIO
from urllib import unquote

from httpy import DefaultApp
from httpy.Response import Response
from httpy.interfaces import IApp, IApplication
from httpy._zope.interface.verify import verifyClass, verifyObject


# Application initialization utilities -- find_apps, load_app
# ===========================================================

def find_apps(site_root):
    """Given an absolute fs path, return a sequence of apps below that path.

    All apps are specified in URL-space; they should not include the website
    filesystem root. They should begin with a single forward slash, but
    should not end with one.

    This method is run from Config if the user has not explicitly configured
    apps. Our rationale for this violation of EIBTI is that apps is the only
    configuration parameter that cannot be arbitrarily changed at deployment
    time. In other words, a site can discharge its duty regardless of what ip or
    port it is on, but a misconfigured apps setting will break a site.

    To achieve our design goal of zero configuration (and thereby to reduce
    friction in an auto-deployment situation), httpy needs to be able to
    introspect a website's applications in a predictable manner. Building
    this functionality in at this level means we can get used to it in
    development, so that we can trust it in deployment.

    """

    # Note that apps are defined in URL-space, so the forward slash should
    # always be used as the path separator.

    apps = []
    for path, dirs, files in os.walk(site_root):
        if '.svn' in dirs:
            dirs.remove('.svn')
        dirs = sorted(dirs)
        if '__' in dirs:
            if path == site_root:
                app_fs_root = '/'
            else:
                app_fs_root = path[len(site_root):].replace(os.sep, '/')
            if '__' not in app_fs_root.split('/'):
                apps.append(app_fs_root)
    return tuple(reversed(apps))


def load_app(site_root, app_uri_root):
    """Given a site's FS root and an app's URI root, return the application.
    """

    msg = ("Found bad app `%s'. Each app must be a path rooted in the " +
           "website root, and it must have a subdirectory named __.")


    # Find the app's filesystem root.
    # ===============================

    _parts = [p for p in app_uri_root.lstrip('/').split('/') if p]
    _parts.insert(0, site_root)
    fs_root = os.sep.join(_parts)
    if not os.path.isdir(fs_root):
        raise StandardError(msg % fs_root)


    # Find the app's magic directory.
    # ===============================

    __ = os.path.join(fs_root, '__')
    if not os.path.isdir(__):
        if fs_root == site_root:
            __ = None # special case
        else:
            raise StandardError(msg % fs_root)


    # Load the actual module.
    # =======================
    # We support automatically falling back to DefaultApp for the root
    # directory. Otherwise, we fail if there is no importable app. We also
    # validate the app using zope interfaces. Your app needn't implement zope
    # interfaces explicitly, however. Also note that we import each app under
    # the app_uri_root so that they don't collide in sys.modules.

    if __ is None:
        log(93, "Falling back to DefaultApp for %s" % site_root)
        app = DefaultApp
    else:
        log(92, "Loading app from %s" % __)
        try:
            fp, pathname, description = imp.find_module('app', [__])
            app = imp.load_module(app_uri_root, fp, pathname, description)
        except ImportError:
            raise ImportError("Unable to import an app from " +
                              "%s: \n%s" % (__, traceback.format_exc()))

    try:
        verifyObject(IApp, app, tentative=True)
    except:
        log(91, "app in %s is not valid." % fs_root)
        raise
    try:
        verifyClass(IApplication, app.Application, tentative=True)
    except:
        log(91, "app.Application in %s is not valid." % fs_root)
        raise


    # Add some useful API to Application, and return an instance.
    # ===========================================================

    mode = os.environ.get('HTTPY_MODE', 'deployment')
    app.Application.debug_mode  = mode == 'debugging'
    app.Application.deploy_mode = mode == 'deployment'
    app.Application.devel_mode  = mode == 'development'
    app.Application.site_root   = site_root
    app.Application.uri_root    = app_uri_root
    app.Application.fs_root     = fs_root
    app.Application.__          = __

    return app.Application()



# Application runtime utilities -- uri_to_fs, parse_*
# ===================================================

def uri_to_fs(site_root, app_fs_root, app_uri_root, resource_uri_path,
              defaults=[], raw=False):
    """Map a requested URI to the filesystem.

    Takes a ApplicationConfig object, a URI path, and a list of filenames which
    should be considered default resources.

    The URI path is taken to be rooted literally in the filesystem root (which
    could be a site root or an application root). If it points to a directory,
    we look for a default resource if any are named. If it points to a file, we
    make sure the file exists.

    This method can raise the following Responses:

        301 Moved Permanently
        400 Bad Request
        403 Forbidden
        404 Not Found

    If successful, we return the filesystem path to the particular resource.

    """

    # Knit the requested URI onto the application root.
    # =================================================

    if app_fs_root == site_root:
        _parts = resource_uri_path.lstrip('/').split('/')
    else:
        uri_below_app = resource_uri_path[len(app_uri_root):]
        _parts = uri_below_app.lstrip('/').split('/')

    _parts.insert(0, app_fs_root)
    resource_fs_path = os.sep.join(_parts)
    resource_fs_path = os.path.realpath(resource_fs_path)


    if raw:
        return resource_fs_path


    if os.path.isdir(resource_fs_path):

        # Process the request as a directory.
        # ===================================

        if not resource_uri_path.endswith('/'):
            # redirect directory requests to trailing slash
            new_location = '%s/' % resource_uri_path
            response = Response(301)
            response.headers['Location'] = new_location
            log(98, "Redirecting to trailing slash: %s" % resource_uri_path)
            raise response

        log(98, "Looking for these defaults: %s" % str(defaults))
        default = ''
        for name in defaults:
            _path = os.path.join(resource_fs_path, name)
            if os.path.isfile(_path):
                default = _path
                break
        resource_fs_path = default
        if not default:
            log(95, "No default resource in %s" % resource_uri_path)
            raise Response(403)

    else:

        # Process the request as a file.
        # ==============================

        if not os.path.exists(resource_fs_path):
            log(95, "Did not find %s at %s." % ( resource_uri_path
                                               , resource_fs_path
                                                ))
            raise Response(404)


    return resource_fs_path


# Following are some parsers useful for dynamic applications.
#
# While httpy.Request keeps close to the HTTP layer, any dynamic application
# will need to comprehend application-specific information encoded in the
# Request. The functions below return representations of such information as
# objects from the standard library.
#
#   function      uses                    returns
#   =========================================================
#   parse_body    raw_body                cgi.FieldStorage
#   parse_cookie  message.get('Cookie')   Cookie.SimpleCookie
#   parse_query   uri['query']            cgi.FieldStorage


def parse_body(request):
    """Translate request's body into a cgi.FieldStorage.
    """

    if request.raw_body == '':
        body = None
    else:
        fp = StringIO(request.raw_body)

        headers = {}
        headers['content-type'] = request.message.get('content-type')
        headers['content-length'] = request.message.get('content-length')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.message.get('boundary')

        body = cgi.FieldStorage( fp = fp
                               , headers = headers
                               , outerboundary = boundary
                               , environ = environ
                               , keep_blank_values = True
                               , strict_parsing = False
                                )
    return body


def parse_cookie(request):
    """Translate request's cookie into a Cookie.SimpleCookie.
    """

    raw_cookie = request.message.get('Cookie','')
    return SimpleCookie(raw_cookie)


def parse_query(request):
    """Translate request's querystring into a cgi.FieldStorage.
    """

    querystring = request.uri['query']

    if querystring == '':
        query = None
    else:
        fp = StringIO(querystring)

        headers = {}
        headers['content-type'] = request.message.get('content-type')
        headers['content-length'] = request.message.get('content-length')

        environ = {}
        environ['REQUEST_METHOD'] = request.method

        boundary = request.message.get('boundary')

        query = cgi.FieldStorage( fp = fp
                                , headers = headers
                                , outerboundary = boundary
                                , environ = environ
                                , keep_blank_values = True
                                , strict_parsing = False
                                 )
    return query



# Logging utilities -- Chad's and Steve's
# =======================================

# Chad's logging util.

def log(verbosity, message):
    if int(os.environ.get("HTTPY_VERBOSITY", 0)) >= verbosity:
        print "%02d  %s" % (verbosity, message)
        import sys; sys.stdout.flush()


# Steve's logging util.

from StringIO import StringIO
import new, threading

class dummy_outputer:
    def __init__(self): pass
    def write(self,*outputs): pass
    def writeln(self,*outputs): pass
    def __call__(self,*outputs): pass
    def dump(self): pass
    def pdump(self): pass

class outputer:
    """
    This is an initial implementation of an outputer class that acts
    like print but adds a couple of features:
        1) verbosity
        2) buffering
        3) output to places other than stdout

    Example usage:

    >>> out = outputer(1)
    >>> out.write('hey')
    >>> out.v2('hey','you')
    >>> out.v1('hey','you')
    >>> out.pdump()
    heyhey you
    >>> out('ack')
    >>> poo = out.dump()
    >>> poo
    'ack '
    """

    def __init__(self,verbosity=0,vlevels=5,parentFirst=None,parentContents=None):
        self.parentContents=parentContents
        self.first=threading.Event()
        self.parentFirst = parentFirst
        self.contents=StringIO()
        if not self.parentContents:
            for i in range(vlevels-1):
                v=i+1
                if v<=verbosity:
                    v_outputer = outputer(parentFirst=self.first,parentContents=self.contents)
                else:
                    v_outputer = dummy_outputer()
                setattr(self,'v%s'%v,v_outputer)

    def write(self,*outputs):
        for output in outputs:
            if self.parentContents:
                self.parentContents.write(str(output))
            self.contents.write(str(output))

    def writeln(self,*outputs):
        if not outputs:
            outputs=['']
        if not self.first.isSet():
            self.first.set()
        else:
            self.contents.write('\n')
        if self.parentContents:
            if not  self.parentFirst.isSet():
                self.parentFirst.set()
            else:
                self.parentContents.write('\n')
        for output in outputs:
            self.write(output)
            self.write(' ')

    def __call__(self,*outputs):
        self.writeln(*outputs)

    def dump(self):
        self.contents.flush()
        self.contents.seek(0)
        output = self.contents.read()
        self.contents=StringIO()
        self.first.clear()
        return output

    def pdump(self):
        print self.dump()
