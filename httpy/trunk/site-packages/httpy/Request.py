import cgi
import re
import urllib
import urlparse
from email.FeedParser import FeedParser

from httpy.Response import Response


# Precompile a regular expression.
# ================================

HTTP_VERSION = re.compile(r'^HTTP/(\d+)\.(\d+)$')


class Request:
    """An HTTP Request message.

        http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html

    A Request instance has the following attributes:

        attribute           description or example
        =======================================================================
        raw                 the raw Request as found on the wire
        raw_line            the raw Request-Line
        raw_message         the raw message
        raw_headers         the raw message headers
        raw_body            the raw message body

        method              'GET'
        uri                 'http://www.example.com:80/index.html?foo=bar'
        path                '/index.html'
        querystring         'foo=bar'
        version             'HTTP/1.1'
        version_tuple       (1, 1)

        message             the message as an instance of email.Message.Message

    """

    def __init__(self, stream):
        """This takes an incoming HTTP stream.
        """
        self.raw = []
        self.set_line(stream)
        self.set_headers(stream)
        self.set_body(stream)
        self.raw = ''.join(self.raw)


    def set_line(self, stream):
        """Given an HTTP stream, parse and store the Request-Line.

        The HTTP stream must be positioned at the start of a request. The
        Request-Line is resolved into method, uri, and version, which are
        validated. Some helpful values are derived from these tokens, and all
        this information is stored on self.

        """

        # Read and tokenize the Request-Line.
        # ===================================

        raw_line = stream.readline()
        while raw_line == '\r\n':
            # Skip initial blank lines to account for IE's buggy POST
            # implementation.
            raw_line = stream.readline()
        line = raw_line.rstrip('/n').rstrip('/r')
        tokens = line.split()
        if len(tokens) == 3:
            method, uri, version = tokens
        elif len(tokens) == 2:
            method, uri = tokens
            version = 'HTTP/0.9'
        else:
            raise Response(400, "The Request-Line `%s' appears " % line +
                                      "to be malformed because it has " +
                                      "neither two nor three tokens.")


        # Validate the method.
        # ====================

        if method not in ('GET', 'HEAD', 'POST'):
            raise Response(501, "This server does not implement " +
                                          "the `%s' method." % method)


        # Parse the URI into a dictionary.
        # ================================
        # We use the urlparse naming convention for uri's keys.

        uri = urlparse.urlsplit(uri)
        keys = ( 'scheme'
               , 'netloc'
               , 'path'
               , 'query'
               , 'fragment'
                )
        _uri = {}
        for i in range(len(uri)):
            k = keys[i]
            v = uri[i]
            _uri[k] = v
        uri = _uri


        # Validate and possibly unencode the path.
        # ========================================

        if not uri['path']:
            # this catches, e.g., '//foo'
            raise Response(400)
        if '%' in uri['path']:
            uri['path'] = urllib.unquote(uri['path'])


        # Validate the version.
        # =====================
        # Consider raising an HTTPVersionNotSupported here ... for 0.9? 2.0?

        m = HTTP_VERSION.match(version)
        if not m:
            raise  Response(400, "The HTTP-Version `%s' " % version +
                                      "appears to be malformed because " +
                                      "it does not match the pattern " +
                                      "`^HTTP/\d+\.\d+$'.")

        version_tuple = tuple([int(i) for i in m.groups()])


        # Store the most important info on self.
        # ======================================

        # raw line
        self.raw.append(raw_line)
        self.raw_line = line

        # tokens
        self.method = method
        self.uri = uri
        self.version = version

        # derivatives
        self.path = uri['path']
        self.querystring = uri['query']
        self.version_tuple = version_tuple


    def set_headers(self, stream):
        """Given an HTTP stream, parse and store the message headers.

        The HTTP stream must be positioned at the second line of a request.

        The message headers are read and a new Message instance is added to
        self. This instance will be updated in set_body once the body has been
        read. We have to do this in two stages because the length of the body is
        communicated to us via the headers.

        """

        # Read in everything until the next blank line, parsing as we go.
        # ===============================================================

        raw_headers = []
        parser_ = FeedParser()
        for line in stream:
            raw_headers.append(line)
            parser_.feed(line)
            if line == '\r\n':
                break


        # Now store on self.
        # ==================

        self.raw.extend(raw_headers)
        self.raw_headers = ''.join(raw_headers)
        self.message = parser_.close()


    def set_body(self, stream):
        """Given an HTTP stream, parse and store the message body.

        The HTTP stream must be positioned at the end of the headers.

        """

        content_length = int(self.message.get('Content-Length', 0))
        transfer_encoding = self.message.get('Transfer-Encoding', '')

        if not content_length and not transfer_encoding:
            raw_body = ''

        elif content_length and not transfer_encoding:
            raw_body = stream.read(content_length)

        elif transfer_encoding:
            "http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.4.6"
            raise Response(501)


        # Toss the body away if the requested method doesn't allow for it.
        # ================================================================
        # I read Section 4.3 to call for this behavior rather than, e.g.,
        # returning a 400. I suppose the concern is that the input stream
        # be properly positioned.

        if self.method not in ('POST', 'PUT'):
            raw_body == None


        # Update self.message with the body.
        # ==================================
        # This accounts for both single and multipart messages.

        boundary = self.message.get_boundary()
        if not boundary:
            self.message.set_payload(raw_body)
        else:
            self.message.set_payload(None)
            parts = raw_body.split(boundary)
            for part in parts:
                self.message.attach(part)


        # Store on self.
        # ==============

        self.raw.append(raw_body)
        self.raw_body = raw_body
        self.raw_message = ''.join(self.raw[1:])



"""
TODO

*safely* unescape uri -- http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
handle chunked transfer encodings
character sets
unit tests

=====DONE=====
parse multipart --> app


"""
