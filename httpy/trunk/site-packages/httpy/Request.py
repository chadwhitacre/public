import cgi
import os
import re
import urllib
import urlparse
from email import message_from_string

from zope.interface import implements
from zope.server.buffers import OverflowableBuffer
from zope.server.fixedstreamreceiver import FixedStreamReceiver
from zope.server.http.chunking import ChunkedReceiver
from zope.server.interfaces import IStreamConsumer

from httpy.Response import Response

# Precompile a regular expression.
# ================================

HTTP_VERSION = re.compile(r'^HTTP/(\d+)\.(\d+)$')

class PartialInput(Exception):
    pass

class Request:
    """An HTTP Request message.

        http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html

     A Request instance has the following public attributes:

        attribute           description or example
        =======================================================================
        raw                 the raw Request as found on the wire
        raw_line            the raw Request-Line
        raw_message         the raw message
        raw_headers         the raw message headers
        raw_body            the raw message body

        method              'GET'
        uri                 a dictionary per urlparse.urlsplit
        version_string      'HTTP/1.1'

        path                '/index.html'
        querystring         'foo=bar'
        version             (1, 1)
        message             the message as an instance of email.Message.Message


     It also exposes the following IStreamConsumer boilerplate:

        complete
        empty
        received

    """

    implements(IStreamConsumer)


    def __init__(self, adj):
        """Takes an Adjustments object.
        """
        self.adj = adj
        self.completed = False
        self.empty = False
        
        self._tmp = ''
        self.raw=[]
        self.raw_line=None
        self.raw_headers=None
        self.raw_body=None
        
    def __str__(self):
        if not self.completed:
            return "<Incomplete HTTP Request>"
        else:
            return os.linesep.join([
                  'Request for %s' % self.path
                , self.raw
                 ])
        
    def recieved(self,block):
        """This takes a block of an incoming HTTP stream.

        We store anything leftover from the last block in raw string form on
        self._tmp.

        """
        self.raw.append(block)
        if not self.raw_line:
            self.get_line(block)
        elif not self.raw_headers:
            self.get_headers(block)
        elif not self.raw_body:
            self.get_body(block)
        return len(block)
            
    def get_line(self,block):
        block = self._tmp+block
        if '\r' in block or '\n' in block:
            lines = block.splitlines(True)
            i=0
            for line in lines:
                if not line.strip(): #could be a blank line (like from IE)
                    pass
                elif (line.endswith('\r') or
                      line.endswith('\n')): #could be the whole thing
                    self.raw_line = line.strip()
                    self._tmp=''.join(lines[i+1:])
                    break
                else: #or else it is a partial line
                    self._tmp=''.join(lines[i:])
                    break
                i+=1
        else:
            self._tmp=block
        if self.raw_line:
            self.parse_line()
            if self._tmp:
                self.get_headers('')
                
    def parse_line(self):
        # Tokenize the first line as a Request-Line.
        # ==========================================
        raw_line=self.raw_line
        line = raw_line.rstrip('/n').rstrip('/r')
        tokens = line.split()
        if len(tokens) == 3:
            method, uri, version_string = tokens
        elif len(tokens) == 2:
            method, uri = tokens
            version_string = 'HTTP/0.9'
        else:
            response = Response(400)
            response.body = ("The Request-Line `%s' appears to be " % line +
                             "malformed because it has neither two nor " +
                             "three tokens.")
            raise response


        # Validate the method.
        # ====================

        if method not in ('GET', 'HEAD', 'POST'):
            response = Response(501)
            response.body = ("This server does not implement the " +
                             "`%s' method." % method)
            raise response


        # Parse the URI into a dictionary.
        # ================================
        # We use the urlparse naming convention for uri's keys.

        uri = urlparse.urlparse(uri)
        keys = ( 'scheme'
               , 'netloc'
               , 'path'
               , 'parameters'
               , 'query'
               , 'fragment'
                )
        _uri = {}
        for i in range(len(uri)):
            k = keys[i]
            v = uri[i]
            _uri[k] = v
        uri = _uri


        # Validate and possibly unencode the path.
        # ========================================

        if not uri['path']:
            # this catches, e.g., '//foo'
            raise Response(400)
        if '%' in uri['path']:
            uri['path'] = urllib.unquote(uri['path'])


        # Validate the version.
        # =====================
        # Consider raising an HTTPVersionNotSupported here ... for 0.9? 2.0?

        m = HTTP_VERSION.match(version_string)
        if not m:
            response = Response(400)
            response.body = ("The HTTP-Version `%s' appears to " % version +
                             "be malformed because it does not match the " +
                             "pattern `^HTTP/\d+\.\d+$'.")
            raise response

        version = tuple([int(i) for i in m.groups()])


        # Store the most important info on self.
        # ======================================

        # raw
        self.raw_line = raw_line

        # tokens
        self.method = method
        #self.uri = uri
        #self.version_string = version_string

        # derivatives
        self.path = uri['path']
        self.querystring = uri['query']
        #self.version = version

    def get_headers(self,block):
        block = self._tmp+block
        found_splitter=False
        for newline in ['\r\n','\n','\r']:
            if newline*2 in block:
                self.raw_headers,self._tmp = block.split(newline*2,1)
                self.raw_headers = self.raw_headers.strip()
                found_splitter=True
        if not found_splitter:
            self._tmp=block
        if self.raw_headers:
            self.parse_headers()
            if self._tmp:
                self.get_body('')

    def parse_headers(self):
        # Parse the block into a Message + leftovers.
        # ==========================================
        message = message_from_string(self.raw_headers)
        
        # Decide which receiver to use for the body.
        # ==========================================

        content_length = int(message.get('Content-Length', 0))
        transfer_encoding = message.get('Transfer-Encoding', '').lower()

        if not content_length and not transfer_encoding:
            self._receiver = None

        elif content_length and not transfer_encoding:
            buffer_ = OverflowableBuffer(self.adj.inbuf_overflow)
            self._receiver = FixedStreamReceiver(content_length, buffer_)

        elif transfer_encoding == 'chunked':
            buffer_ = OverflowableBuffer(self.adj.inbuf_overflow)
            self._receiver = ChunkedReceiver(buffer_)

        else:
            self._receiver = None

        self.message = message


    def get_body(self,block):
        """Given a block from an HTTP stream, build a message body.

        We guarantee that the entire block is part of an HTTP request message.

        """

        # Get out of here quick if we can.
        # ================================

        if not self._receiver:
            self.raw_body = ''
            self.completed = True
            return

        # Get all of the message body in one block.
        # =========================================

        if self._tmp:
            block = self._tmp + block
            self._tmp = ''
        if not self._receiver.completed:
            self._receiver.received(block)
            if not self._receiver.completed:
                return # I'll be back!
        
        raw_body = self._receiver.getfile().read()


        # Toss the body away if the requested method doesn't allow for it.
        # ================================================================
        # I read RFC 2616, Section 4.3 to call for this behavior rather than,
        # e.g., returning a 400. I suppose the concern is that the input stream
        # be properly positioned.

        if self.method not in ('POST', 'PUT'):
            raw_body == None


        # Update self.message with the body.
        # ==================================
        # This accounts for both single and multipart messages.

        boundary = self.message.get_boundary()
        if not boundary:
            self.message.set_payload(raw_body)
        else:
            self.message.set_payload(None)
            parts = raw_body.split(boundary)
            for part in parts:
                self.message.attach(part)


        # Store on self.
        # ==============

        self.raw_body = raw_body
        self.completed = True



"""
    TODO
    
    *safely* unescape uri -- http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
    character sets
    unit tests
    
    =====DONE=====
    parse multipart --> app
    handle chunked transfer encodings
    

"""
