import os
import re
import urllib
import urlparse
from email import message_from_string

from zope.interface import implements
from zope.server.adjustments import default_adj
from zope.server.buffers import OverflowableBuffer
from zope.server.fixedstreamreceiver import FixedStreamReceiver
from zope.server.http.chunking import ChunkedReceiver
from zope.server.interfaces import IStreamConsumer

from httpy.Response import Response


# Set up some support objects.
# ============================

HTTP_VERSION = re.compile(r'^HTTP/(\d+)\.(\d+)$')

class Complete(Exception):
    """Indicates that the Request has been fully received.
    """


# Define our class!
# =================

class Request:
    # This is a container to which we can add only the API that we want to pass
    # along to the Transactions. Otherwise we get a bunch of unwanted methods and
    # zope boilerplate.
    pass





class Request:
    """An HTTP Request message.

        http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html

    This is a very wooden representation of a Request. The only stable API is
    as follows:

        attribute       description or example
        =======================================================================
        raw             the raw Request exactly as it was found on the wire
        raw_line        the Request-Line
        raw_headers     the message headers
        raw_body        the message body

        method          the HTTP method requested
        uri             the full requested URI as a dictionary
        path            the path component of the URI
        message         the HTTP message (i.e., everything but the Request-Line)
                          as an instance of email.Message.Message, or None if
                          there is no message


    The values of line and headers do not include the terminating linebreaks of
    those items. However, raw includes every byte that was received over the
    wire, so they are possible to get. raw also includes any initial blank
    lines.

    """

    implements(IStreamConsumer)

    raw = ''
    raw_line = ''
    raw_headers = ''
    raw_body = ''

    method = ''
    uri = {}
    path = ''
    message = None


    def __init__(self, adj=None):
        """Takes an Adjustments object.
        """

        if adj is None:
            adj = default_adj
        self.adj = adj

        self._receiver = None
        self._tmp = ''
        self._raw = []


    # Fulfill our IStreamConsumer contracts.
    # ======================================

    def received(self, block):
        """This takes a block of an incoming HTTP stream.

        We store anything leftover from the last block in raw string form in
        self._tmp.

        """

        self._raw.append(block)

        try:
            if not self.raw_line:
                self.get_line(block)
            elif not self.raw_headers:
                self.get_headers(block)
            elif not self.raw_body:
                self.get_body(block)

        except Complete:
            self.raw = ''.join(self._raw)
            self.completed = True

        return len(block)

    completed = False

    empty = False


    # Request-Line
    # ============

    def get_line(self, block):
        """
        """

        block = self._tmp + block
        if '\r' in block or '\n' in block:
            lines = block.splitlines(True)
            i = 0
            for line in lines:
                if not line.strip(): #could be a blank line (like from IE)
                    pass
                elif (line.endswith('\r') or
                      line.endswith('\n')): #could be the whole thing
                    self.raw_line = line.strip()
                    self._tmp = ''.join(lines[i+1:])
                    break
                else: #or else it is a partial line
                    self._tmp = ''.join(lines[i:])
                    break
                i+=1
        else:
            self._tmp = block
        if self.raw_line:
            self.parse_line()

            # Decide if we have any headers.
            line_ending = lines[0][len(self.raw_line):]
            if self._tmp == line_ending:
                self._raw.append(self._tmp)
                raise Complete

            if self._tmp:
                self.get_headers('')


    def parse_line(self):
        """Parse and validate the Request-Line.
        """

        # Tokenize the first line as a Request-Line.
        # ==========================================

        tokens = self.raw_line.strip().split()
        if len(tokens) == 3:
            method, uri, version = tokens
        elif len(tokens) == 2:
            method, uri = tokens
            version = 'HTTP/0.9'
        else:
            response = Response(400)
            response.body = ("The Request-Line `%s' appears to be " % self.raw_line +
                             "malformed because it has neither two nor " +
                             "three tokens.")
            raise response


        # Validate the method.
        # ====================

        if method not in ('GET', 'HEAD', 'POST'):
            response = Response(501)
            response.body = ("This server does not implement the " +
                             "'%s' method." % method)
            raise response


        # Validate the URI.
        # =================
        # We build a mapping using the urlparse naming convention for the keys.
        # Then we do a little validation and cleanup.

        uri = urlparse.urlparse(uri)
        keys = ( 'scheme'
               , 'netloc'
               , 'path'
               , 'parameters'
               , 'query'
               , 'fragment'
                )
        _uri = {}
        for i in range(len(uri)):
            k = keys[i]
            v = uri[i]
            _uri[k] = v
        uri = _uri


        if not uri['path']:
            # this catches, e.g., '//foo'
            raise Response(400)
        if '%' in uri['path']:
            uri['path'] = urllib.unquote(uri['path'])


        # Validate the version.
        # =====================
        # Consider raising Response(505) here ... for 0.9? 2.0?

        m = HTTP_VERSION.match(version)
        if not m:
            response = Response(400)
            response.body = ("The HTTP-Version `%s' appears to " % version +
                             "be malformed because it does not match the " +
                             "pattern `^HTTP/\d+\.\d+$'.")
            raise response


        # Save a few absolutely basic things for application use.
        # =======================================================

        self.method = method
        self.uri = uri
        self.path = uri['path']


    # Headers
    # =======

    def get_headers(self, block):
        """
        """

        block = self._tmp + block
        found_splitter = False
        for newline in ('\r\n', '\n', '\r'):
            if newline*2 in block:
                self.raw_headers, self._tmp = block.split(newline*2, 1)
                self.raw_headers = self.raw_headers.strip()
                found_splitter = True
        if not found_splitter:
            self._tmp = block
        if self.raw_headers:
            self.get_body('')


    # Body
    # ====

    def set_receiver(self):
        """Once the headers have been read, decide how to read the body.

        We use the standard library's email package to parse the headers. The
        receiver is stored on self so it persists across calls to our own
        self.received, since it actually holds data between such calls. Later on
        we will add the request body to self.message.

        """

        message = message_from_string(self.raw_headers)
        content_length = int(message.get('Content-Length', 0))
        transfer_encoding = message.get('Transfer-Encoding', '').lower()

        if not content_length and not transfer_encoding:
            self._receiver = None

        elif content_length and not transfer_encoding:
            buffer_ = OverflowableBuffer(self.adj.inbuf_overflow)
            self._receiver = FixedStreamReceiver(content_length, buffer_)

        elif transfer_encoding == 'chunked':
            buffer_ = OverflowableBuffer(self.adj.inbuf_overflow)
            self._receiver = ChunkedReceiver(buffer_)

        else:
            self._receiver = None

        self.message = message


    def get_body(self, block):
        """Given a block from an HTTP stream, build a message body.

        We guarantee that the entire block is part of an HTTP request message.

        """

        # Decide which receiver to use.
        # =============================
        # If we don't have a receiver, it means there is no body.

        if self._receiver is None:
            self.set_receiver()
        if self._receiver is None:
            self.raw_body = ''
            raise Complete


        # Get all of the message body in one block.
        # =========================================

        if self._tmp:
            block = self._tmp + block
            self._tmp = ''
        if not self._receiver.completed:
            self._receiver.received(block)
            if not self._receiver.completed:
                return # I'll be back!


        # Store on self and get out of here.
        # ==================================
        # We toss the body away if the requested method doesn't allow for it. I
        # read RFC 2616, Section 4.3 to call for this behavior rather than,
        # e.g., returning a 400. I suppose the concern is that the input stream
        # be properly positioned for multi-request connections.

        if self.method == 'POST': # If we supported PUT it would go here.
            self.raw_body = self._receiver.getfile().read()
        else:
            self.raw_body = ''

        self.parse_body()

        raise Complete



    def parse_body(self):
        """Update self.message with the request body.

        This accounts for both single and multipart messages.

        """

        boundary = self.message.get_boundary()
        if not boundary:
            self.message.set_payload(self.raw_body)
        else:
            self.message.set_payload(None)
            parts = self.raw_body.split(boundary)
            for part in parts:
                self.message.attach(part)





"""
TODO

*safely* unescape uri -- http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
character sets

=====DONE=====
parse multipart --> app
handle chunked transfer encodings
unit tests

"""
