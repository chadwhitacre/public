import cgi
import os
import re
import urllib
import urlparse
from email.FeedParser import FeedParser

from zope.interface import implements
from zope.server.buffers import OverflowableBuffer
from zope.server.fixedstreamreceiver import FixedStreamReceiver
from zope.server.http.chunking import ChunkedReceiver
from zope.server.interfaces import IStreamConsumer

from httpy.Response import Response


# Precompile a regular expression.
# ================================

HTTP_VERSION = re.compile(r'^HTTP/(\d+)\.(\d+)$')


class PartialInput(Exception):
    pass


class Request:
    """An HTTP Request message.

        http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html

    A Request instance has the following public attributes:

        attribute           description or example
        =======================================================================
        raw                 the raw Request as found on the wire
        raw_line            the raw Request-Line
        raw_message         the raw message
        raw_headers         the raw message headers
        raw_body            the raw message body

        method              'GET'
        uri                 a dictionary per urlparse.urlsplit
        version_string      'HTTP/1.1'

        path                '/index.html'
        querystring         'foo=bar'
        version             (1, 1)
        message             the message as an instance of email.Message.Message


    It also exposes the following IStreamConsumer boilerplate:

        complete
        empty
        received

    """

    implements(IStreamConsumer)


    def __init__(self, adj):
        """Takes an Adjustments object.
        """
        self.adj = adj
        self.completed = False
        self.empty = False
        self._need_line = self._need_headers = self._need_body = True
        self._tmp = ''


    def __str__(self):
        if not self.completed:
            return "<Incomplete HTTP Request>"
        else:
            return os.linesep.join([
                  'Request for %s' % self.path
                , self.raw
                 ])


    def received(self, block):
        """This takes a block of an incoming HTTP stream.

        We store anything leftover from the last block in raw string form on
        self._tmp.

        """

        try:
            if self._need_line:
                self._read_line(block)

            if not self._need_line and self._need_headers:
                self._read_headers(block)

            if not self._need_line and not self._need_headers and self._need_body:
                self._read_body(block)

            if not self._need_body:
                self.raw = ''.join(( self.raw_line
                                   , self.raw_headers
                                   , self.raw_body
                                    ))
                self.completed = True

        except PartialInput:
            pass

        return len(block)


    def _read_line(self):
        """Given a block of an HTTP stream, look for a Request-Line.

        The Request-Line is resolved into method, uri, and version, which are
        validated. Some helpful values are derived from these tokens, and all
        this information is stored on self. Any data in the block that isn't
        part of the Request-Line is stored in self._tmp for usage by the next
        method.

        """

        # Get the entire Request-Line in one block.
        # =========================================

        if self._tmp:
            _block = self._tmp + self.block
            self._tmp = ''
        if '\r\n' not in self.block:
            self._tmp = self.block
            raise PartialInput # I'll be back!


        # Siphon off the first line.
        # ==========================

        lines = block.splitlines(True)
        raw_line = lines.pop(0)
        while raw_line in ('\r\n', '\r', '\n'):
            # Skip initial blank lines to account for IE's buggy POST
            # implementation.
            raw_line = lines.pop(0)


        # Tokenize the first line as a Request-Line.
        # ==========================================

        line = raw_line.rstrip('/n').rstrip('/r')
        tokens = line.split()
        if len(tokens) == 3:
            method, uri, version_string = tokens
        elif len(tokens) == 2:
            method, uri = tokens
            version_string = 'HTTP/0.9'
        else:
            response = Response(400)
            response.body = ("The Request-Line `%s' appears to be " % line +
                             "malformed because it has neither two nor " +
                             "three tokens.")
            raise response


        # Validate the method.
        # ====================

        if method not in ('GET', 'HEAD', 'POST'):
            response = Response(501)
            response.body = ("This server does not implement the " +
                             "`%s' method." % method)
            raise response


        # Parse the URI into a dictionary.
        # ================================
        # We use the urlparse naming convention for uri's keys.

        uri = urlparse.urlsplit(uri)
        keys = ( 'scheme'
               , 'netloc'
               , 'path'
               , 'query'
               , 'fragment'
                )
        _uri = {}
        for i in range(len(uri)):
            k = keys[i]
            v = uri[i]
            _uri[k] = v
        uri = _uri


        # Validate and possibly unencode the path.
        # ========================================

        if not uri['path']:
            # this catches, e.g., '//foo'
            raise Response(400)
        if '%' in uri['path']:
            uri['path'] = urllib.unquote(uri['path'])


        # Validate the version.
        # =====================
        # Consider raising an HTTPVersionNotSupported here ... for 0.9? 2.0?

        m = HTTP_VERSION.match(version_string)
        if not m:
            response = Response(400)
            response.body = ("The HTTP-Version `%s' appears to " % version +
                             "be malformed because it does not match the " +
                             "pattern `^HTTP/\d+\.\d+$'.")
            raise response

        version = tuple([int(i) for i in m.groups()])


        # Store the most important info on self.
        # ======================================

        # raw
        self.raw_line = raw_line

        # tokens
        self.method = method
        self.uri = uri
        self.version_string = version_string

        # derivatives
        self.path = uri['path']
        self.querystring = uri['query']
        self.version = version

        # state
        self._tmp = ''.join(lines)
        self._need_line = False


    def _read_headers(self):
        """Given a block from an HTTP stream, look for message headers.

        The message headers are read and a new Message instance is added to
        self. This instance will be updated in _read_body once the body has been
        read. We have to do this in two stages because the length of the body is
        communicated to us via the headers.

        """

        # Get all of the message headers in one block.
        # ============================================

        if self._tmp:
            block = self._tmp + self.block
            self._tmp = ''
        if '\r\n\r\n' not in block:
            self._tmp = block
            raise PartialInput# I'll be back!


        # Parse the block into a Message + leftovers.
        # ==========================================

        lines = block.splitlines(True)
        _headers = []
        parser_ = FeedParser()
        line = lines.pop(0)
        while line != '\r\n':
            _headers.append(line)
            parser_.feed(line)
            line = lines.pop(0)
        _headers.append(line)
        parser_.feed(line)
        message = parser_.close()


        # Decide which receiver to use for the body.
        # ==========================================

        content_length = int(message.get('Content-Length', 0))
        transfer_encoding = message.get('Transfer-Encoding', '').lower()

        if not content_length and not transfer_encoding:
            self._receiver = None

        elif content_length and not transfer_encoding:
            buffer_ = OverflowableBuffer(self.adj.inbuf_overflow)
            self._receiver = FixedStreamReceiver(content_length, buffer_)

        elif transfer_encoding == 'chunked':
            buffer_ = OverflowableBuffer(self.adj.inbuf_overflow)
            self._receiver = ChunkedReceiver(buffer_)

        else:
            self._receiver = None


        # Now store on self.
        # ==================

        self.raw_headers = ''.join(_headers)
        self.message = message

        self._tmp = ''.join(lines)
        self._need_headers = False


    def _read_body(self):
        """Given a block from an HTTP stream, build a message body.

        We guarantee that the entire block is part of an HTTP request message.

        """


        # Get out of here quick if we can.
        # ================================

        if not self._receiver:
            self._need_body = False
            self.raw_body = ''
            return

        import pdb; pdb.set_trace()

        # Get all of the message body in one block.
        # =========================================

        if self._tmp:
            block = self._tmp + block
            self._tmp = ''
        if not self._receiver.completed:
            self._receiver.received(block)
            return # I'll be back!

        raw_body = self._receiver.getfile().read()


        # Toss the body away if the requested method doesn't allow for it.
        # ================================================================
        # I read RFC 2616, Section 4.3 to call for this behavior rather than,
        # e.g., returning a 400. I suppose the concern is that the input stream
        # be properly positioned.

        if self.method not in ('POST', 'PUT'):
            raw_body == None


        # Update self.message with the body.
        # ==================================
        # This accounts for both single and multipart messages.

        boundary = self.message.get_boundary()
        if not boundary:
            self.message.set_payload(raw_body)
        else:
            self.message.set_payload(None)
            parts = raw_body.split(boundary)
            for part in parts:
                self.message.attach(part)


        # Store on self.
        # ==============

        self.raw_body = raw_body
        self._need_body = False



"""
TODO

*safely* unescape uri -- http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1.2
character sets
unit tests

=====DONE=====
parse multipart --> app
handle chunked transfer encodings


"""
