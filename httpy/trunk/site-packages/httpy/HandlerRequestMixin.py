import imp
import os
import sys

import httpy.app
from httpy import log
from httpy.Request import Request
from httpy.Response import Response
from httpy.RollbackImporter import RollbackImporter


class HandlerRequestMixin:
    """This object contains request-side logic for the Handler class.
    """

    rollbackImporter = None

    def get_transaction(self, config, uri_path):
        """Return an instance of a Transaction appropriate to the request.

        This method takes the server's configuration dictionary, and the
        requested URI-path.

        The following conditions must be met, otherwise we default to
        httpy.app.Transaction:

            - The directory at app_root must have a subdirectory named `__'.
            - There must be a module `app.py', or a package `app', in `__'.
            - The app module/package must have a `Transaction' class.
            - app.Transaction must have a callable named `process'.


        This method started life as the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        # If we are in development mode, refresh all modules.
        # ===================================================

        if config['mode'] == 'development':
            if self.rollbackImporter:
                self.rollbackImporter.uninstall()
            self.rollbackImporter = RollbackImporter()


        # Setup configuration.
        # ====================

        root = config['root']
        apps = config['apps']

        app_root, __  = self.translate(root, apps, uri_path)

        _config = {}
        _config['mode'] = config['mode']
        _config['verbosity'] = config['verbosity']
        _config['root'] = app_root
        _config['__'] = __
        config = _config


        if not __:
            log(95, "No magic directory found in %s. Falling " % app_root +
                    "back to httpy.app")
            app = httpy.app
        else:
            log(98, "Found magic directory at %s; will look for app." % __)
            app = None


        if not app:

            # Fast path: see if the module has already been imported.
            try:
                app = sys.modules['app']
            except KeyError:
                pass

            try:
                fp, pathname, description = imp.find_module('app', [__])
                app = imp.load_module('app', fp, pathname, description)
            except ImportError:
                log(95, "Unable to import app from %s. " % __ +
                        "Falling back to httpy.app.")
                app = httpy.app

            if not hasattr(app, 'Transaction'):
                log(91, "Unable to import Transaction from app at " +
                        "%s. Falling back to httpy.app." % __)
                app = httpy.app

            if not hasattr(app.Transaction, 'process'):
                log(91, "The app.Transaction in %s does not have " % __ +
                        "a `process' method. Falling back to httpy.app.")
                app = httpy.app

            if not callable(app.Transaction.process):
                log(91, "app.Transaction.process from %s is not " % __ +
                        "callable. Falling back to httpy.app.")
                app = httpy.app


        # Return an instance of the transaction.
        # ======================================

        log(98, "Found a transaction to use: %s." % str(app.Transaction))
        return app.Transaction(config)


    def translate(self, root, apps, path):
        """Map the requested path to the filesystem.

        This method takes a website's filesystem-root, a list of application
        URI-roots, and the requested URI-path. It returns the filesystem-root of
        the application to be used for this request, and the filesystem-path of
        the application's magic directory, or None if the application does not
        have a magic directory.

        """

        # Find an application directory that matches the requested URI-path.
        # ==================================================================
        # The website root is always an implicit application. The first-named
        # app will match first.

        app = '/'
        for _app in apps:
            if path.startswith(_app):
                app = _app
                break
        app_root = os.path.realpath(os.path.join(root, app.lstrip('/')))
        path = os.path.realpath(os.path.join(app_root, path.lstrip('/')))

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(403)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            __ = None
        if __ and path.startswith(__):
            raise Response(404)


        return (app_root, __)
