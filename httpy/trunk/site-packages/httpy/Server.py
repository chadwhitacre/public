import asyncore
import inspect
import logging
import os
import popen2
import signal
import socket
import sys
import time
import traceback

from httpy._zope.server.adjustments import default_adj
from httpy._zope.server.serverbase import ServerBase
from httpy._zope.server.taskthreads import ThreadedTaskDispatcher
from httpy.Channel import Channel


# Logging
# =======
logger = logging.getLogger('httpy.Server')


STOP_SIGNALS = {
    signal.SIGINT  : 'SIGINT'
  , signal.SIGTERM : 'SIGTERM'
                }

class Server(ServerBase):
    """An httpy server.

    Instantiate with a Config object, and start it with start().

    """

    # ServerBase boilerplate
    channel_class = Channel
    SERVER_IDENT = 'httpy'


    http_version = (1, 0)
    http_version_string = "HTTP/1.0"
    response_header = "httpy/0.5"


    def __init__(self, config, threads=10):
        """Takes an httpy.Config object.

        The thread count should probably be exposed to configuration, but I
        still want to hold out the possibility of swapping out a different base
        server, which may change the meaning of that parameter.

        """

        # Install some basic API.
        # =======================

        self.config = config
        mode = os.environ.get('HTTPY_MODE', 'deployment')
        self.debug_mode  = mode == 'debugging'
        self.deploy_mode = mode == 'deployment'
        self.devel_mode  = mode == 'development'


        # Set up signal handling so we can shut down cleanly.
        # ===================================================

        for sig in STOP_SIGNALS:
            signal.signal(sig, self.stop)


        # Satisfy ServerBase requirements.
        # ================================

        asyncore.dispatcher.__init__(self)
        self.adj = default_adj
        if self.config.sockfam == socket.AF_UNIX:
            # The default adjustment doesn't apply here, and triggers an error.
            self.adj.socket_options = []
        self.verbose = False
        task_dispatcher = ThreadedTaskDispatcher()
        task_dispatcher.setThreadCount(threads)
        self.task_dispatcher = task_dispatcher
        self.logger = logger


        # Bind to an address.
        # ===================

        self.create_socket(config.sockfam, socket.SOCK_STREAM)
        self.set_reuse_addr()
        if config.sockfam == socket.AF_UNIX:
            if os.path.exists(config.address):
                os.unlink(config.address)
                logger.debug("unlinking stale socket")

        timeout = time.time() + 10
        while 1:
            if time.time() < timeout:
                try:
                    self.bind(config.address)
                    break
                except socket.error, err:
                    time.sleep(0.5)
            else:
                raise err


    def start(self):
        """
        """
        self.accept_connections()
        if self.config.sockfam == socket.AF_INET:
            addr, port = self.socket.getsockname()
            logger.info("httpy started on port %s" % port)
        elif self.config.sockfam == socket.AF_UNIX:
            logger.info("httpy started on %s" % self.config.address)
        asyncore.loop(timeout=5)


    def stop(self, signum=None, frame=None):
        """
        """
        if signum is not None:
            logger.debug("caught %s" % STOP_SIGNALS[signum])
        logger.info("shutting down...")

        for app in self.config.apps:
            if hasattr(app, 'close') and inspect.ismethod(app.close):
                logger.debug("closing %s" % app)
                app.close()
            else:
                logger.debug("%s provides no close hook" % app)

        self.task_dispatcher.shutdown()
        asyncore.close_all()

        if self.config.sockfam == socket.AF_UNIX:
            if not os.path.exists(self.config.address):
                logger.debug("what happened to our socket?")
            os.unlink(self.config.address)

        logger.info("httpy stopped")



class Restart(StandardError):
    """Triggers a restart of the child server process.
    """


class RestartingServer:
    """Instantiate with a Config object, and start it with start().

    This server runs the *real* server in a separate process, restarting it
    whenever modules change on the filesystem. There are actually a number of
    ways to skin this deceptively simple cat. Here's what I've tried:

        Refresh modules directly from within the python process.
        --------------------------------------------------------

        The basic trick is to delete items from sys.modules, forcing a refresh
        the next time they are loaded. However, because modules import from one
        another, you need to make sure you reload enough of them to make it
        worth it. I got pretty far down this road (the place to start is to
        google for RollbackImporter), but at a couple points I started seeing
        very elusive segfaults. My best guess is that I was hitting a bug in
        Python, but I never narrowed it down enough to file it. :-(


        Run the python process within a wrapper that knows how to restart it.
        ---------------------------------------------------------------------

        Since you need to refresh almost all of your modules anyway, it makes a
        lot of sense to deal with the problem at the macro level. I got this
        idea from Ian Bicking via CherryPy. Thanks, guys. :-) Their version of
        this solution is to spawn a process and block for it, and then monitor
        the state of the modules on the filesystem in a separate thread. They
        use the blocked process's exit code to trigger reloading.


        Run within a wrapper but monitor within the process.
        ----------------------------------------------------

        I think it should also work to push the monitoring functionality down
        into the application, but I wasn't able to successfully exit zope.server
        from inside it, because I don't understand threading well enough.


        Run in a non-blocking process, monitor within the main process.
        ---------------------------------------------------------------

        The solution I've settled on here is to start the main server in a
        separate process, but not to block for it. I then monitor the filesystem
        in the main process/thread, and manipulate the worker process via its
        process ID. This solution, therefore, is not Windows-compatible. But,
        boy, is it simpler. :-)  See also: my above comment on me vs. threading.


    """

    def __init__(self, config):
        self.config = config
        self.mtimes = {}
        self.pid = -1
        for sig in STOP_SIGNALS:
           signal.signal(sig, self.stop)


    def start(self, args=None):
        logger.info("starting child server ...")
        if args is None:
            args = [sys.executable] + sys.argv
        new_env = os.environ.copy()
        new_env['HTTPY_PLAIN_JANE'] = 'So plain.'
        while 1:
            try:
                try:
                    self.pid = os.spawnve( os.P_NOWAIT
                                         , sys.executable
                                         , args
                                         , new_env
                                          )
                    while 1:
                        self.look_for_changes()
                        time.sleep(1)
                finally:
                    self.stop_child()
            except SystemExit:
                sys.stdout.flush()
                #time.sleep(0.5) # Give stdout a chance to flush.
                raise
            except Restart:
                logger.info("restarting child server ...")
            except:
                logger.error("exception while spawning child ...\n" +
                             traceback.format_exc())


    def stop_child(self):
        """Stop the child server process.
        """
        try:
            os.kill(self.pid, signal.SIGTERM)
        except OSError:
            logger.warning("OSError killing pid %d" % self.pid)
            logger.warning(traceback.format_exc())


        if 0: # this is for debugging the restart-while-debugging bug

            print "isatty: %s %s %s" % tuple([x.isatty() for x in ( sys.stdin
                                                                  , sys.stdout
                                                                  , sys.stderr
                                                                  )])

            while 0:
                msg = os.read(0, 8192)
                if msg == 'quit\n':
                    break
                os.write(1, msg)

            #stdin = os.open('/dev/stdin', os.O_WRONLY)
            #os.dup2(stdin, 0)
            #stdout = os.open('/dev/stdout', os.O_WRONLY)
            #os.dup2(stdout, 1)
            #stderr = os.open('/dev/stderr', os.O_WRONLY)
            #os.dup2(stderr, 2)


    def stop(self, signum=-1, frame=None):
        """Stop the child process, then exit ourselves.
        """
        self.stop_child()
        if signum is not None:
            logger.debug("parent caught %s" % STOP_SIGNALS[signum])
        logger.debug("parent shutting down...")
        raise SystemExit


    def look_for_changes(self):
        """See if any of our available modules have changed on the filesystem.
        """

        for module in sys.modules.values():

            # Get out early if we can.
            # ========================

            filename = getattr(module, '__file__', None)
            if filename is None:
                continue
            if filename.endswith(".pyc"):
                filename = filename[:-1]


            # The file may have been removed from the filesystem.
            # ===================================================

            if not os.path.isfile(filename):
                logger.debug("missing: %s" % filename)
                if filename in self.mtimes:
                    del self.mtimes[filename]
                raise Restart


            # Or not.
            # =======

            mtime = os.stat(filename).st_mtime
            if filename not in self.mtimes:
                self.mtimes[filename] = mtime
                continue
            if mtime > self.mtimes[filename]:
                logger.debug("outdated: %s" % filename)
                self.mtimes[filename] = mtime
                raise Restart
