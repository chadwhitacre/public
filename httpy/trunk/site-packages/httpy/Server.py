import asyncore
import inspect
import os
import popen2
import signal
import sys
import time
import traceback

from httpy._zope.server.serverbase import ServerBase
from httpy._zope.server.taskthreads import ThreadedTaskDispatcher

from httpy.Channel import Channel
from httpy.utils import log

STOP_SIGNALS = {
    signal.SIGINT  : 'SIGINT'
  , signal.SIGTERM : 'SIGTERM'
                }



class Server(ServerBase):
    """An httpy server.

    Instantiate with a Config object, and start it with start().

    """

    # ServerBase boilerplate
    channel_class = Channel
    SERVER_IDENT = 'httpy'


    http_version = (1, 0)
    http_version_string = "HTTP/1.0"
    response_header = "httpy/0.5"


    def __init__(self, config, threads=10):
        """Takes an httpy.Config object.

        The thread count should probably be exposed to configuration, but I
        still want to hold out the possibility of swapping out a different base
        server, which may change the meaning of that parameter.

        """

        # Install some basic API.
        # =======================

        self.config = config
        mode = os.environ.get('HTTPY_MODE', 'deployment')
        self.debug_mode  = mode == 'debugging'
        self.deploy_mode = mode == 'deployment'
        self.devel_mode  = mode == 'development'


        # Set up signal handling so we can shut down cleanly.
        # ===================================================

        for sig in STOP_SIGNALS:
            signal.signal(sig, self.stop)



        # Create a task dispatcher.
        # =========================

        td = ThreadedTaskDispatcher()
        td.setThreadCount(threads)
        ServerBase.__init__( self
                           , config.ip
                           , config.port
                           , start=False
                           , task_dispatcher=td
                            )

    def start(self):
        self.accept_connections()
        addr, port = self.socket.getsockname()
        log(1, "httpy started on port %s" % port)
        log(99, "%s\n\n" % ("="*76))
        asyncore.loop(timeout=5)


    def stop(self, signum=None, frame=None):
        if signum is not None:
            log(1, "caught %s" % STOP_SIGNALS[signum])
        log(1, "shutting down...")
        for app in self.config.apps:
            if hasattr(app, 'close') and inspect.ismethod(app.close):
                log(97, "closing %s" % app)
                app.close()
            else:
                log(97, "%s provides no close hook" % app)

        self.task_dispatcher.shutdown()
        asyncore.close_all()
        log(1, "httpy stopped")



class Restart(StandardError):
    """Triggers a restart of the child server process.
    """

class RestartingServer:
    """Instantiate with a Config object, and start it with start().

    This server runs the *real* server in a separate process, restarting it
    whenever modules change on the filesystem. There are actually a number of
    ways to skin this deceptively simple cat. Here's what I've tried:

        Refresh modules directly from within the python process.
        --------------------------------------------------------

        The basic trick is to delete items from sys.modules, forcing a refresh
        the next time they are loaded. However, because modules import from one
        another, you need to make sure you reload enough of them to make it
        worth it. I got pretty far down this road (the place to start is to
        google for RollbackImporter), but at a couple points I started seeing
        very elusive segfaults. My best guess is that I was hitting a bug in
        Python, but I never narrowed it down enough to file it. :-(


        Run the python process within a wrapper that knows how to restart it.
        ---------------------------------------------------------------------

        Since you need to refresh almost all of your modules anyway, it makes a
        lot of sense to deal with the problem at the macro level. I got this
        idea from Ian Bicking via CherryPy. Thanks, guys. :-) Their version of
        this solution is to spawn a process and block for it, and then monitor
        the state of the modules on the filesystem in a separate thread. They
        use the blocked process's exit code to trigger reloading.


        Run within a wrapper but monitor within the process.
        ----------------------------------------------------

        I think it should also work to push the monitoring functionality down
        into the application, but I wasn't able to successfully exit zope.server
        from inside it, because I don't understand threading well enough.


        Run in a non-blocking process, monitor within the main process.
        ---------------------------------------------------------------

        The solution I've settled on here is to start the main server in a
        separate process, but not to block for it. I then monitor the filesystem
        in the main process/thread, and manipulate the worker process via its
        process ID. This solution, therefore, is not Windows-compatible. But,
        boy, is it simpler. :-)  See also: my above comment on me vs. threading.


    I am open to modifying this in a future version to make it Windows-
    compatible.

    """

    def __init__(self, config):
        self.config = config
        self.mtimes = {}
        self.pid = -1
        for sig in STOP_SIGNALS:
            signal.signal(sig, self.stop)


    def start(self, args=None):
        log(1, "starting child server ...")
        if args is None:
            args = [sys.executable] + sys.argv
        new_env = os.environ.copy()
        new_env['HTTPY_PLAIN_JANE'] = 'So plain.'
        while 1:
            try:
                try:
                    self.pid = os.spawnve( os.P_NOWAIT
                                         , sys.executable
                                         , args
                                         , new_env
                                          )
                    while 1:
                        self.look_for_changes()
                        time.sleep(1)
                finally:
                    self.stop_child()
            except SystemExit:
                time.sleep(0.5) # Give stdout a chance to flush.
                raise
            except Restart:
                log(90, "Restarting child server ...")
            except:
                log(90, "Exception while spawning child ...\n" +
                        traceback.format_exc())


    def stop_child(self):
        """Stop the child server process.
        """
        try:
            os.kill(self.pid, signal.SIGTERM)
        except OSError:
            log(90, "OSError killing pid %d" % self.pid)
            log(99, traceback.format_exc())


        if 0: # this is for debugging the restart-while-debugging bug

            print "isatty: %s %s %s" % tuple([x.isatty() for x in ( sys.stdin
                                                                  , sys.stdout
                                                                  , sys.stderr
                                                                   )])

            while 0:
                msg = os.read(0, 8192)
                if msg == 'quit\n':
                    break
                os.write(1, msg)

            #stdin = os.open('/dev/stdin', os.O_WRONLY)
            #os.dup2(stdin, 0)
            #stdout = os.open('/dev/stdout', os.O_WRONLY)
            #os.dup2(stdout, 1)
            #stderr = os.open('/dev/stderr', os.O_WRONLY)
            #os.dup2(stderr, 2)


    def stop(self, signum=-1, frame=None):
        """Stop the child process, then exit ourselves.
        """
        self.stop_child()
        if signum is not None:
            log(1, "parent caught %s" % STOP_SIGNALS[signum])
        log(1, "parent shutting down...")
        raise SystemExit


    def look_for_changes(self):
        """See if any of our available modules have changed on the filesystem.
        """

        for module in sys.modules.values():

            # Get out early if we can.
            # ========================

            filename = getattr(module, '__file__', None)
            if filename is None:
                continue
            if filename.endswith(".pyc"):
                filename = filename[:-1]


            # The file may have been removed from the filesystem.
            # ===================================================

            if not os.path.isfile(filename):
                print >> sys.stderr, "File is missing: %s" % filename
                if filename in self.mtimes:
                    del self.mtimes[filename]
                raise Restart


            # Or not.
            # =======

            mtime = os.stat(filename).st_mtime
            if filename not in self.mtimes:
                self.mtimes[filename] = mtime
                continue
            if mtime > self.mtimes[filename]:
                print >> sys.stderr, "File is outdated: %s" % filename
                self.mtimes[filename] = mtime
                raise Restart
