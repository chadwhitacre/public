"""This module provides the classes that define our server.

There are three classes here:

    Loader -- a mixin that provides framework and application loading

    Server -- the main server class

    RestartingServer -- used for development; restarts a child server whenever
                        changes are made to your framework or applications

"""

import asyncore
import imp
import inspect
import logging
import os
import popen2
import signal
import socket
import subprocess
import sys
import time
import traceback

from httpy import DefaultFramework
from httpy._zope.interface.verify import verifyClass, verifyObject
from httpy._zope.server.adjustments import default_adj
from httpy._zope.server.serverbase import ServerBase
from httpy._zope.server.taskthreads import ThreadedTaskDispatcher
from httpy.Channel import Channel
from httpy.DefaultApp import DefaultApplication
from httpy.interfaces import IApp, IApplication, IFramework



# Logging and signal handling
# ===========================

logger = logging.getLogger('httpy.Server')

STOP_SIGNALS = {
    signal.SIGINT  : 'SIGINT'
  , signal.SIGTERM : 'SIGTERM'
                }


class Loader:
    """This mixin provides API for loading framework and apps.

    This is factored out because both other classes need to load the framework
    and apps -- Server in order to use them, RestartingServer in order to
    monitor them for changes.

    """

    def get_framework(self):
        """Return an instance of the site's framework.

        We are looking for a module defined in __/framework.py.

        """

        if self.config.__:
            framework_file = os.path.join(self.config.__, 'framework.py')
            if os.path.exists(framework_file):
                logger.debug("Loading framework from %s" % self.config.__)
                fp, pathname, description = imp.find_module( 'framework'
                                                           , [self.config.__]
                                                            )
                framework = imp.load_module( 'framework'
                                           , fp
                                           , pathname
                                           , description
                                            )
        else:
            logger.warning("No framework found, using default.")
            framework = DefaultFramework


        # Validate the framework.
        # =======================
        # We use zope interfaces, although your framework needn't implement
        # zope interfaces explicitly.

        try:
            verifyObject(IFramework, framework, tentative=True)
        except:
            logger.debug("framework in %s is not valid." % self.config.__)
            raise


        # Add API and return.
        # ===================

        framework.__ = self.config.__
        framework.site_root = self.config.root
        framework.debug_mode = self.debug_mode
        framework.devel_mode = self.devel_mode
        framework.deploy_mode = self.deploy_mode

        return framework



    def get_apps(self):
        """Return a sequence of app instances.

        Any properly-formed app.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no app.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no app.py
        is found there, then we fall back to DefaultApplication.

        """

        # Walk the tree rooted in site_root and load apps.
        # ================================================

        apps = []
        need_default = True
        for path, dirs, files in os.walk(self.config.root):
            if '.svn' in dirs:
                dirs.remove('.svn')
            if '__' in dirs:
                dirs.remove('__')
            dirs = sorted(dirs)
            if 'app.py' in files:
                apps.append(self._load_app(path))
                if path == self.config.root:
                    need_default = False
        apps.reverse()


        # If we didn't find an app in site_root, look in __.
        # ==================================================

        if need_default:
            if self.config.__:
                if 'app.py' in os.listdir(self.config.__):
                    apps.append(self._load_app(self.config.__))
                    need_default = False


        # If we didn't find an app in __ either, use DefaultApplication.
        # ==============================================================

        if need_default:
            apps.append(self._instantiate_Application( self.config.root
                                                     , DefaultApplication
                                                      ))

        return apps


    def _load_app(self, app_fs_root):
        """Given an app's fs root, return an instance of the application.

        Each app is imported under the app_fs_root so that they don't collide in
        sys.modules.

        """

        logger.debug("Loading app from %s" % app_fs_root)
        try:
            fp, pathname, description = imp.find_module('app', [app_fs_root])
            app = imp.load_module(app_fs_root, fp, pathname, description)
        except ImportError:
            raise ImportError("Unable to import app from " +
                              "%s: \n%s" % ( app_fs_root
                                           , traceback.format_exc()
                                            ))

        # Validate the app.
        # =================
        # We use zope interfaces, although your app needn't implement zope
        # interfaces explicitly.

        try:
            verifyObject(IApp, app, tentative=True)
        except:
            logger.debug("app in %s is not valid." % app_fs_root)
            raise
        try:
            verifyClass(IApplication, app.Application, tentative=True)
        except:
            logger.debug("app.Application in %s is not valid." % app_fs_root)
            raise

        return self._instantiate_Application(app_fs_root, app.Application)


    def _instantiate_Application(self, app_fs_root, Application):
        """Given a path and an Application class, return an instance.

        This is factored out because we want to add some runtime API before
        instantiating, and we want to instantiate in a couple places.

        """

        # Paths
        # =====

        if app_fs_root == self.config.__:
            app_uri_root = '/'
            app_fs_root = self.config.root
        else:
            app_uri_root = app_fs_root[len(self.config.root):]
            app_uri_root = app_uri_root.replace(os.sep, '/')
            if not app_uri_root:
                app_uri_root = '/'

        Application.site_root = self.config.root
        Application.uri_root = app_uri_root
        Application.fs_root = app_fs_root
        Application.__ = self.config.__


        # Mode
        # ====

        Application.debug_mode = self.debug_mode
        Application.deploy_mode = self.deploy_mode
        Application.devel_mode = self.devel_mode

        return Application()



class Server(ServerBase, Loader):
    """An httpy server.

    Instantiate with a Config object, and start it with start().

    """

    # ServerBase boilerplate
    channel_class = Channel
    SERVER_IDENT = 'httpy'


    http_version = (1, 0)
    http_version_string = "HTTP/1.0"
    response_header = "httpy/0.7"


    def __init__(self, config):
        """Takes an httpy.Config object.
        """

        # Install some basic API.
        # =======================

        self.config = config

        self.debug_mode  = self.config.mode == 'debugging'
        self.deploy_mode = self.config.mode == 'deployment'
        self.devel_mode  = self.config.mode == 'development'

        self.framework = self.get_framework()
        self.apps = self.get_apps()


        # Set up signal handling so we can shut down cleanly.
        # ===================================================

        for sig in STOP_SIGNALS:
            signal.signal(sig, self.stop)


        # Satisfy ServerBase requirements.
        # ================================

        asyncore.dispatcher.__init__(self)
        self.adj = default_adj
        if self.config.sockfam == socket.AF_UNIX:
            # The default adjustment doesn't apply here, and triggers an error.
            self.adj.socket_options = []
        self.verbose = False
        task_dispatcher = ThreadedTaskDispatcher()
        task_dispatcher.setThreadCount(self.config.threads)
        self.task_dispatcher = task_dispatcher
        self.logger = logger


        # Bind to an address.
        # ===================

        self.create_socket(config.sockfam, socket.SOCK_STREAM)
        self.set_reuse_addr()
        if config.sockfam == socket.AF_UNIX:
            if os.path.exists(config.address):
                os.unlink(config.address)
                logger.debug("unlinking stale socket")

        timeout = time.time() + 10
        while 1:
            if time.time() < timeout:
                try:
                    self.bind(config.address)
                    break
                except socket.error, err:
                    time.sleep(0.5)
            else:
                raise err


    def start(self):
        """
        """
        self.accept_connections()
        if self.config.sockfam == socket.AF_INET:
            addr, port = self.socket.getsockname()
            logger.info("httpy started on port %s" % port)
        elif self.config.sockfam == socket.AF_UNIX:
            logger.info("httpy started on %s" % self.config.address)
        asyncore.loop(timeout=5)


    def stop(self, signum=None, frame=None):
        """
        """
        if signum is not None:
            logger.debug("caught %s" % STOP_SIGNALS[signum])
        logger.info("shutting down...")

        for app in self.apps:
            if hasattr(app, 'close') and inspect.ismethod(app.close):
                logger.debug("closing %s" % app)
                app.close()
            else:
                logger.debug("%s provides no close method" % app)

        self.task_dispatcher.shutdown()
        asyncore.close_all()

        if self.config.sockfam == socket.AF_UNIX:
            if not os.path.exists(self.config.address):
                logger.debug("what happened to our socket?")
            os.unlink(self.config.address)

        logger.info("httpy stopped")



class Restart(StandardError):
    """Triggers a restart of the child server process.
    """


class RestartingServer(Loader):
    """Instantiate with a Config object, and start it with start().

    This server runs the *real* server in a separate process, restarting it
    whenever modules change on the filesystem. There are actually a number of
    ways to skin this deceptively simple cat. Here's what I've tried:

        Refresh modules directly from within the python process.
        --------------------------------------------------------

        The basic trick is to delete items from sys.modules, forcing a refresh
        the next time they are loaded. However, because modules import from one
        another, you need to make sure you reload enough of them to make it
        worth it. I got pretty far down this road (the place to start is to
        google for RollbackImporter), but at a couple points I started seeing
        very elusive segfaults. My best guess is that I was hitting a bug in
        Python, but I never narrowed it down enough to file it. :-(


        Run the python process within a wrapper that knows how to restart it.
        ---------------------------------------------------------------------

        Since you need to refresh almost all of your modules anyway, it makes a
        lot of sense to deal with the problem at the macro level. I got this
        idea from Ian Bicking via CherryPy. Thanks, guys. :-) Their version of
        this solution is to spawn a process and block for it, and then monitor
        the state of the modules on the filesystem in a separate thread. They
        use the blocked process's exit code to trigger reloading.


        Run within a wrapper but monitor within the process.
        ----------------------------------------------------

        I think it should also work to push the monitoring functionality down
        into the application, but I wasn't able to successfully exit zope.server
        from inside it, because I don't understand threading well enough.


        Run in a non-blocking process, monitor within the main process.
        ---------------------------------------------------------------

        The solution I've settled on here is to start the main server in a
        separate process, but not to block for it. I then monitor the filesystem
        in the main process/thread, and manipulate the worker process via its
        process ID. This solution, therefore, is not Windows-compatible. But,
        boy, is it simpler. :-)  See also: my above comment on me vs. threading.


    """

    def __init__(self, config):
        self.config = config
        self.mtimes = {}
        self.pid = -1
        for sig in STOP_SIGNALS:
           signal.signal(sig, self.stop)


        # Load framework and apps so that we can monitor them for changes.
        # ================================================================

        self.config = config

        self.debug_mode  = self.config.mode == 'debugging'
        self.deploy_mode = self.config.mode == 'deployment'
        self.devel_mode  = self.config.mode == 'development'

        dummy = self.get_framework()
        dummy = self.get_apps()


    def start(self, args=None):
        logger.info("starting child server ...")
        if args is None:
            args = [sys.executable] + sys.argv
        new_env = os.environ.copy()
        new_env['HTTPY_PLAIN_JANE'] = 'So plain.'
        while 1:
            try:
                try:
                    self.pid = subprocess.Popen(args, env=new_env).pid
                    while 1:
                        self.look_for_changes()
                        time.sleep(1)
                finally:
                    self.stop_child()
            except SystemExit:
                time.sleep(0.5) # Give stdout a chance to flush.
                raise
            except Restart:
                logger.info("restarting child server ...")
            except:
                logger.error("exception while spawning child ...\n" +
                             traceback.format_exc())


    def stop_child(self):
        """Stop the child server process.
        """
        if self.pid > 0:
            try:
                os.kill(self.pid, signal.SIGTERM)
            except OSError:
                logger.warning("OSError killing pid %d" % self.pid)
                logger.warning(traceback.format_exc())
        else:
            logger.error("self.pid is %s; won't kill" % str(self.pid))


        if 0: # this is for debugging the restart-while-debugging bug

            print "isatty: %s %s %s" % tuple([x.isatty() for x in ( sys.stdin
                                                                  , sys.stdout
                                                                  , sys.stderr
                                                                  )])

            while 0:
                msg = os.read(0, 8192)
                if msg == 'quit\n':
                    break
                os.write(1, msg)

            #stdin = os.open('/dev/stdin', os.O_WRONLY)
            #os.dup2(stdin, 0)
            #stdout = os.open('/dev/stdout', os.O_WRONLY)
            #os.dup2(stdout, 1)
            #stderr = os.open('/dev/stderr', os.O_WRONLY)
            #os.dup2(stderr, 2)


    def stop(self, signum=-1, frame=None):
        """Stop the child process, then exit ourselves.
        """
        self.stop_child()
        if signum is not None:
            logger.debug("parent caught %s" % STOP_SIGNALS[signum])
        logger.debug("parent shutting down...")
        raise SystemExit


    def look_for_changes(self):
        """See if any of our available modules have changed on the filesystem.
        """

        for module in sys.modules.values():

            # Get out early if we can.
            # ========================

            filename = getattr(module, '__file__', None)
            if filename is None:
                continue
            if filename.endswith(".pyc"):
                filename = filename[:-1]


            # The file may have been removed from the filesystem.
            # ===================================================

            if not os.path.isfile(filename):
                logger.debug("missing: %s" % filename)
                if filename in self.mtimes:
                    del self.mtimes[filename]
                raise Restart


            # Or not.
            # =======

            mtime = os.stat(filename).st_mtime
            if filename not in self.mtimes:
                self.mtimes[filename] = mtime
                continue
            if mtime > self.mtimes[filename]:
                logger.debug("outdated: %s" % filename)
                self.mtimes[filename] = mtime
                raise Restart
