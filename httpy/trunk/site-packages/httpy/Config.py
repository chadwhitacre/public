import imp
import os
import socket
import sys
import traceback
from ConfigParser import RawConfigParser
from optparse import OptionParser

from httpy import DefaultApp
from httpy.interfaces import IApp, ITransaction
from httpy._zope.interface.verify import verifyClass, verifyObject


class ConfigError(Exception):
    """This is an error in any part of our configuration.
    """

    def __init__(self, msg):
        self.msg = msg
        Exception.__init__(self)

    def __str__(self):
        return self.msg


class AppConfig:
    """Represents an httpy application's configuration. API:

        uri_root    The application's root in URL-space
        fs_root     The application's root on the filesystem
        __          The application's magic directory on the filesystem
        module      The Python module defining the application

    """

    uri_root    = '<empty>'
    fs_root     = '<empty>'
    __          = '<empty>'
    module      = None


    def __init__(self, site_root, app_uri_root):
        """Takes the site's filesystem root and the app's URL-space root.
        """

        msg = ("Found bad app `%s'. Each app must be a path rooted in the " +
               "website root, and it must have a subdirectory named __.")


        # Find the app's filesystem root.
        # ===============================

        _parts = [p for p in app_uri_root.lstrip('/').split('/') if p]
        _parts.insert(0, site_root)
        fs_root = os.sep.join(_parts)
        if not os.path.isdir(fs_root):
            raise ConfigError(msg % fs_root)


        # Find the app's magic directory.
        # ===============================

        __ = os.path.join(fs_root, '__')
        if not os.path.isdir(__):
            if fs_root == site_root:
                __ = None # special case
            else:
                raise ConfigError(msg % fs_root)


        # Load the actual module.
        # =======================

        module = self._load_module(__, app_uri_root)


        # Save
        # ====

        self.uri_root   = app_uri_root
        self.fs_root    = fs_root
        self.__         = __
        self.module     = module


    def __repr__(self):
        if self.__ is None:
            return "<default httpy app @ / >"
        return "<httpy app @ %s >" % self.uri_root
    __str__ = __repr__

    def _load_module(self, __, name):
        """Given a magic directory, return a module.

        We support automatically falling back to DefaultApp for the root
        directory. Otherwise, we fail if there is no importable app. We also
        validate the app using zope interfaces. Your app needn't implement zope
        interfaces explicitly, however.

        """

        if __ is None:
            app = DefaultApp
        else:
            try:
                fp, pathname, description = imp.find_module('app', [__])
                app = imp.load_module(name, fp, pathname, description)
            except ImportError:
                raise ConfigError("Unable to import an app from " +
                                  "%s: \n%s" % (__, traceback.format_exc()))

        verifyObject(IApp, app, tentative=True)
        verifyClass(ITransaction, app.Transaction, tentative=True)

        return app


class ServerConfig:
    """Determine the config for an httpy server from four sources:

        - defaults -- hard-wired defaults
        - env -- environment variables
        - file_ -- a configuration file
        - opts -- command line options

    A dictionary is built from each context, and then validated: if possible,
    values are coerced to the requisite types; if not, ConfigError is raised.
    These dictionaries are combined in the order given above, such that
    environment variables override defaults, etc. Finally, the combined
    dictionary is transfered to the following attributes on self:

        ip      an IPv4 address or the empty string

        port    an integer between 0 and 65535, inclusive

        mode    either `deployment' or `development'

        root    the path to a directory on the filesystem which will serve as
                the root of the website

        apps    a tuple of of paths rooted in self['root'] that should be
                considered applications

        verbosity
                an integer between 0 and 99, inclusive, indicating how much
                information to log


    """

    options = ( 'ip'
              , 'port'
              , 'mode'
              , 'root'
              , 'apps'
              , 'verbosity'
               )

    apps_unset = True # Track whether the user explicitly set apps.


    def __init__(self, argv=[]):

        # Read them in reverse order because any file path will be in opts.
        # =================================================================

        opts, path = self._opts(argv)
        file_ = self._file(path)
        env = self._env()
        defaults = self._defaults()


        # If we make it this far without an exception then we have clean data.
        # ====================================================================

        config = {}
        config.update(defaults)
        config.update(env)
        config.update(file_)
        config.update(opts)

        self.ip = config['ip']
        self.port = config['port']
        self.mode = config['mode']
        self.root = config['root']
        self.apps = config['apps']
        self.verbosity = config['verbosity']


        # Influence sys.path and Load this site's applications.
        # =====================================================
        # We stick site_packages in sys.path whether it exists or not, because
        # otherwise we have to factor root app validation back out of
        # AppConfig.

        site_packages = os.path.join(self.root, '__', 'site-packages')
        sys.path.insert(0, site_packages)

        if self.apps_unset:
            self.apps = self._find_apps(self.root)
        if '/' not in self.apps:
            self.apps += ('/',)
        apps = []
        for app_uri_root in self.apps:
            apps.append(AppConfig(self.root, app_uri_root))
        self.apps = apps


    def _defaults(self):

        d = {}

        d['ip'] = ''
        d['port'] = 8080
        d['mode'] = 'deployment'
        d['root'] = os.path.realpath('.')
        d['apps'] = ''
        d['verbosity'] = 1

        return self._validate('defaults', d)


    def _env(self):

        d = {}

        for key in self.options:
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                d[key] = os.environ.get(envvar)

        return self._validate('env', d)


    def _file(self, path):

        d = {}

        parser_ = RawConfigParser()
        parser_.read(path)

        sections = parser_.sections()

        for key in self.options:
            for section in sections:
                if parser_.has_option(section, key):
                    d[key] = parser_.get(section, key)

        return self._validate('file', d)


    def _opts(self, argv):
        """Special case: return a valid dictionary *and* a config file path.
        """

        d = {}
        path = ''

        if not argv:
            return d, path

        usage = "for details, `man 1 httpy'."

        parser_ = OptionParser(usage=usage)
        parser_.add_option("-f", "--file", dest="path",
                           help="The path to a configuration file. []")
        parser_.add_option("-i", "--ip", dest="ip",
                           help="The IP address to listen on. [all]")
        parser_.add_option("-p", "--port", dest="port",
                           help="The TCP port to listen on. [8080]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="`development' or `deployment'. [deployment]")
        parser_.add_option("-r", "--root", dest="root",
                           help="The path to the website root. [.]")
        parser_.add_option("-a", "--apps", dest="apps",
                           help="A whitespace- or comma-separated list of " +
                                "URI abs_paths. []")
        parser_.add_option("-v", "--verbosity", dest="verbosity",
                           help="An integer between 0 and 99 (inclusive) " +
                                "indicating how much information to log. [1]")
        opts, args = parser_.parse_args(args=argv)


        # Validate the path if given.
        # ===========================

        if opts.path:
            path = os.path.realpath(opts.path)
            if not os.path.isfile(path):
                raise ConfigError("The path %s does not point to a "
                                  "file." % path)


        # Build the dictionary.
        # =====================

        d = {}

        for key in self.options:
            if hasattr(opts, key):
                val = getattr(opts, key)
                if val is not None:
                    d[key] = val


        return (self._validate('opts', d), path)


    def _validate(self, context, d):
        """Given a string and a dictionary, return a validated dictionary.

        First, superfluous keys are removed. Then each key is validated in turn
        if present. Some type coercion is performed, and then the values are
        checked. If either fails, ConfigError is raised.

        """

        if not d:
            return d

        _d = {}
        for k, v in d.items():
            if k in self.options:
                _d[k] = v
        d = _d


        # ip
        # ==
        # Must be either the empty string or a valid IPv4 address.

        if d.has_key('ip'):

            msg = "Found bad IP `%s' in context `%s'. " +\
                  "IP must be empty or a valid IPv4 address."
            msg = msg % (str(d['ip']), context)

            if not d['ip']:
                d['ip'] = ''
            elif not isinstance(d['ip'], basestring):
                raise ConfigError(msg)
            elif d['ip'] != '':
                try:
                    socket.inet_aton(d['ip'])
                except socket.error:
                    raise ConfigError(msg)


        # port
        # ====
        # Coerce to int. Must be between 0 and 65535, inclusive.

        if d.has_key('port'):

            msg = "Found bad port `%s' in context `%s'. " +\
                  "Port must be an integer between 0 and 65535."
            msg = msg % (str(d['port']), context)

            if isinstance(d['port'], basestring) and \
               d['port'].isdigit():
                d['port'] = int(d['port'])
            elif isinstance(d['port'], int) and not (d['port'] is False):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if not(0 <= d['port'] <= 65535):
                raise ConfigError(msg)


        # mode
        # ====

        if d.has_key('mode'):

            msg = "Found bad mode `%s' in context `%s'. Mode must be " +\
                  "either `deployment' or `development'."
            msg = msg % (str(d['mode']), context)

            if d['mode'] not in ('deployment', 'development'):
                raise ConfigError(msg)


        # root
        # ====
        # Must be a valid directory (also check perms?)

        if d.has_key('root'):

            msg = "Found bad root `%s' in context `%s'. " +\
                  "Root must point to a directory."
            msg = msg % (str(d['root']), context)

            if isinstance(d['root'], basestring):
                d['root'] = os.path.realpath(d['root'])
            else:
                raise ConfigError(msg)

            if not os.path.isdir(d['root']):
                raise ConfigError(msg)


        # apps
        # ====
        # Coerce to a tuple. Must all be valid paths.

        if d.has_key('apps'):

            msg = ("Found bad apps `%s' in context `%s'. Apps must be a " +
                    "colon-separated list of paths rooted in the website " +
                    "root.")
            msg = msg % (str(d['apps']), context)

            if isinstance(d['apps'], basestring):
                if not d['apps']:
                    d['apps'] = ()
                else:
                    d['apps'] = tuple(d['apps'].split(':'))
            elif isinstance(d['apps'], tuple):
                pass # already a tuple for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if context != 'defaults':
                self.apps_unset = False


        # verbosity
        # =========
        # Coerce to int. Must be between 0 and 99, inclusive.

        if d.has_key('verbosity'):

            msg = "Found bad verbosity `%s' in context `%s'. " +\
                  "Verbosity must be an integer between 0 and 99."
            msg = msg % (str(d['verbosity']), context)

            if (isinstance(d['verbosity'], basestring)
                and d['verbosity'].isdigit()
                ):
                d['verbosity'] = int(d['verbosity'])
            elif (isinstance(d['verbosity'], int)
                  and not (d['verbosity'] is False)
                  ):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if not(0 <= d['verbosity'] <= 99):
                raise ConfigError(msg)


        # Made it!
        # ========

        return d


    @staticmethod
    def _find_apps(root):
        """Given an absolute fs path, return a sequence of apps below that path.

        All apps are specified in URL-space; they should not include the website
        filesystem root. They should begin with a single forward slash, but
        should not end with one.

        This method is only run if the user has not explicitly configured apps.
        Our rationale for this violation of EIBTI is that apps is the only
        configuration parameter that cannot be arbitrarily changed at deployment
        time. In other words, a site can discharge its duty regardless of what
        ip or port it is on, but a misconfigured apps setting will break a site.

        To achieve our design goal of zero configuration (and thereby to reduce
        friction in an auto-deployment situation), httpy needs to be able to
        introspect a website's applications in a predictable manner. Building
        this functionality in at this level means we can get used to it in
        development, so that we can trust it in deployment.

        """

        apps = []
        for path, dirs, files in os.walk(root):
            if '.svn' in dirs:
                dirs.remove('.svn')
            dirs = sorted(dirs)
            if '__' in dirs:
                if path == root:
                    app_fs_root = os.sep
                else:
                    app_fs_root = path[len(root):]
                if '__' not in app_fs_root.split(os.sep):
                    apps.append(app_fs_root)
        return tuple(reversed(apps))




class TransactionConfig:

    def __init__(self, app, server):
        """Takes a ServerConfig and an AppConfig.
        """
        self.mode         = server.mode
        self.verbosity    = server.verbosity
        self.site_root    = server.root
        self.app_uri_root = app.uri_root
        self.app_fs_root  = app.fs_root
        self.__           = app.__
