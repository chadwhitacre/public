import os
import socket
import sys
import traceback
from ConfigParser import RawConfigParser
from optparse import OptionParser

from httpy import utils


class ConfigError(StandardError):
    """This is an error in any part of our configuration.
    """

    def __init__(self, msg):
        StandardError.__init__(self)
        self.msg = msg

    def __str__(self):
        return self.msg


class Config:
    """Determine the config for an httpy server from four sources:

        - defaults -- hard-wired defaults
        - env -- environment variables
        - file_ -- a configuration file
        - opts -- command line options

    A dictionary is built from each context, and then validated: if possible,
    values are coerced to the requisite types; if not, ConfigError is raised.
    These dictionaries are combined in the order given above, such that
    environment variables override defaults, etc. Finally, the combined
    dictionary is transfered to the following attributes on self:

        sockfam the family of the address to which httpy should bind; options
                are the strings `AF_INET', `AF_INET6', and `AF_UNIX'.

        address a socket address, the specific format of which depends on the
                sockfam argument, per the Python socket documentation; where
                tuples are called for, a comma-delimited string will suffice

        mode    either `deployment,' `development,' or `debugging'

        root    the path to a directory on the filesystem which will serve as
                the root of the website

        apps    a tuple of paths rooted in self['root'] that should be
                considered applications

        verbosity
                an integer between 0 and 99, inclusive, indicating how much
                information to log


    """

    options = ( 'sockfam'
              , 'address'
              , 'apps'
              , 'mode'
              , 'root'
              , 'verbosity'
               )

    apps_unset = True # Track whether the user explicitly set apps.


    def __init__(self, argv=[]):

        # Read them in reverse order because any file path will be in opts.
        # =================================================================

        opts, path = self._opts(argv)
        file_ = self._file(path)
        env = self._env()
        defaults = self._defaults()


        # If we make it this far without an exception then we have clean data.
        # ====================================================================
        # So now it's time to collate all our configuration, and store it in
        # useful places. Some goes on self, to be passed to Server.__init__.
        # A couple others are put in the environment.

        config = {}
        config.update(defaults)
        config.update(env)
        config.update(file_)
        config.update(opts)

        self.sockfam = config['sockfam']
        self.address = self._validate_address(config['address'])
        self.root = config['root']
        self.apps = config['apps']

        os.environ["HTTPY_VERBOSITY"] = str(config['verbosity'])
        os.environ["HTTPY_MODE"] = str(config['mode'])


        # Influence sys.path.
        # =====================================================
        # We stick site_packages in sys.path whether it exists or not, because
        # otherwise we have to factor root app validation back out of
        # load_app.

        site_packages = os.path.join(self.root, '__', 'site-packages')
        sys.path.insert(0, site_packages)

        if self.apps_unset:
            self.apps = utils.find_apps(self.root)
        if '/' not in self.apps:
            self.apps += ('/',)
        apps = []
        for app_uri_root in self.apps:
            apps.append(utils.load_app(self.root, app_uri_root))
        self.apps = apps


    def _defaults(self):

        d = {}

        d['sockfam'] = socket.AF_INET
        d['address'] = ('', 8080)
        d['mode'] = 'deployment'
        d['root'] = os.path.realpath('.')
        d['apps'] = ''
        d['verbosity'] = 1

        return self._validate('defaults', d)


    def _env(self):

        d = {}

        for key in self.options:
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                d[key] = os.environ.get(envvar)

        return self._validate('env', d)


    def _file(self, path):

        d = {}

        parser_ = RawConfigParser()
        parser_.read(path)

        sections = parser_.sections()

        for key in self.options:
            for section in sections:
                if parser_.has_option(section, key):
                    d[key] = parser_.get(section, key)

        return self._validate('file', d)


    def _opts(self, argv):
        """Special case: return a valid dictionary *and* a config file path.
        """

        d = {}
        path = ''

        if not argv:
            return d, path

        usage = "for details, `man 1 httpy'."

        parser_ = OptionParser(usage=usage)
        parser_.add_option("-f", "--file", dest="path",
                           help="The path to a configuration file. []")
        parser_.add_option("-s", "--sockfam", dest="sockfam",
                           help="`AF_INET' `AF_INET6' or `AF_UNIX'. [AF_INET]")
        parser_.add_option("-d", "--address", dest="address",
                           help="The address to bind to. [<INADDR_ANY>]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="`deploy' `develop' or `debug'. [deploy]")
        parser_.add_option("-r", "--root", dest="root",
                           help="The path to the website root. [.]")
        parser_.add_option("-a", "--apps", dest="apps",
                           help="A whitespace- or comma-separated list of " +
                                "URI abs_paths. []")
        parser_.add_option("-v", "--verbosity", dest="verbosity",
                           help="An integer between 0 and 99 (inclusive) " +
                                "indicating how much information to log. [1]")
        opts, args = parser_.parse_args(args=argv)


        # Validate the path if given.
        # ===========================

        if opts.path:
            path = os.path.realpath(opts.path)
            if not os.path.isfile(path):
                raise ConfigError("The path %s does not point to a "
                                  "file." % path)


        # Build the dictionary.
        # =====================

        d = {}

        for key in self.options:
            if hasattr(opts, key):
                val = getattr(opts, key)
                if val is not None:
                    d[key] = val


        return (self._validate('opts', d), path)


    def _validate(self, context, d):
        """Given a string and a dictionary, return a validated dictionary.

        First, superfluous keys are removed. Then each key is validated in turn
        if present. Some type coercion is performed, and then the values are
        checked. If either fails, ConfigError is raised.

        """

        if not d:
            return d

        _d = {}
        for k, v in d.items():
            if k in self.options:
                _d[k] = v
        d = _d



        # sockfam
        # =======
        # Must be a socket family per the socket module. May be a string.

        if d.has_key('sockfam'):

            msg = ("Found bad socket family `%s' in context `%s'. " +
                   "Socket family must be either `AF_INET' or `AF_UNIX'.")
            msg = msg % (str(d['sockfam']), context)

            sockfams = ( socket.AF_INET
                       , socket.AF_UNIX
                       , 'AF_INET'
                       , 'AF_UNIX'
                        )
            someday =  ( socket.AF_INET6
                       , 'AF_INET6'
                        )

            if d['sockfam'] in someday:
                raise NotImplementedError
            elif d['sockfam'] not in sockfams:
                raise ConfigError(msg)
            elif isinstance(d['sockfam'], basestring):
                d['sockfam'] = getattr(socket, d['sockfam'])


        # address
        # =======
        # This is factored out since it depends on the socket family, which
        # we won't finally know until all contexts have been processed.


        # mode
        # ====
        # We expand abbreviations to the full term.

        if d.has_key('mode'):

            msg = ("Found bad mode `%s' in context `%s'. Mode must be " +
                   "either `deployment,' `development' or `debugging.' " +
                   "Abbreviations are fine.")
            msg = msg % (str(d['mode']), context)


            if not isinstance(d['mode'], basestring):
                raise ConfigError(msg)
            elif len(d['mode']) < 3:
                raise ConfigError(msg)
            elif 'deployment'.startswith(d['mode']):
                d['mode'] = 'deployment'
            elif 'development'.startswith(d['mode']):
                d['mode'] = 'development'
            elif 'debugging'.startswith(d['mode']):
                d['mode'] = 'debugging'
            else:
                raise ConfigError(msg)


        # root
        # ====
        # Must be a valid directory (also check perms?)

        if d.has_key('root'):

            msg = "Found bad root `%s' in context `%s'. " +\
                  "Root must point to a directory."
            msg = msg % (str(d['root']), context)

            if isinstance(d['root'], basestring):
                d['root'] = os.path.realpath(d['root'])
            else:
                raise ConfigError(msg)

            if not os.path.isdir(d['root']):
                raise ConfigError(msg)


        # apps
        # ====
        # Coerce to a tuple. Must all be valid paths.

        if d.has_key('apps'):

            msg = ("Found bad apps `%s' in context `%s'. Apps must be a " +
                    "colon-separated list of paths rooted in the website " +
                    "root.")
            msg = msg % (str(d['apps']), context)

            if isinstance(d['apps'], basestring):
                if not d['apps']:
                    d['apps'] = ()
                else:
                    d['apps'] = tuple(d['apps'].split(':'))
            elif isinstance(d['apps'], tuple):
                pass # already a tuple for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if context != 'defaults':
                self.apps_unset = False


        # verbosity
        # =========
        # Coerce to int. Must be between 0 and 99, inclusive.

        if d.has_key('verbosity'):

            msg = "Found bad verbosity `%s' in context `%s'. " +\
                  "Verbosity must be an integer between 0 and 99."
            msg = msg % (str(d['verbosity']), context)

            if (isinstance(d['verbosity'], basestring)
                and d['verbosity'].isdigit()
                ):
                d['verbosity'] = int(d['verbosity'])
            elif (isinstance(d['verbosity'], int)
                  and not (d['verbosity'] is False)
                  ):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if not(0 <= d['verbosity'] <= 99):
                raise ConfigError(msg)


        # Made it!
        # ========

        return d


    def _validate_address(self, addr):
        """Validate the address, returning a type-coerced address.

        This is factored out because it depends on the socket family.

        """

        def const2name(n):
            if n==1: return 'AF_UNIX'
            if n==2: return 'AF_INET'
            if n==28: return 'AF_INET6'

        msg = "Found bad address `%s' for address family `%s'."
        msg = msg % (addr, const2name(self.sockfam))
        err = ConfigError(msg)

        if self.sockfam == socket.AF_UNIX:
            # the easy one -- has to be a string
            # we could test to see if the path exists or is creatable

            if not isinstance(addr, basestring):
                raise err

            return addr


        elif self.sockfam == socket.AF_INET:
            # Here we need a tuple: (str, int). The string must be a valid
            # IPv4 address or the empty string, and the int -- the port -- must
            # be between 0 and 65535, inclusive.


            # Break out IP and port.
            # ======================

            if isinstance(addr, (tuple, list)):
                if len(addr) != 2:
                    raise
                ip, port = addr
            elif isinstance(addr, basestring):
                if addr.count(':') != 1:
                    raise err
                ip, port = [i.strip() for i in addr.lower().split(':')]
            else:
                raise err


            # IP
            # ==

            if not isinstance(ip, basestring):
                raise err
            elif ip != '':
                try:
                    socket.inet_aton(ip)
                except socket.error:
                    raise err


            # port
            # ====
            # Coerce to int. Must be between 0 and 65535, inclusive.

            if isinstance(port, basestring):
                if not port.isdigit():
                    raise err
                else:
                    port = int(port)
            elif isinstance(port, int) and not (port is False):
                pass # already an int for some reason (called interactively?)
            else:
                raise err

            if not(0 <= port <= 65535):
                raise err


            # Return.
            # =======

            return (ip, port)


        elif self.sockfam == socket.AF_INET6:
            raise NotImplementedError # sorry!
