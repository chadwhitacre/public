import os
import socket
from ConfigParser import RawConfigParser
from optparse import OptionParser


class ConfigError(Exception):
    """This is an error in any part of our configuration.
    """

    def __init__(self, msg):
        self.msg = msg
        Exception.__init__(self)

    def __str__(self):
        return self.msg


class Config(dict):
    """Determine the config for an httpy server from four sources:

        - defaults -- hard-wired defaults
        - env -- environment variables
        - file_ -- a configuration file
        - opts -- command line options

    A dictionary is built from each context, and then validated: if possible,
    values are coerced to the requisite types; if not, ConfigError is raised.
    These dictionaries are combined in the order given above, such that
    environment variables override defaults, etc. Finally, the combined
    dictionary is transfered to self. A Config instance has the following
    values:

        ip      an IPv4 address or the empty string

        port    an integer between 0 and 65535, inclusive

        mode    either `deployment' or `development'

        root    the path to a directory on the filesystem which will serve as
                the root of the website

        apps    a list of paths rooted in self['root'] that should be
                considered applications

        verbosity
                an integer between 0 and 99, inclusive, indicating how much
                information to log


    The `ossify' method is used to convert a Config object to a standard
    dictionary.

    """

    options = ( 'ip'
              , 'port'
              , 'mode'
              , 'root'
              , 'apps'
              , 'verbosity'
               )


    def __init__(self, argv=[]):

        # Read them in reverse order because any file path will be in opts.

        opts, path = self._opts(argv)
        file_ = self._file(path)
        env = self._env()
        defaults = self._defaults()

        # If we make it this far without an exception then we have clean data.

        config = {}
        config.update(defaults)
        config.update(env)
        config.update(file_)
        config.update(opts)

        self['ip'] = config['ip']
        self['port'] = config['port']
        self['mode'] = config['mode']
        self['root'] = config['root']
        self['apps'] = config['apps']
        self['verbosity'] = config['verbosity']

        self.validate_apps()


    ossify = dict.copy


    def _defaults(self):

        d = {}

        d['ip'] = ''
        d['port'] = 8080
        d['mode'] = 'deployment'
        d['root'] = os.path.realpath('.')
        d['apps'] = ''
        d['verbosity'] = 1

        return self._validate('defaults', d)


    def _env(self):

        d = {}

        for key in self.options:
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                d[key] = os.environ.get(envvar)

        return self._validate('env', d)


    def _file(self, path):

        d = {}

        parser_ = RawConfigParser()
        parser_.read(path)

        sections = parser_.sections()

        for key in self.options:
            for section in sections:
                if parser_.has_option(section, key):
                    d[key] = parser_.get(section, key)

        return self._validate('file', d)


    def _opts(self, argv):
        """Special case: return a valid dictionary *and* a config file path.
        """

        d = {}
        path = ''

        if not argv:
            return d, path

        usage = "for details, `man 1 httpy'."

        parser_ = OptionParser(usage=usage)
        parser_.add_option("-f", "--file", dest="path",
                           help="The path to a configuration file. []")
        parser_.add_option("-i", "--ip", dest="ip",
                           help="The IP address to listen on. [all]")
        parser_.add_option("-p", "--port", dest="port",
                           help="The TCP port to listen on. [8080]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="`development' or `deployment'. [deployment]")
        parser_.add_option("-r", "--root", dest="root",
                           help="The path to the website root. [.]")
        parser_.add_option("-a", "--apps", dest="apps",
                           help="A whitespace- or comma-separated list of " +
                                "URI abs_paths. []")
        parser_.add_option("-v", "--verbosity", dest="verbosity",
                           help="An integer between 0 and 99 (inclusive) " +
                                "indicating how much information to log. [1]")
        opts, args = parser_.parse_args(args=argv)


        # Validate the path if given.
        # ===========================

        if opts.path:
            path = os.path.realpath(opts.path)
            if not os.path.isfile(path):
                raise ConfigError("The path %s does not point to a "
                                  "file." % path)


        # Build the dictionary.
        # =====================

        d = {}

        for key in self.options:
            if hasattr(opts, key):
                val = getattr(opts, key)
                if val is not None:
                    d[key] = val


        return (self._validate('opts', d), path)


    def _validate(self, context, d):
        """Given a string and a dictionary, return a validated dictionary.

        First, superfluous keys are removed. Then each key is validated in turn
        if present. Some type coercion is performed, and then the values are
        checked. If either fails, ConfigError is raised.

        """

        if not d:
            return d

        _d = {}
        for k, v in d.items():
            if k in self.options:
                _d[k] = v
        d = _d


        # ip
        # ==
        # Must be either the empty string or a valid IPv4 address.

        if d.has_key('ip'):

            msg = "Found bad IP `%s' in context `%s'. " +\
                  "IP must be empty or a valid IPv4 address."
            msg = msg % (str(d['ip']), context)

            if not d['ip']:
                d['ip'] = ''
            elif not isinstance(d['ip'], basestring):
                raise ConfigError(msg)
            elif d['ip'] != '':
                try:
                    socket.inet_aton(d['ip'])
                except socket.error:
                    raise ConfigError(msg)


        # port
        # ====
        # Coerce to int. Must be between 0 and 65535, inclusive.

        if d.has_key('port'):

            msg = "Found bad port `%s' in context `%s'. " +\
                  "Port must be an integer between 0 and 65535."
            msg = msg % (str(d['port']), context)

            if isinstance(d['port'], basestring) and \
               d['port'].isdigit():
                d['port'] = int(d['port'])
            elif isinstance(d['port'], int) and not (d['port'] is False):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if not(0 <= d['port'] <= 65535):
                raise ConfigError(msg)


        # mode
        # ====

        if d.has_key('mode'):

            msg = "Found bad mode `%s' in context `%s'. Mode must be " +\
                  "either `deployment' or `development'."
            msg = msg % (str(d['mode']), context)

            if d['mode'] not in ('deployment', 'development'):
                raise ConfigError(msg)


        # root
        # ====
        # Must be a valid directory (also check perms?)

        if d.has_key('root'):

            msg = "Found bad root `%s' in context `%s'. " +\
                  "Root must point to a directory."
            msg = msg % (str(d['root']), context)

            if isinstance(d['root'], basestring):
                d['root'] = os.path.realpath(d['root'])
            else:
                raise ConfigError(msg)

            if not os.path.isdir(d['root']):
                raise ConfigError(msg)


        # apps
        # ====
        # Coerce to a tuple. Must all be valid paths.

        if d.has_key('apps'):

            msg1 = ("Found bad apps `%s' in context `%s'. Apps must be a " +
                    "colon-separated list of paths rooted in the website " +
                    "root.")
            msg1 = msg1 % (str(d['apps']), context)

            if isinstance(d['apps'], basestring):
                if not d['apps']:
                    d['apps'] = ()
                else:
                    d['apps'] = tuple(d['apps'].split(':'))
            elif isinstance(d['apps'], tuple):
                pass # already a tuple for some reason (called interactively?)
            else:
                raise ConfigError(msg1)


        # verbosity
        # =========
        # Coerce to int. Must be between 0 and 99, inclusive.

        if d.has_key('verbosity'):

            msg = "Found bad verbosity `%s' in context `%s'. " +\
                  "Verbosity must be an integer between 0 and 99."
            msg = msg % (str(d['verbosity']), context)

            if (isinstance(d['verbosity'], basestring)
                and d['verbosity'].isdigit()
                ):
                d['verbosity'] = int(d['verbosity'])
            elif (isinstance(d['verbosity'], int)
                  and not (d['verbosity'] is False)
                  ):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if not(0 <= d['verbosity'] <= 99):
                raise ConfigError(msg)


        # Made it!
        # ========

        return d


    def validate_apps(self):
        """Validate the apps in self; exits None on success.

        We break this out so that the self['root'] is set first.

        """

        msg = ("Found bad app `%s'. Each app must be a path rooted in the " +
               "website root.")

        for app_path in self['apps']:
            full_path = os.path.join(self['root'], app_path[1:])
            full_path = os.path.realpath(full_path)
            if not os.path.isdir(full_path):
                msg = msg % (str(app_path))
                raise ConfigError(msg)

