import os
from optparse import OptionParser
from ConfigParser import RawConfigParser


class ConfigError(Exception):
    def __init__(self, msg):
        self.msg = msg


class Configuration:
    """Determine the config for an httpy server from four sources:

        - defaults -- a set of defaults
        - env -- environment variables
        - file_ -- a configuration file
        - opts -- command line options

    For each context, a dictionary is built from that context, and then
    validated: if possible, values are coerced to the requisite types; if not,
    ConfigurationError is raised. These dictionaries are combined in the order
    given above, such that environment variables override defaults, etc.
    Finally, the combined dictionary is split into two, one representing server
    configuration, and one handler configuration.

    """

    def __init__(self, argv=[]):

        self.options = ( 'ip'
                       , 'port'
                       , 'root'
                       , 'defaults'
                       , 'extensions'
                       , 'mode'
                        )

        # Read them in reverse order because any file path is in opts.

        opts, path = self._opts(argv)
        file_ = self._file(path)
        env = self._env()
        defaults = self._defaults()

        # If we make it this far without an exception then we have clean data.

        config = {}
        config.update(defaults)
        config.update(env)
        config.update(file_)
        config.update(opts)

        self.server = {}
        self.server['ip'] = config['ip']
        self.server['port'] = config['port']

        self.handler = {}
        self.handler['root'] = config['root']
        self.handler['defaults'] = config['defaults']
        self.handler['extensions'] = config['extensions']
        self.handler['mode'] = config['mode']


    def _defaults(self):

        d = {}
        d['ip'] = ''
        d['port'] = 8080
        d['root'] = os.path.realpath('.')
        d['defaults'] = 'index.html index.pt'
        d['extensions'] = 'pt'
        d['mode'] = 'development'

        return self._validate('defaults', d)


    def _env(self):

        d = {}

        for key in self.options:
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                d['ip'] = os.environ.get(envvar)

        return self._validate('env', d)


    def _file(self, path):

        d = {}

        parser_ = RawConfigParser()
        parser_.read(path)

        d = {}
        sections = parser_.sections()

        for key in self.options:
            for section in sections:
                if parser_.has_option(section, key):
                    d[key] = parser_.get(section, key)

        return self._validate('file', d)


    def _opts(self, argv):
        """Special case: return a valid dictionary *and* a config file path.
        """

        d = {}
        path = ''

        if not argv:
            return d, path

        usage = "for details, `man 1 httpy'."

        parser_ = OptionParser(usage=usage)
        parser_.add_option("-f", "--file", dest="path",
                           help="The path to a configuration file. [none]")
        parser_.add_option("-i", "--ip", dest="ip",
                           help="The IP address to listen on. [all]")
        parser_.add_option("-p", "--port", dest="port",
                           help="The TCP port to listen on. [8080]")
        parser_.add_option("-r", "--root", dest="root",
                           help="The path to the website root. [.]")
        parser_.add_option("-d", "--defaults", dest="defaults",
                           help="Attempt to serve these files when a " +
                                "directory is requested. [index.html " +
                                "index.pt]")
        parser_.add_option("-e", "--extensions", dest="extensions",
                           help="File extensions that indicate page " +
                                "templates. [pt]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="`development' or `deployment'. [deployment]")
        opts, args = parser_.parse_args(args=argv)


        # Validate the path if given.
        # ===========================

        if opts.path:
            path = os.path.realpath(opts.path)
            if not os.path.isfile(path):
                raise ConfigError("The path %s does not point to a file." % path)


        # Build the dictionary.
        # =====================

        d = {}

        for key in self.options:
            if hasattr(opts, key):
                val = getattr(opts, key)
                if val is not None:
                    d[key] = val


        return (self._validate('opts', d), path)


    def _validate(self, context, d):
        """Given a string and a dictionary, return a validated dictionary.

        Some type coercion is performed. If the value can't be coerced, then
        ConfigurationError is raised. Superfluous keys are deleted.

        """

        # port
        # ====
        # Coerce to int. Must be between 0 and 65535.

        if d.has_key('port'):

            errmsg = "[%s] Port must be an integer between 0 and 65535." % context

            if isinstance(d['port'], basestring) and \
               d['port'].isdigit():
                d['port'] = int(d['port'])
            elif isinstance(d['port'], int):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(errmsg)

            if not(0 <= d['port'] <= 65535):
                raise ConfigError(errmsg)


        # root
        # ====
        # Must be a valid directory (also check perms?)

        if d.has_key('root'):

            d['root'] = os.path.realpath(d['root'])

            errmsg = "[%s] Root (%s) does not point to a directory"

            if not os.path.isdir(d['root']):
                raise ConfigError(errmsg)


        # defaults
        # ========
        # Coerce to a tuple.

        if d.has_key('defaults'):

            errmsg = "[%s] Defaults must be a white-space " % context +\
                     "separated list of filenames."

            if isinstance(d['defaults'], basestring):
                d['defaults'] = tuple(d['defaults'].split())
            elif isinstance(d['defaults'], tuple):
                pass # already a tuple for some reason (called interactively?)
            else:
                raise ConfigError(errmsg)


        # Made it!
        # ========

        return d

        """
        ### just code storage atm


        handler['defaults'] = tuple(handler['defaults'].split())
        handler['extensions'] = tuple(handler['extensions'].split())
        if handler['mode'].lower() not in ('development', 'deployment'):
            raise Usage("Configuration error: mode must be one of `development' " +
                        "and `deployment'.")
        if not os.path.isdir(handler['root']):
            raise Usage("Configuration error: site root is not a directory:" +
                        handler['root'])

            handler['defaults'] = tuple(handler['defaults'].split())
            handler['extensions'] = tuple(handler['extensions'].split())
            if not os.path.isdir(handler['root']):
                raise Usage("Configuration error: site root is not a directory:" +
                            handler['root'])
            return (server, handler)

        """
