import os
import socket
from optparse import OptionParser
from ConfigParser import RawConfigParser


class ConfigError(Exception):
    def __init__(self, msg):
        self.msg = msg
        Exception.__init__(self)
    def __str__(self):
        return self.msg


class Configuration:
    """Determine the config for an httpy server from four sources:

        - defaults -- a set of defaults
        - env -- environment variables
        - file_ -- a configuration file
        - opts -- command line options

    For each context, a dictionary is built from that context, and then
    validated: if possible, values are coerced to the requisite types; if not,
    ConfigurationError is raised. These dictionaries are combined in the order
    given above, such that environment variables override defaults, etc.
    Finally, the combined dictionary is split into two, one representing server
    configuration, and one handler configuration.

    """

    options = ( 'ip'
              , 'port'
              , 'root'
              , 'defaults'
              , 'extensions'
              , 'mode'
               )

    def __init__(self, argv=[]):

        # Read them in reverse order because any file path will be in opts.

        opts, path = self._opts(argv)
        file_ = self._file(path)
        env = self._env()
        defaults = self._defaults()

        # If we make it this far without an exception then we have clean data.

        config = {}
        config.update(defaults)
        config.update(env)
        config.update(file_)
        config.update(opts)

        self.server = {}
        self.server['ip'] = config['ip']
        self.server['port'] = config['port']

        self.handler = {}
        self.handler['root'] = config['root']
        self.handler['defaults'] = config['defaults']
        self.handler['extensions'] = config['extensions']
        self.handler['mode'] = config['mode']


    def _defaults(self):

        d = {}
        d['ip'] = ''
        d['port'] = 8080
        d['root'] = os.path.realpath('.')
        d['defaults'] = 'index.html index.pt'
        d['extensions'] = 'pt'
        d['mode'] = 'deployment'

        return self._validate('defaults', d)


    def _env(self):

        d = {}

        for key in self.options:
            envvar = 'HTTPY_%s' % key.upper()
            if os.environ.has_key(envvar):
                d[key] = os.environ.get(envvar)

        return self._validate('env', d)


    def _file(self, path):

        d = {}

        parser_ = RawConfigParser()
        parser_.read(path)

        d = {}
        sections = parser_.sections()

        for key in self.options:
            for section in sections:
                if parser_.has_option(section, key):
                    d[key] = parser_.get(section, key)

        return self._validate('file', d)


    def _opts(self, argv):
        """Special case: return a valid dictionary *and* a config file path.
        """

        d = {}
        path = ''

        if not argv:
            return d, path

        usage = "for details, `man 1 httpy'."

        parser_ = OptionParser(usage=usage)
        parser_.add_option("-f", "--file", dest="path",
                           help="The path to a configuration file. [none]")
        parser_.add_option("-i", "--ip", dest="ip",
                           help="The IP address to listen on. [all]")
        parser_.add_option("-p", "--port", dest="port",
                           help="The TCP port to listen on. [8080]")
        parser_.add_option("-r", "--root", dest="root",
                           help="The path to the website root. [.]")
        parser_.add_option("-d", "--defaults", dest="defaults",
                           help="Attempt to serve these files when a " +
                                "directory is requested. [index.html " +
                                "index.pt]")
        parser_.add_option("-e", "--extensions", dest="extensions",
                           help="File extensions that indicate page " +
                                "templates. [pt]")
        parser_.add_option("-m", "--mode", dest="mode",
                           help="`development' or `deployment'. [deployment]")
        opts, args = parser_.parse_args(args=argv)


        # Validate the path if given.
        # ===========================

        if opts.path:
            path = os.path.realpath(opts.path)
            if not os.path.isfile(path):
                raise ConfigError("The path %s does not point to a file." % path)


        # Build the dictionary.
        # =====================

        d = {}

        for key in self.options:
            if hasattr(opts, key):
                val = getattr(opts, key)
                if val is not None:
                    d[key] = val


        return (self._validate('opts', d), path)


    def _validate(self, context, d):
        """Given a string and a dictionary, return a validated dictionary.

        First, superfluous keys are removed. Then each key is validated in turn
        if present. Some type coercion is performed, and then the values are
        checked. If either fails, ConfigError is raised.

        """

        if not d:
            return d

        _d = {}
        for k, v in d.items():
            if k in self.options:
                _d[k] = v
        d = _d


        # ip
        # ==
        # Must be either the empty string or a valid IPv4 address.

        if d.has_key('ip'):

            msg = "Found bad IP '%s' in context '%s'. " +\
                  "IP must be empty or a valid IPv4 address."
            msg = msg % (str(d['ip']), context)

            if not d['ip']:
                d['ip'] = ''
            elif not isinstance(d['ip'], basestring):
                raise ConfigError(msg)
            elif d['ip'] != '':
                try:
                    socket.inet_aton(d['ip'])
                except socket.error:
                    raise ConfigError(msg)


        # port
        # ====
        # Coerce to int. Must be between 0 and 65535.

        if d.has_key('port'):

            msg = "Found bad port '%s' in context '%s'. " +\
                  "Port must be an integer between 0 and 65535."
            msg = msg % (str(d['port']), context)

            if isinstance(d['port'], basestring) and \
               d['port'].isdigit():
                d['port'] = int(d['port'])
            elif isinstance(d['port'], int) and not (d['port'] is False):
                pass # already an int for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            if not(0 <= d['port'] <= 65535):
                raise ConfigError(msg)


        # root
        # ====
        # Must be a valid directory (also check perms?)

        if d.has_key('root'):

            msg = "Found bad root '%s' in context '%s'. " +\
                  "Root must point to a directory."
            msg = msg % (str(d['root']), context)

            if isinstance(d['root'], basestring):
                d['root'] = os.path.realpath(d['root'])
            else:
                raise ConfigError(msg)

            if not os.path.isdir(d['root']):
                raise ConfigError(msg)


        # defaults
        # ========
        # Coerce to a tuple. Must be filenames only, no paths.

        if d.has_key('defaults'):

            msg = "Found bad defaults '%s' in context '%s'. Defaults " +\
                  "must be a whitespace- or comma-separated list of filenames."
            msg = msg % (str(d['defaults']), context)

            if isinstance(d['defaults'], basestring):
                if ',' in d['defaults']:
                    d['defaults'] = tuple(d['defaults'].split(','))
                else:
                    d['defaults'] = tuple(d['defaults'].split())
            elif isinstance(d['defaults'], tuple):
                pass # already a tuple for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            for filename in d['defaults']:
                if os.sep in filename:
                    raise ConfigError(msg)


        # extensions
        # ==========
        # Coerce to a tuple. Only allow alphanumeric characters

        if d.has_key('extensions'):

            msg = "Found bad defaults '%s' in context '%s'. Extensions " +\
                  "must be a whitespace- or comma-separated list of " +\
                  "alphanumeric filename extensions."
            msg = msg % (str(d['extensions']), context)

            if isinstance(d['extensions'], basestring):
                if ',' in d['extensions']:
                    d['extensions'] = tuple(d['extensions'].split(','))
                else:
                    d['extensions'] = tuple(d['extensions'].split())
            elif isinstance(d['extensions'], tuple):
                pass # already a tuple for some reason (called interactively?)
            else:
                raise ConfigError(msg)

            for ext in d['extensions']:
                if not ext.isalnum():
                    raise ConfigError(msg)


        # mode
        # ====

        if d.has_key('mode'):

            msg = "Found bad mode '%s' in context '%s'. Mode must be " +\
                  "either `deployment' or `development'."
            msg = msg % (str(d['mode']), context)

            if d['mode'] not in ('deployment', 'development'):
                raise ConfigError(msg)


        # Made it!
        # ========

        return d

        """
        ### just code storage atm


        handler['defaults'] = tuple(handler['defaults'].split())
        handler['extensions'] = tuple(handler['extensions'].split())
        if handler['mode'].lower() not in ('development', 'deployment'):
            raise Usage("Configuration error: mode must be one of `development' " +
                        "and `deployment'.")
        if not os.path.isdir(handler['root']):
            raise Usage("Configuration error: site root is not a directory:" +
                        handler['root'])

            handler['defaults'] = tuple(handler['defaults'].split())
            handler['extensions'] = tuple(handler['extensions'].split())
            if not os.path.isdir(handler['root']):
                raise Usage("Configuration error: site root is not a directory:" +
                            handler['root'])
            return (server, handler)

        """
