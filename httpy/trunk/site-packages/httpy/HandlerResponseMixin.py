import traceback

import httpy.app
from httpy import log
from httpy.Response import Response
from httpy.Response import STATUS_CODES


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""



class HandlerResponseMixin:
    """This object contains response-side logic for the Handler class.
    """

    def respond(self, response):

        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase, reason_message = STATUS_CODES.get(response.code)
        if not response.body:
            response.body = reason_message
        status_line = "%s %s %s\r\n" % ( self.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.out.write(status_line)


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if not str(response.code).startswith('2'):
                # Error messages default to text/plain.
                headers['content-type'] = 'text/plain'
            else:
                # But setting this header for succesful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.out.write("%s: %s\r\n" % header)

        self.out.write("\r\n")
        self.out.flush()


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if response.code == 304:
            pass
        elif not hasattr(self, 'request_'):
            # We are handling an parsing error in Request().
            self.out.write(response.body)
        elif self.request_.method != 'HEAD':
            self.out.write(response.body)

        self.out.flush()
        log(94, "Responded with %d %s" % (response.code, reason_phrase))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())


        # Build the response.
        # ===================

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.server.config['mode'] == 'development':
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        # Send the response.
        # ==================

        self.out.write(status_line)
        for header in headers.items():
            self.out.write('%s: %s\r\n' % header)
        self.out.write('\r\n')
        self.out.write(body)


