import logging
import os

from httpy import Response


logger = logging.getLogger('httpy.frameworks.default')


class Responder:
    """This default framework loads IApps per the following rubric:

        /htt.py

    See httpy.interfaces.IFramework for more doc.

    """

    def __init__(self):
        pass


    def respond(self, request):
        """Given a Request, raise an IResponse.
        """

        # Look for a custom site-packages and stick it in the path.
        # =========================================================
        # We support __/site-packages, __/lib, and __ for a custom packages
        # directory, in that order. We always remember the magic directory.

        __ = os.path.join(self.root, '__')
        site_packages = os.path.join(self.root, '__', 'site-packages')
        lib = os.path.join(self.root, '__', 'lib')

        self.__ = None
        if os.path.isdir(__):
            self.__ = __

        for path in (site_packages, lib, __):
            if os.path.isdir(path):
                sys.path.insert(0, path)
                break


    def stop(self):
        return
        for app in self.apps:
            if hasattr(app, 'close') and inspect.ismethod(app.close):
                logger.debug("closing %s" % app)
                app.close()
            else:
                logger.debug("%s provides no close method" % app)



    def get_apps(self):
        """Return a sequence of app instances.

        Any properly-formed app.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no app.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no app.py
        is found there, then we fall back to Static.App.

        """

        # Walk the tree rooted in site_root and load apps.
        # ================================================

        apps = []
        need_default = True
        for path, dirs, files in os.walk(self.config.root):
            if '.svn' in dirs:
                dirs.remove('.svn')
            if '__' in dirs:
                dirs.remove('__')
            dirs = sorted(dirs)
            if 'app.py' in files:
                apps.append(self._load_app(path))
                if path == self.config.root:
                    need_default = False
        apps.reverse()


        # If we didn't find an app in site_root, look in __.
        # ==================================================

        if need_default:
            if self.config.__:
                if 'app.py' in os.listdir(self.config.__):
                    apps.append(self._load_app(self.config.__))
                    need_default = False


        # If we didn't find an app in __ either, use Static.App.
        # ======================================================

        if need_default:
            apps.append(self._instantiate_App( self.config.root
                                                     , Static.App
                                                      ))

        return apps


    def _load_app(self, app_fs_root):
        """Given an app's fs root, return an instance of the application.

        Each app is imported under the app_fs_root so that they don't collide in
        sys.modules.

        """

        logger.debug("loading app from %s" % app_fs_root)
        try:
            fp, pathname, description = imp.find_module('app', [app_fs_root])
            app = imp.load_module(app_fs_root, fp, pathname, description)
        except ImportError:
            raise ImportError("unable to import app from " +
                              "%s: \n%s" % ( app_fs_root
                                           , traceback.format_exc()
                                            ))

        # Validate the app.
        # =================
        # We use zope interfaces, although your app needn't implement zope
        # interfaces explicitly.

        try:
            verifyObject(Iapp, app, tentative=True)
        except:
            logger.debug("app in %s is not valid." % app_fs_root)
            raise
        try:
            verifyClass(IApp, app.App, tentative=True)
        except:
            logger.debug("app.App in %s is not valid." % app_fs_root)
            raise

        return self._instantiate_App(app_fs_root, app.App)


    def _instantiate_App(self, app_fs_root, App):
        """Given a path and an App class, return an instance.

        This is factored out because we want to add some runtime API before
        instantiating, and we want to instantiate in a couple places.

        """

        # Paths
        # =====

        if app_fs_root == self.config.__:
            app_uri_root = '/'
            app_fs_root = self.config.root
        else:
            app_uri_root = app_fs_root[len(self.config.root):]
            app_uri_root = app_uri_root.replace(os.sep, '/')
            if not app_uri_root:
                app_uri_root = '/'

        App.site_root = self.config.root
        App.uri_root = app_uri_root
        App.fs_root = app_fs_root
        App.__ = self.config.__


        # Mode
        # ====

        App.debug_mode = self.debug_mode
        App.deploy_mode = self.deploy_mode
        App.devel_mode = self.devel_mode

        return App()

    def wrap_request(self, app, request):
        """Do some validation.
        """

        # Is the app still on the filesystem?
        if not os.path.isdir(self.app.fs_root):
            raise Response(404)

        if self.server.config.__:

            resource_fs_path = uri_to_fs( self.app.site_root
                                        , self.app.fs_root
                                        , self.app.uri_root
                                        , self.request.path
                                        , raw=True
                                         )

            # Is the site's magic directory still on the filesystem?
            if not os.path.isdir(self.server.config.__):
                raise Response(500, "The site's magic directory has " +
                                    "disappeared.")

            # Protect the magic directory from direct access, but make sure we
            # can serve a default app.py from there.
            if resource_fs_path.startswith(self.server.config.__):
                app_py = os.path.join(self.server.config.__, 'app.py')
                if not resource_fs_path == app_py:
                    raise Response(404)


        return request

    def get_app(self, request):
        """Translates request.path to app.uri_path
        """

        app = None
        for _app in self.apps:
            if request.path.startswith(_app.uri_root):
                app = _app
                break
        if app is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Response(400)

        logger.debug("Using %s for this request." % app)
        return app

    def unwrap_response(self, app, response):
        """We expect an httpy.Response or a standard Python exception.

        Note that we *return* an error Response from here rather than raising
        it.

        """
        if not isinstance(response, (Response, Exception)):
            logger.error("You must raise a Response or Exception.")
            return Response(500)
        return response


Responder = Responder()