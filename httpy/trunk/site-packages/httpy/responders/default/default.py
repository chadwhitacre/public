import inspect
import logging
import os

from httpy._zope.interface import implements
from httpy import Response, responders
from httpy.interfaces import IResponder
from httpy.responders.default.interfaces import Iapp, IApp, IFramework


logger = logging.getLogger('httpy.responder.default')


class DefaultFramework:
    """Pass-through. See IFramework for details.
    """

    implements(IFramework)

    def wrap_request(self, request):
        return request

    def unwrap_response(self, response):
        return response


class Responder(responders.Static): #, responders.Script):
    """This default responder infers a site from your filesystem.
    """

    implements(IResponder)

    def __init__(self):

        # Set paths.
        # ==========

        self.root = os.getcwd()
        self.__ = os.path.join(self.root, '__')
        if not os.path.exists(self.__):
            self.__ = None


        # Find findables.
        # ===============

        self.framework = self.get_framework()
        self.apps = self.get_apps()



    # Contracts
    # =========

    def respond(self, request):
        """Given a Request, raise an IResponse.
        """

        # Locate and validate an app.

        app = self.get_app(request)

        if not os.path.isdir(app.fs_root):
            raise Response(404)

        if self.server.config.__:

            resource_fs_path = uri_to_fs( self.app.site_root
                                        , self.app.fs_root
                                        , self.app.uri_root
                                        , self.request.path
                                        , raw=True
                                         )

            # Is the site's magic directory still on the filesystem?
            if not os.path.isdir(self.server.config.__):
                raise Response(500, "The site's magic directory has " +
                                    "disappeared.")

            # Protect the magic directory from direct access, but make sure we
            # can serve a default app.py from there.
            if resource_fs_path.startswith(self.server.config.__):
                app_py = os.path.join(self.server.config.__, 'app.py')
                if not resource_fs_path == app_py:
                    raise Response(404)


    def stop(self):
        """Close down all apps.
        """
        for app in self.apps:
            if hasattr(app, 'close') and inspect.ismethod(app.close):
                logger.debug("closing %s" % app)
                app.close()
            else:
                logger.debug("%s provides no close method" % app)



    # Find things.
    # ============

    def get_framework(self):
        """Return an IFramework.

        We look in __, then in .. We add a couple API niceties before
        returning.

        """

        # Find a framework.
        # =================

        paths = [self.__, self.root]
        try:
            logger.debug("loading framework ...")
            fp, pathname, description = imp.find_module('framework', paths)
            framework = imp.load_module('framework', fp, pathname, description)
        except ImportError:
            logger.warning("framework import failed:\n" +
                           traceback.format_exc())
            logger.info("falling back to passthrough")
            framework = DefaultFramework


        # Add API and return.
        # ===================

        framework.__ = self.__
        framework.root = self.root

        return framework


    def get_apps(self):
        """Return a sequence of app instances.

        Any properly-formed app.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no app.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no app.py
        is found there, then we fall back to Static.App.

        """

        # Walk the tree rooted in site_root and load apps.
        # ================================================

        apps = []
        need_default = True
        for path, dirs, files in os.walk(self.config.root):
            if '.svn' in dirs:
                dirs.remove('.svn')
            if '__' in dirs:
                dirs.remove('__')
            dirs = sorted(dirs)
            if 'app.py' in files:
                apps.append(self._load_app(path))
                if path == self.config.root:
                    need_default = False
        apps.reverse()


        # If we didn't find an app in site_root, look in __.
        # ==================================================

        if need_default:
            if self.config.__:
                if 'app.py' in os.listdir(self.config.__):
                    apps.append(self._load_app(self.config.__))
                    need_default = False


        # If we didn't find an app in __ either, use Static.App.
        # ======================================================

        if need_default:
            apps.append(self._instantiate_App( self.config.root
                                                     , Static.App
                                                      ))

        return apps

        # Look for a custom site-packages and stick it in the path.
        # =========================================================
        # We support __/site-packages, __/lib, and __ for a custom packages
        # directory, in that order. We always remember the magic directory.

        __ = os.path.join(self.root, '__')
        site_packages = os.path.join(self.root, '__', 'site-packages')
        lib = os.path.join(self.root, '__', 'lib')

        self.__ = None
        if os.path.isdir(__):
            self.__ = __

        for path in (site_packages, lib, __):
            if os.path.isdir(path):
                sys.path.insert(0, path)
                break



    # Helpers.
    # ========

    def uri_to_fs(self, site_root, app_fs_root, app_uri_root, resource_uri_path,
                  defaults=[], raw=False):
        """Map a requested URI to the filesystem.

        Takes a few paths, a list of filenames which should be considered default
        resources, and a flag indicating whether to return the path before doing any
        validation or defaults.

        The URI path is taken to be rooted literally in the filesystem root (which
        could be a site root or an application root). If it points to a directory,
        we look for a default resource if any are named. If it points to a file, we
        make sure the file exists.

        This method can raise the following Responses:

            301 Moved Permanently
            400 Bad Request
            403 Forbidden
            404 Not Found

        If successful, we return the filesystem path to the particular resource.

        """

        logger = logging.getLogger('httpy.utils.uri_to_fs')


        # Knit the requested URI onto the application root.
        # =================================================

        if app_fs_root == site_root:
            _parts = resource_uri_path.lstrip('/').split('/')
        else:
            uri_below_app = resource_uri_path[len(app_uri_root):]
            _parts = uri_below_app.lstrip('/').split('/')

        _parts.insert(0, app_fs_root)
        resource_fs_path = os.sep.join(_parts)
        resource_fs_path = os.path.realpath(resource_fs_path)


        if raw:
            return resource_fs_path


        if os.path.isdir(resource_fs_path):

            # Process the request as a directory.
            # ===================================

            if not resource_uri_path.endswith('/'):
                # redirect directory requests to trailing slash
                new_location = '%s/' % resource_uri_path
                response = Response(301)
                response.headers['Location'] = new_location
                logger.debug("redirecting to trailing slash: %s" % resource_uri_path)
                raise response

            logger.debug("looking for these defaults: %s" % str(defaults))
            default = ''
            for name in defaults:
                _path = os.path.join(resource_fs_path, name)
                if os.path.isfile(_path):
                    default = _path
                    break
            resource_fs_path = default
            if not default:
                logger.debug("no default resource in: %s" % resource_fs_path)
                raise Response(403)

        else:

            # Process the request as a file.
            # ==============================

            if not os.path.exists(resource_fs_path):
                logger.debug("did not find %s at %s" % ( resource_uri_path
                                                   , resource_fs_path
                                                    ))
                raise Response(404)


        return resource_fs_path









    def _load_app(self, app_fs_root):
        """Given an app's fs root, return an instance of the application.

        Each app is imported under the app_fs_root so that they don't collide in
        sys.modules.

        """

        logger.debug("loading app from %s" % app_fs_root)
        try:
            fp, pathname, description = imp.find_module('app', [app_fs_root])
            app = imp.load_module(app_fs_root, fp, pathname, description)
        except ImportError:
            raise ImportError("unable to import app from " +
                              "%s: \n%s" % ( app_fs_root
                                           , traceback.format_exc()
                                            ))

        # Validate the app.
        # =================
        # We use zope interfaces, although your app needn't implement zope
        # interfaces explicitly.

        try:
            verifyObject(Iapp, app, tentative=True)
        except:
            logger.debug("app in %s is not valid." % app_fs_root)
            raise
        try:
            verifyClass(IApp, app.App, tentative=True)
        except:
            logger.debug("app.App in %s is not valid." % app_fs_root)
            raise

        return self._instantiate_App(app_fs_root, app.App)


    def _instantiate_App(self, app_fs_root, App):
        """Given a path and an App class, return an instance.

        This is factored out because we want to add some runtime API before
        instantiating, and we want to instantiate in a couple places.

        """

        # Paths
        # =====

        if app_fs_root == self.config.__:
            app_uri_root = '/'
            app_fs_root = self.config.root
        else:
            app_uri_root = app_fs_root[len(self.config.root):]
            app_uri_root = app_uri_root.replace(os.sep, '/')
            if not app_uri_root:
                app_uri_root = '/'

        App.site_root = self.config.root
        App.uri_root = app_uri_root
        App.fs_root = app_fs_root
        App.__ = self.config.__


        # Mode
        # ====

        App.debug_mode = self.debug_mode
        App.deploy_mode = self.deploy_mode
        App.devel_mode = self.devel_mode

        return App()


    def get_app(self, request):
        """Translates request.path to app.uri_path
        """

        app = None
        for _app in self.apps:
            if request.path.startswith(_app.uri_root):
                app = _app
                break
        if app is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Response(400)

        logger.debug("Using %s for this request." % app)
        return app

