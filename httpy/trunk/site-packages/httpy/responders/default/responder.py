import imp
import inspect
import logging
import os
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.interface.verify import verifyObject, verifyClass

from httpy import Response
from httpy.responders import Static
from httpy.interfaces import IResponder
from httpy.responders.default.interfaces import Iresponder, IResponder, IFramework


logger = logging.getLogger('httpy.responder.default')


class DefaultFramework:
    """Pass-through. See IFramework for details.
    """

    implements(IFramework)

    def wrap_request(self, request):
        return request

    def unwrap_response(self, response):
        return response


class CustomResponse(StandardError):
    """Mixin for custom IResponses.

    This is a signal to the try/except machinery in the master Responder that it
    should apply the outbound framework hook.

    """


class Responder: #, responders.Script):
    """This default responder infers a site from your filesystem.
    """

    implements(IResponder)

    def __init__(self):

        # Set paths.
        # ==========

        self.root = os.getcwd()
        self.__ = os.path.join(self.root, '__')
        if not os.path.exists(self.__):
            self.__ = None


        # Look for a custom site-packages and stick it in the path.
        # =========================================================
        # We support __/site-packages, __/lib, and __ for a custom packages
        # directory, in that order. We always remember the magic directory.

        site_packages = os.path.join(self.root, 'site-packages')
        lib = os.path.join(self.root, '__', 'lib')
        __ = self.__
        __site_packages = os.path.join(self.root, '__', 'site-packages')
        __lib = os.path.join(self.root, '__', 'lib')

        for path in (site_packages, lib, __site_packages, __lib, __):
            if os.path.isdir(path):
                sys.path.insert(0, path)
                break


        # Find findables.
        # ===============

        self.framework = self.get_framework()
        self.responders = self.get_responders()



    # Contracts
    # =========

    def respond(self, request):
        """Given a Request, raise an IResponse.

        This is where we insert our framework hooks.

        """

        request = self.framework.wrap_request(request)
        responder = self.get_responder(request)

        try:
            responder.respond(request)
        except (Response, CustomResponse), response:
            raise self.framework.unwrap_response(response)
        except:
            raise


    def stop(self):
        """Close down all responders.
        """
        for responder in self.responders:
            if hasattr(responder, 'close') and inspect.ismethod(responder.close):
                logger.debug("closing %s" % responder)
                responder.close()
            else:
                logger.debug("%s provides no close method" % responder)



    # Helpers
    # =======

    def get_framework(self):
        """Return an IFramework.

        We look in __, then in .. We add a couple API niceties before
        returning.

        """

        # Find a framework.
        # =================

        paths = [self.__, self.root]
        try:
            logger.debug("loading framework ...")
            fp, pathname, description = imp.find_module('framework', paths)
            framework = imp.load_module('framework', fp, pathname, description)
        except ImportError:
            logger.warning("framework import failed:\n" +
                           traceback.format_exc())
            logger.info("falling back to passthrough")
            framework = DefaultFramework


        # Add API and return.
        # ===================

        framework.__ = self.__
        framework.root = self.root

        return framework()


    def get_responders(self):
        """Return a sequence of responder instances.

        Any properly-formed responder.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no responder.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no
        responder.py is found there, then we fall back to Static.

        """

        # Walk the tree rooted in root and load responders.
        # =================================================

        responders = []
        need_default = True
        for path, dirs, files in os.walk(self.root):
            if '.svn' in dirs:
                dirs.remove('.svn')
            if '__' in dirs:
                dirs.remove('__')
            if 'site-packages' in dirs:
                dirs.remove('site-packages')
            dirs = sorted(dirs)
            if 'responder.py' in files:
                responders.append(self.load_responder(path))
                if path == self.root:
                    need_default = False
        responders.reverse()


        # Make sure we have a responder for /.
        # ====================================

        if need_default:
            if self.__ is not None:
                if 'responder.py' in os.listdir(self.__):
                    responders.append(self.load_responder(self.__))
                    need_default = False

        if need_default:
            self.add_api(Static)
            responders.append(Static())

        return responders


    def load_responder(self, root_fs):
        """Given a responder's filesystem root, return an instance.

        Each responder is imported under the root_fs so that they don't
        collide in sys.modules.

        """

        logger.debug("loading responder from %s" % root_fs)
        try:
            fp, path, description = imp.find_module('responder', [root_fs])
            responder = imp.load_module(root_fs, fp, path, description)
        except ImportError:
            raise ImportError("unable to import responder from " +
                              "%s: \n%s" % ( root_fs
                                           , traceback.format_exc()
                                            ))

        # Validate the responder.
        # =======================
        # We use zope interfaces, although your responder needn't implement
        # them explicitly.

        try:
            verifyObject(Iresponder, responder, tentative=True)
        except:
            logger.debug("responder in %s is not valid." % root_fs)
            raise
        try:
            verifyClass(IResponder, responder.Responder, tentative=True)
        except:
            logger.debug( "responder.Responder in %s " % root_fs +
                          "is not valid."
                          )
            raise

        self.add_api(responder.Responder, root_fs)
        return responder.Responder()


    def add_api(self, Responder, root_fs=None):
        """Given a class and a filesystem path, return the class.

        This is factored out because we want to add some runtime API before
        instantiating, and we want to instantiate in a couple places.

        """

        root_fs = root_fs or self.root

        api = {}
        api['root_fs_site'] = self.root
        api['__'] = self.__

        if root_fs == self.__:         # responder.py from the magic directory
            api['root_uri'] = '/'
            api['root_fs'] = self.root
        else:                         # responder.py from within the site tree
            root_uri = root_fs[len(self.root):]
            root_uri = root_uri.replace(os.sep, '/')
            if not root_uri:
                root_uri = '/'
            api['root_uri'] = root_uri
            api['root_fs'] = root_fs

        for key, val in api.items():
            if not hasattr(Responder, key):
                setattr(Responder, key, val)


    def get_responder(self, request):
        """Given a request, return a responder.

        We translate request.path to the filesystem, and do some validation.

        """

        # Match a responder based on URI root.
        # ====================================

        responder = None
        for _responder in self.responders:
            if request.path.startswith(_responder.root_uri):
                responder = _responder
                break
        if responder is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Response(400)

        logger.debug("Using %s for this request." % responder)


        # Make sure it still exists on the filesystem.
        # ============================================

        if not os.path.isdir(responder.root_fs):
            log.error( "Filesystem root has disappeared for responder " +
                       "'%s'" % responder
                      )
            raise Response(500)

        if responder.__:
            if not os.path.isdir(responder.__):
                log.error( "Magic directory has disappeared for responder " +
                           "'%s'" % responder
                          )
            raise Response(500)

            # Protect the magic directory from direct access.
            # ??? -- but make sure we can serve a default responder.py from there.
            if request.path.startswith('/__'):
                #responder_py = os.path.join(responder.__, 'responder.py')
                #if not resource_fs_path == responder_py:
                raise Response(400)


        return responder

