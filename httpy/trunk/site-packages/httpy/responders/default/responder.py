import imp
import inspect
import logging
import os
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.interface.exceptions import Invalid
from httpy._zope.interface.verify import verifyObject, verifyClass

from httpy import Response, utils
from httpy.responders import Static
from httpy.interfaces import IResponder as IBaseResponder
from httpy.responders.default.interfaces import Iresponder, IResponder
from httpy.responders.default.interfaces import Iframework, IFramework


logger = logging.getLogger('httpy.responder.default')


class DefaultFramework:
    """Pass-through. See IFramework for details.
    """

    implements(IFramework)

    def wrap_request(self, responder, request):
        return request

    def unwrap_response(self, responder, response):
        return response


class CustomResponse(StandardError):
    """Mixin for custom IResponses.

    This is a signal to the try/except machinery in the master Responder that it
    should apply the outbound framework hook.

    """


class Responder:
    """This default responder infers a site from your filesystem.
    """

    implements(IBaseResponder)

    def __init__(self):

        # Set paths.
        # ==========

        self.root = os.getcwd()
        self.__ = os.path.join(self.root, '__')
        if not os.path.exists(self.__):
            self.__ = None


        # Find findables.
        # ===============

        self.framework = self.get_framework()
        self.responders = self.get_responders()



    # Contracts
    # =========

    def respond(self, request):
        """Given a Request, raise an IResponse.

        This is where we insert our framework hooks.

        """

        responder = self.get_responder(request)
        request = self.framework.wrap_request(responder, request)

        try:
            responder.respond(request)
        except (Response, CustomResponse), response:
            raise self.framework.unwrap_response(responder, response)
        except:
            raise


    def stop(self):
        """Close down all responders.
        """
        for responder in self.responders:
            if hasattr(responder, 'close') and inspect.ismethod(responder.close):
                logger.debug("closing %s" % responder)
                responder.close()
            else:
                logger.debug("%s provides no close method" % responder)



    # Helpers
    # =======

    def get_framework(self):
        """Return an IFramework.

        We look in __, then in .. We add a couple API niceties before
        returning.

        """

        # Find a framework.
        # =================

        paths = [self.__, self.root]
        try:
            logger.debug("loading framework ...")
            fp, pathname, description = imp.find_module('framework', paths)
            framework = imp.load_module('framework', fp, pathname, description)
        except ImportError:
            logger.warning("framework import failed:\n" +
                           traceback.format_exc())
            logger.info("falling back to passthrough")
            framework = DefaultFramework
            pathname = '<default>'


        # Validate it.
        # ============
        # We use zope interfaces, although your framework needn't implement
        # them explicitly. Allow both module and class frameworks.

        try:                                             # framework.Framework

            verifyObject(Iframework, framework, tentative=True)

            try:
                framework = framework.Framework
                verifyClass(IFramework, framework, tentative=True)
            except Invalid:
                logger.debug( "framework.Framework at '%s' " % pathname +
                              "is not valid."
                              )
                raise

        except Invalid:                                            # framework

            try:
                verifyObject(IFramework, framework, tentative=True)
            except:
                logger.debug("framework at '%s' is not valid." % pathname)
                raise


        # Add API and return.
        # ===================

        framework.__ = self.__
        framework.root = self.root
        if inspect.isclass(framework):
            framework = framework()
        return framework


    def get_responders(self):
        """Return a sequence of responder instances.

        Any properly-formed responder.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no responder.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no
        responder.py is found there, then we fall back to Static.

        """

        # Walk the tree rooted in root and load responders.
        # =================================================

        responders = []
        need_default = True
        for path, dirs, files in os.walk(self.root):

            do_not_enter = ('.svn', 'site-packages', 'lib')
            for name in do_not_enter:
                if name in dirs:
                    # Skip some directories.
                    dirs.remove(name)

            if os.path.basename(path) == '__':
                # Never recurse into subdirectories of __.
                dirs = []

            dirs = sorted(dirs)

            if '__' in dirs:
                if 'responder.py' in os.listdir(os.path.join(path, '__')):
                    # A responder in <path>/__ trumps one in <path>.
                    continue

            if 'responder.py' in files:
                # Found one!
                responders.append(self.load_responder(path))
                if path in (self.root, self.__):
                    need_default = False

        responders.reverse()


        # Make sure we have a responder for / before returning.
        # =====================================================

        if need_default:
            self.add_api(Static, self.root)
            responders.append(Static())

        return responders


    def load_responder(self, root):
        """Given a responder's filesystem root, return an instance.

        Each responder is imported under the root_fs so that they don't collide
        in sys.modules. We also insert exactly one of the following paths into
        sys.path; the first one that exists is chosen:

            1. rootfs/site-packages/
            2. rootfs/lib/
            3. rootfs/

        """

        logger.debug("loading responder from %s" % root)
        try:
            fp, path, description = imp.find_module('responder', [root])
            responder = imp.load_module(root, fp, path, description)
        except ImportError:
            raise ImportError("unable to import responder from " +
                              "%s: \n%s" % ( root
                                           , traceback.format_exc()
                                            ))

        # Validate the responder.
        # =======================
        # We use zope interfaces, although your responder needn't implement
        # them explicitly. Allow both module and class responders.

        try:                                   # responder.Responder.respond()

            verifyObject(Iresponder, responder, tentative=True)

            try:
                responder = responder.Responder
                verifyClass(IBaseResponder, responder, tentative=True)
            except Invalid:
                logger.debug( "responder.Responder in %s " % root +
                              "is not valid."
                              )
                raise

        except Invalid:                                  # responder.respond()

            try:
                verifyObject(IBaseResponder, responder, tentative=True)
            except:
                logger.debug("responder in %s is not valid." % root)
                raise


        # Insert a path into sys.path.
        # ============================
        # If the responder is not from a magic directory, then consider a
        # magic directory for inclusion in sys.path.

        site_packages = os.path.join(root, 'site-packages')
        lib = os.path.join(root, 'lib')
        candidates = [site_packages, lib, root]
        if os.path.basename(root) != '__':
            candidates.insert(2, os.path.join(root, '__'))

        pkg = None
        for path in candidates:
            if os.path.isdir(path):
                pkg = path
                sys.path.insert(0, path)
                break


        # Add API and return.
        # ===================

        self.add_api(responder, root, pkg)
        if inspect.isclass(responder):
            responder = responder()
        return responder


    def add_api(self, Responder, root, pkg=None):
        """Given a class and a filesystem path, return the class.
        """

        head, tail = os.path.split(root)
        __ = None
        if tail == '__':
            __ = root
            root = head
        else:
            ___ = os.path.join(root, '__')
            if os.path.exists(___):
                __ = ___

        uri = root[len(self.root):]
        uri = uri.replace(os.sep, '/')
        if not uri:
            uri = '/'

        api = {}
        api['site_root'] = self.root
        api['site___'] = self.__
        api['root'] = root
        api['__'] = __
        api['uri'] = uri
        api['pkg'] = pkg

        for key, val in api.items():
            if not hasattr(Responder, key):
                setattr(Responder, key, val)


    def get_responder(self, request):
        """Given a request, return a responder.
        """

        # Match a responder based on the URI path.
        # ========================================

        responder = None
        for _responder in self.responders:
            if request.path.startswith(_responder.uri):
                responder = _responder
                break
        if responder is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Response(400)

        logger.debug("Using %s for this request." % responder)


        # Make sure our paths still exist, but aren't being accessed.
        # ===========================================================

        fs_path = utils.uri_to_fs(request.path, responder.root, raw=True)

        if not os.path.isdir(responder.root):
            log.error( "Filesystem root has disappeared for responder " +
                       "'%s'" % responder
                      )
            raise Response(500)

        if responder.__ is not None:
            if not os.path.isdir(responder.__):
                log.error( "Magic directory has disappeared for responder " +
                           "'%s'" % responder
                          )
                raise Response(500)
            if fs_path.startswith(responder.__):
                raise Response(403)

        if responder.pkg is not None:
            if not os.path.isdir(responder.pkg):
                log.error( "Custom package directory has disappeared for " +
                           "responder '%s'" % responder
                          )
                raise Response(500)
            if fs_path.startswith(responder.pkg):
                raise Response(403)

        return responder

