import inspect
import logging
import os

from httpy import Response
from httpy.responders import Static
from httpy._zope.interface import implements
from httpy.interfaces import IResponder
from httpy.responders.default.interfaces import Iresponder, IResponder, IFramework


logger = logging.getLogger('httpy.responder.default')


class DefaultFramework:
    """Pass-through. See IFramework for details.
    """

    implements(IFramework)

    def wrap_request(self, request):
        return request

    def unwrap_response(self, response):
        return response


class Responder(Static): #, responders.Script):
    """This default responder infers a site from your filesystem.
    """

    implements(IResponder)

    def __init__(self):

        # Set paths.
        # ==========

        self.root = os.getcwd()
        self.__ = os.path.join(self.root, '__')
        if not os.path.exists(self.__):
            self.__ = None


        # Find findables.
        # ===============

        self.framework = self.get_framework()
        self.responders = self.get_responders()



    # Contracts
    # =========

    def respond(self, request):
        """Given a Request, raise an IResponse.
        """
        responder = self.get_responder(request)
        responder.respond(request)


    def stop(self):
        """Close down all responders.
        """
        for responder in self.responders:
            if hasattr(responder, 'close') and inspect.ismethod(responder.close):
                logger.debug("closing %s" % responder)
                responder.close()
            else:
                logger.debug("%s provides no close method" % responder)



    # Find things.
    # ============

    def get_framework(self):
        """Return an IFramework.

        We look in __, then in .. We add a couple API niceties before
        returning.

        """

        # Find a framework.
        # =================

        paths = [self.__, self.root]
        try:
            logger.debug("loading framework ...")
            fp, pathname, description = imp.find_module('framework', paths)
            framework = imp.load_module('framework', fp, pathname, description)
        except ImportError:
            logger.warning("framework import failed:\n" +
                           traceback.format_exc())
            logger.info("falling back to passthrough")
            framework = DefaultFramework


        # Add API and return.
        # ===================

        framework.__ = self.__
        framework.root = self.root

        return framework


    def get_responders(self):
        """Return a sequence of responder instances.

        Any properly-formed responder.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no responder.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no
        responder.py is found there, then we fall back to responders.Static.

        """

        # Walk the tree rooted in root and load responders.
        # =================================================

        classes = []
        need_default = True
        for path, dirs, files in os.walk(self.root):
            if '.svn' in dirs:
                dirs.remove('.svn')
            if '__' in dirs:
                dirs.remove('__')
            dirs = sorted(dirs)
            if 'responder.py' in files:
                responders.append(load_responder(path))
                if path == self.root:
                    need_default = False
        responders.reverse()


        # Make sure we have a responder for /.
        # ====================================

        if need_default:
            if self.__ is not None:
                if 'responder.py' in os.listdir(self.__):
                    responders.append(self.load_responder(self.__))
                    need_default = False

        if need_default:
            add_api(responders.Static)
            responders.append(responders.Static)

        return responders


        def load_responder(root_fs):
            """Given a responder's filesystem root, return an instance.

            Each responder is imported under the root_fs so that they don't
            collide in sys.modules.

            """

            logger.debug("loading responder from %s" % root_fs)
            try:
                fp, path, description = imp.find_module('responder', [root_fs])
                responder = imp.load_module(root_fs, fp, path, description)
            except ImportError:
                raise ImportError("unable to import responder from " +
                                  "%s: \n%s" % ( root_fs
                                               , traceback.format_exc()
                                                ))

            # Validate the responder.
            # =======================
            # We use zope interfaces, although your responder needn't implement
            # them explicitly.

            try:
                verifyObject(Iresponder, responder, tentative=True)
            except:
                logger.debug("responder in %s is not valid." % root_fs)
                raise
            try:
                verifyClass(IApp, responder.Responder, tentative=True)
            except:
                logger.debug( "responder.Responder in %s " % root_fs +
                              "is not valid."
                              )
                raise

            add_api(responder.Responder, root_fs)
            return responder.Responder()


        def add_api(self, Responder, root_fs=None):
            """Given a class and a filesystem path, return the class.

            This is factored out because we want to add some runtime API before
            instantiating, and we want to instantiate in a couple places.

            """

            root_fs = root_fs or self.root

            api = {}
            api['root_fs_site'] = self.root
            api['__'] = self.__

            if root_fs == self.__:         # responder.py from the magic directory
                api['root_uri'] = '/'
                api['root_fs'] = self.root
            else:                         # responder.py from within the site tree
                root_uri = root_fs[len(self.root):]
                root_uri = root_uri.replace(os.sep, '/')
                if not root_uri:
                    root_uri = '/'
                api['root_uri'] = root_uri
                api['root_fs'] = root_fs

            for key, val in api:
                if not hasattr(Responder, key):
                    setattr(Responder, key, val)


        # Look for a custom site-packages and stick it in the path.
        # =========================================================
        # We support __/site-packages, __/lib, and __ for a custom packages
        # directory, in that order. We always remember the magic directory.

        # __ = os.path.join(self.root, '__')
        # site_packages = os.path.join(self.root, '__', 'site-packages')
        # lib = os.path.join(self.root, '__', 'lib')
        #
        # self.__ = None
        # if os.path.isdir(__):
        #     self.__ = __
        #
        # for path in (site_packages, lib, __):
        #     if os.path.isdir(path):
        #         sys.path.insert(0, path)
        #         break



    # Runtime Helpers
    # ===============

    def get_responder(self, request):
        """Given a request, return a responder.

        We translate request.path to the filesystem, and do some validation.

        """

        # Match a responder based on URI root.
        # ====================================

        responder = None
        for _responder in self.responders:
            if request.path.startswith(_responder.uri_root):
                responder = _responder
                break
        if responder is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Response(400)

        logger.debug("Using %s for this request." % responder)


        # Make sure it still exists on the filesystem.
        # ============================================

        if not os.path.isdir(responder.root_fs):
            log.error( "Filesystem root has disappeared for responder " +
                       "'%s'" % responder
                      )
            raise Response(500)


        path = uri_to_fs( self.root
                        , responder.root_fs
                        , responder.root_uri
                        , self.request.path
                        , raw=True
                         )

        if responder.__:
            if not os.path.isdir(responder.__):
                log.error( "Magic directory has disappeared for responder " +
                           "'%s'" % responder
                          )
            raise Response(500)

            if resource_fs_path.startswith(responder.__):
                responder_py = os.path.join(responder.__, 'responder.py')
                if not resource_fs_path == responder_py:
                    raise Response(400)



            # Protect the magic directory from direct access, but make sure we
            # can serve a default responder.py from there.


        return responder


    def uri_to_fs(self, site_root, responder_fs_root, responder_uri_root, resource_uri_path,
                  defaults=[], raw=False):
        """Map a requested URI to the filesystem.

        Takes a few paths, a list of filenames which should be considered default
        resources, and a flag indicating whether to return the path before doing any
        validation or defaults.

        The URI path is taken to be rooted literally in the filesystem root (which
        could be a site root or a responder root). If it points to a directory,
        we look for a default resource if any are named. If it points to a file, we
        make sure the file exists.

        This method can raise the following Responses:

            301 Moved Permanently
            400 Bad Request
            403 Forbidden
            404 Not Found

        If successful, we return the filesystem path to the particular resource.

        """

        logger = logging.getLogger('httpy.utils.uri_to_fs')


        # Knit the requested URI onto the responder root.
        # =================================================

        if responder_fs_root == site_root:
            _parts = resource_uri_path.lstrip('/').split('/')
        else:
            uri_below_responder = resource_uri_path[len(responder_uri_root):]
            _parts = uri_below_responder.lstrip('/').split('/')

        _parts.insert(0, responder_fs_root)
        resource_fs_path = os.sep.join(_parts)
        resource_fs_path = os.path.realpath(resource_fs_path)


        if raw:
            return resource_fs_path



