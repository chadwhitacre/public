from StringIO import StringIO
from email.Message import Message

from httpy._zope.server.adjustments import default_adj

#from httpy.couplers.standalone.config import Config
from httpy.couplers.standalone.request import ZopeRequest
from httpy.couplers.standalone.task import Task


class StubServer:
    def __init__(self):
        self.http_version_string = "HTTP/1.0"
        self.response_header = "stub server"
        self.config = Config(['-rroot'])
        self.debug_mode = False
        self.deploy_mode = True
        self.devel_mode = False


class StubChannel(StringIO):
    def __init__(self):
        self.server = StubServer()
        StringIO.__init__(self)
    def close_when_done(self):
        pass


class StubRequest:
    """A stub IRequest provider.
    """

    def __init__(self, **kwargs):

        self.raw = ''
        self.raw_line = ''
        self.raw_headers = ''
        self.raw_body = ''

        self.method = ''
        self.uri = {}
        self.path = ''
        self.headers = Message()

        for name, attr in kwargs.items():
            setattr(self, name, attr)


request = ZopeRequest(default_adj)
request.received("GET / HTTP/1.1\r\n\r\n")


def DUMMY_TASK():
    return Task(StubChannel(), request)


DUMMY_APP = """\
from httpy.Response import Response

class Application:
    def respond(self, request):
        response = Response(200)
        response.headers['content-type'] = 'text/plain'
        response.body = 'Greetings, program!'
        raise response

"""


def REQUEST_PARTS(newline='\r\n'):
    IE_CRAP="\r\n\n\r"
    LINE = "POST http://netloc/path;parameters?query#fragment HTTP/1.1"+newline
    LINE2 = "GET / HTTP/1.1"+newline
    HEADERS = newline.join([
          "Host: josemaria:5370"
        , "User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.10) Gecko/20050716 Firefox/1.0.6"
        , "Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5"
        , "Accept-Language: en-us,en;q=0.7,ar;q=0.3"
        , "Accept-Encoding: gzip,deflate"
        , "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        , "Keep-Alive: 300"
        , "Connection: keep-alive"
        , "Referer: http://www.zetadev.com/tmp/test.html"
        , "Content-Type: application/x-www-form-urlencoded"
        , "Content-Length: 8"
        , newline
         ])
    HEADERS2 = newline.join([
          "Host: josemaria:5370"
        , "User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.10) Gecko/20050716 Firefox/1.0.6"
        , "Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5"
        , "Accept-Language: en-us,en;q=0.7,ar;q=0.3"
        , "Accept-Encoding: gzip,deflate"
        , "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        , "Keep-Alive: 300"
        , "Connection: keep-alive"
        , "Referer: http://www.zetadev.com/tmp/test.html"
        , newline
         ])
    BODY = "foo=test"
    POST = IE_CRAP+LINE+HEADERS+BODY
    GET = IE_CRAP+LINE2+HEADERS2
    return (IE_CRAP,LINE,LINE2,HEADERS,HEADERS2,BODY,POST,GET)


def neuter_traceback(tb):
    """Given a traceback, return just the system-independent lines.
    """
    tb_list = tb.split(os.linesep)
    if not tb_list[-1]:
        tb_list = tb_list[:-1]
    neutered = []
    for i in range(0,len(tb_list),2):
        neutered.append(tb_list[i])
    neutered.append(tb_list[-1])
    return os.linesep.join(neutered)


from email import message_from_string

# MIME equality functions
# =======================
# These were too hard to add to email.Message.Message


class NotEqual(StandardError):
    """
    """

def mime__eq__(a, b):
    """Given two MIME messages as strings, compare them for equality.

    MIME messages are equal if they have the same headers (case- and order-
    insensitive), and the same body.

    Currently only implemented for single-part messages.

    """
    msg1 = message_from_string(a)
    msg2 = message_from_string(b)

    try:
        hdrs1 = sorted([(k.lower(), v) for k,v in msg1.items()])
        hdrs2 = sorted([(k.lower(), v) for k,v in msg2.items()])
        if hdrs1 != hdrs2:
            raise NotEqual
        if hdrs1.get_payload() != hdrs2.get_payload():
            raise NotEqual
    except NotEqual:
        return False
    else:
        return True

def mime__ne__(a, b):
    return not mime__eq__(a, b)
