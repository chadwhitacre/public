from os import fstat
from threading import Lock


NOT_INITIALIZED = object()


class Entry(object):
    """A cache entry, mostly an internal object.
    """
    def __init__(self,key):
        object.__init__(self)
        self._key=key
        self._value=NOT_INITIALIZED
        self._lock=Lock()


class Cache(object):
    """An abstract, multi-threaded cache.
    """

    def __init__(self,max_size=0):
        """Builds a cache with a limit of max_size entries.

        If the limit is exceeded, the Least Recently Used entry is discarded. If
        max_size==0, the cache is unbounded (no LRU rule is applied).

        """

        object.__init__(self)
        self._maxsize=max_size
        self._dict={}
        self._lock=Lock()

        # Header of the access list
        if self._maxsize:
            self._head=Entry(None)
            self._head._previous=self._head
            self._head._next=self._head


    def __setitem__(self, name, value):
        """Populates the cache with a given name and value.
        """

        self._lock.acquire()
        try:
            key = self.key(name)
            entry = self._dict.get(key)
            if not entry:
                entry = Entry(key)
                self._pack(entry,value)
                self._dict[key]=entry
                if self._maxsize:
                    entry._next = entry._previous = None
                    self._access(entry)
                    self._checklru()
            else:
                entry._lock.acquire()
                try:
                    self._pack(entry,value)
                    if self._maxsize:
                        self._access(entry)
                finally:
                    entry._lock.release()
            self.commit()
        finally:
            self._lock.release()


    def __getitem__(self, name):
        """Gets a value from the cache, building it if required.
        """

        self._lock.acquire()
        try:
            key = self.key(name)
            entry = self._dict.get(key)
            if not entry:
                entry = Entry(key)
                self._dict[key]=entry
                if self._maxsize:
                    entry._next = entry._previous = None
                    self._access(entry)
                    self._checklru()
            elif self._maxsize:
                self._access(entry)
        finally:
            self._lock.release()

        entry._lock.acquire()
        try:
            value = self._unpack(entry)
            if value is NOT_INITIALIZED:
                opened = self.check(name,entry)
                value = self.build(name,opened,entry)
                self._pack(entry,value)
                self.commit()
            else:
                opened = self.check(name,entry)
                if opened is not None:
                    value = self.build(name,opened,entry)
                    self._pack(entry,value)
                    self.commit()
            return value
        finally:
            entry._lock.release()


    def __delitem__(self,key):
        self._lock.acquire()
        try:
            key = self.key(key)
            del self._dict[key]
        finally:
            self._lock.release()


    def mru(self):
        """Returns the Most Recently Used key.
        """
        if self._maxsize:
            self._lock.acquire()
            try:
                return self._head._previous._key
            finally:
                self._lock.release()
        else:
            return None


    def lru(self):
        """Returns the Least Recently Used key.
        """
        if self._maxsize:
            self._lock.acquire()
            try:
                return self._head._next._key
            finally:
                self._lock.release()
        else:
            return None


    def clear(self):
        """Clear the cache.
        """
        self._lock.acquire()
        try:
            self._dict.clear()
            if self._maxsize:
                self._head._next=self._head
                self._head._previous=self._head
        finally:
            self._lock.release()


    # Hooks
    # =====
    # Override these in your subclass.

    def key(self, name):
        """A hook into dictionary access.

        Override this method to extract a key from the name passed to the []
        operator.

        """
        return name


    def commit(self):
        """A hook into dictionary modification.

        Override this method if you want to do something each time the
        underlying dictionary is modified (e.g. make it persistent).

        """
        pass


    def check(self, name, entry):
        """A hook into determination of whether an entry is stale.

        Return None if it is fresh or an opened resource if it is stale. The
        object returned will be passed to the 'build' method as the 'opened'
        parameter. Use the 'entry' parameter to store meta-data if required.
        Don't worry about multiple threads accessing the same name, as this
        method is properly isolated.

        """
        return None


    def build(self, name, opened, entry):

        """Build the cached value with the given name from the given opened
        resource. Use entry to obtain or store meta-data if needed. Don't worry
        about multiple threads accessing the same name, as this method is
        properly isolated.

        """
        raise NotImplementedError()


    # Internal Methods
    # ================
    # These must each be invoked within a cache lock.

    def _access(self,entry):
        """Updates the access list.
        """
        if entry._next is not self._head:
            if entry._previous is not None:
                # remove the entry from the access list
                entry._previous._next=entry._next
                entry._next._previous=entry._previous
            # insert the entry at the end of the access list
            entry._previous=self._head._previous
            entry._previous._next=entry
            entry._next=self._head
            entry._next._previous=entry
            if self._head._next is self._head:
                self._head._next=entry


    def _checklru(self):
        """Removes the LRU entry if needed.
        """
        if len(self._dict)>self._maxsize:
            lru=self._head._next
            lru._previous._next=lru._next
            lru._next._previous=lru._previous
            del self._dict[lru._key]


    def _pack(self,entry,value):
        """Store the value in the entry.
        """
        entry._value=value


    def _unpack(self, entry):
        """Recover the value from the entry.

        This returns NOT_INITIALIZED if it is not OK.

        """
        return entry._value





class FileCache(Cache):
    """A file cache.

    Returns the content of the files as a string, given their filename. Whenever
    the files are modified (according to their modification time) the cache is
    updated. Override the build method to obtain more interesting behaviour.

    """

    def __init__(self, max_size=0, mode='rb'):
        Cache.__init__(self, max_size)
        self.mode=mode

    def check(self, name, entry):
        """Determine whether a file has changed or not.
        """

        f = file(name, self.mode)
        fs = fstat(f.fileno())
        ts1 = fs[-2]
        try:
            ts2 = entry._timestamp
        except AttributeError:
            ts2 = ts1-1

        if ts2<ts1:
            entry._timestamp=ts1
            return f
        else:
            return None

    def build(self, name, opened, entry):
        """Return the content of the file as a string.

        Override this for better behaviour.

        """
        try:
            return opened.read()
        finally:
            opened.close()


class Module(object):
    """ Placeholder object for the module definition. """
    def __init__(self,filename):
        self.__file__=filename

    def __repr__(self):
        return '<%s object at 0x%08x from %s>'%(type(self).__name__,id(self),self.__file__)



class ModuleCache(FileCache):
    """ A module cache. Give it a file name, it returns a module-like object
        which results from the execution of the Python script it contains.
    """
    def __init__(self,max_size=0):
        FileCache.__init__(self,max_size,'r')

    def build(self,name,opened,entry):
        try:
            module = Module(name)
            exec opened in module.__dict__
            return module
            # I used to use imp.load_source but right now I'm trying the stuff above
            # return imp.load_source(re.sub('\W','_',name),name,opened)
        finally:
            opened.close()
