import imp
import os
import traceback

from httpy import DefaultApp
from httpy.interfaces import IApp, IApplication
from httpy._zope.interface.verify import verifyClass, verifyObject


class ConfigError(StandardError):
    pass



class Application:
    """Represents an httpy application's configuration. API:

        uri_root    The application's root in URL-space
        fs_root     The application's root on the filesystem
        __          The application's magic directory on the filesystem
        module      The Python module defining the application

    """

    uri_root    = '<empty>'
    fs_root     = '<empty>'
    __          = '<empty>'
    module      = None


    def __init__(self, site_root, app_uri_root):
        """Takes the site's filesystem root and the app's URL-space root.
        """

        msg = ("Found bad app `%s'. Each app must be a path rooted in the " +
               "website root, and it must have a subdirectory named __.")


        # Find the app's filesystem root.
        # ===============================

        _parts = [p for p in app_uri_root.lstrip('/').split('/') if p]
        _parts.insert(0, site_root)
        fs_root = os.sep.join(_parts)
        if not os.path.isdir(fs_root):
            raise ConfigError(msg % fs_root)


        # Find the app's magic directory.
        # ===============================

        __ = os.path.join(fs_root, '__')
        if not os.path.isdir(__):
            if fs_root == site_root:
                __ = None # special case
            else:
                raise ConfigError(msg % fs_root)


        # Load the actual module.
        # =======================

        module = self._load_module(__, app_uri_root)


        # Save
        # ====

        self.uri_root   = app_uri_root
        self.fs_root    = fs_root
        self.__         = __
        self.module     = module


    def __repr__(self):
        if self.__ is None:
            return "<default httpy app @ / >"
        return "<httpy app @ %s >" % self.uri_root
    __str__ = __repr__

    def _load_module(self, __, name):
        """Given a magic directory, return a module.

        We support automatically falling back to DefaultApp for the root
        directory. Otherwise, we fail if there is no importable app. We also
        validate the app using zope interfaces. Your app needn't implement zope
        interfaces explicitly, however.

        """

        if __ is None:
            app = DefaultApp
        else:
            try:
                fp, pathname, description = imp.find_module('app', [__])
                app = imp.load_module(name, fp, pathname, description)
            except ImportError:
                raise ConfigError("Unable to import an app from " +
                                  "%s: \n%s" % (__, traceback.format_exc()))

        verifyObject(IApp, app, tentative=True)
        verifyClass(IApplication, app.Application, tentative=True)

        return app


