import __builtin__
import os
import sys
import threading
import time


class reloader:
    """Mess with the import process to dynamically reload changed modules.

    When a module changes, you first reload that module, then you reload any
    modules that use that module.


    We track the order in which modules are imported. If a module changes, we
    reload that module and then all other modules, reverse-order going up,
    forward-order going down.


    """


    dependents = None   # index of modules to the modules that import them
    mtimes = None       # index of modules to modification times

    def __init__(self):
        self.dependents = {}
        self.mtimes = {}


    # Public Interface
    # ================

    def install(self):
        self.__import__ = __builtin__.__import__
        __builtin__.__import__ = self._import
        self.monitor = threading.Thread(target=self._monitor)
        self.monitor.setDaemon(True)
        self.monitor.start()

    def uninstall(self):
        raise NotImplementedError


    # Real Work
    # =========

    def _import(self, name, globs, locs, fromlist):
        """Extend __import__ to track import dependencies.
        """


        imported = self.__import__(name, globs, locs, fromlist)

        if hasattr(imported, '__file__'): # it makes sense to track this module

            depfn = sys._getframe(1).f_code.co_filename
            dependent = None
            for name, module in sys.modules.items():
                if hasattr(module, '__file__'):
                    if module.__file__ == depfn:
                        dependent = (name, module)
                        break

            if dependent is not None:
                if imported not in self.dependents:
                    self.dependents[imported] = [dependent]
                else:
                    self.dependents[imported].append(dependent)

        return imported


    def _monitor(self):
        """Track changes on the filesystem and reload modules as appropriate.
        """

        while 1:

            time.sleep(0.1)

            if not self.dependents: # not initialized yet
                continue

            for module in self.dependents:

                filename = module.__file__
                if filename.endswith('.pyc'):
                    filename = filename[:-1]


                # The file may have been removed from the filesystem.
                # ===================================================
                # Remove from both of our indices and sys.modules, and reload
                # dependent modules.

                if not os.path.isfile(filename):
                    if filename in self.mtimes:                 # mtimes
                        del self.mtimes[filename]
                    for name, mod in sys.modules.items():       # sys.modules
                        if mod is module:
                            del sys.modules[name]
                    for name, mod in self.dependents[module]:   # dependents
                        self._reload(mod)
                    del self.dependents[module]


                # Or not.
                # =======

                mtime = os.stat(filename).st_mtime
                if filename not in self.mtimes:
                    self.mtimes[filename] = mtime
                    continue
                if mtime > self.mtimes[filename]:
                    print "reloading %s" % filename
                    self.mtimes[filename] = mtime
                    self._reload(module)



    def _reload(self, module):
        """Given a module, reload it and all of its dependents.
        """
        print >> sys.stderr, 'reloading %s' % str(module)
        dependents = self.dependents[module]
        del self.dependents[module]
        reload(module)
        for name, module in dependents:
            self._reload(module)


reloader = reloader()




if __name__ == '__main__':
    reloader.install()
    import sys
    import sys