import imp
import os
import sys
import traceback
from SocketServer import StreamRequestHandler

import httpy.app
from httpy import log
from httpy.Request import Request
from httpy.Response import Response


FAILURE = """\
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    %s
</body>"""


class Handler(StreamRequestHandler):

    def handle(self):

        try:
            log(95, "Attempting to handle a request.")
            self.config = self.server.config.copy()
            self.request_ = Request(self.rfile)
            self.handle_unsafely()
        except Response, response:
            self.end(response)
        except:
            self.fail()


    def handle_unsafely(self):
        """Execute one transaction.

        Transaction.process must raise an Ending or other exception.

        """
        Transaction = self.get_transaction()
        transaction = Transaction(self.config, self.request_)
        transaction.process()


        # If we get this far, it means that Transaction.process did not raise an
        # Ending. Bad process! No soup for you!

        raise Endings.InternalServerError


    def get_transaction(self):
        """Given a config dict and an httpy.Request, return a Transaction.

         - import based on uri path and app/server root
         - in deployment mode, don't reimport
         - in development mode, reimport on every request
         - app-layer configuration should be optional

        """


        # If we are in development mode, refresh all modules.
        # ===================================================

        if self.config['mode'] == 'development':
            "http://pyunit.sourceforge.net/notes/reloading.html"


        # Map the requested path to an application. Import it.
        # ====================================================

        app = '/'
        for _app in self.config['apps']:
            if self._request.path.startswith(app):
                app = _app
        app_path = os.path.join(self.config['root'], app[1:])
        app_path = os.path.realpath(app_path)
        if not os.path.isdir(app_path):
            # This can happen if an app is removed after httpy is started.
            raise Response(404)

        app = self.import_app(app_path)


        # Let the application influence configuration if it wants to.
        # ===========================================================

        if not hasattr(app, 'configure'):
            log(92, "Application at %s provides no local " % app_path +
                    "configuration.")
        else:
            log(98, "Found local configuration for application at " +
                    "%s." % app_path)
            self.config = app.configure(self.config)


        return app.Transaction


    def end(self, response):
        log(93, "Attempting to send a response")

        response.code

        self.wfile.write("HTTP/1.1 200 OK\r\n")
        self.wfile.flush()

        for header in response.headers.iteritems():
            self.wfile.write("%s: %s\r\n" % header)
        self.wfile.write("\r\n")
        self.wfile.flush()

        self.wfile.write(response.body)
        self.wfile.flush()


    def fail(self):
        log(90, "Any application-level error-handling has failed for:" +
                traceback.format_exc())
        response = Response(500)
        response.headers = {'Content-Type':'text/plain'}
        if self.config['mode'] == 'development':
            traceback_ = traceback.format_exc()
        else:
            traceback_ = ''
        response.body = FAILURE % traceback_
        self.end(response)


    def import_app(self, app_path):
        """Given a filesystem path, import an app if possible.

        The following conditions must be met, otherwise we fall back to
        httpy.app:

            - The directory at app_path must have a subdirectory named `__'.
            - There must be a module `app.py', or a package `app', in `__'.
            - The app module/package must have a `Transaction' attribute.
            - app.Transaction must have a callable at `process'.


        This method is adapted from the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        __ = os.path.join(app_path, '__')
        if not os.path.isdir(__):
            log(95, "No magic directory found at %s. Falling back " % __ +
                    "to httpy.app")
            return httpy.app
        else:
            log(98,"Found magic directory at %s; will look for app." % __)


        # Fast path: see if the module has already been imported.
        try:
            return sys.modules['app']
        except KeyError:
            pass

        try:
            fp, pathname, description = imp.find_module('app', [app_path])
            app = imp.load_module('app', fp, pathname, description)
        except ImportError:
            log(90, "Unable to import app from %s. " % app_path +
                    "Falling back to httpy.app.")
            return httpy.app

        if not hasattr(app, 'Transaction'):
            log(90, "Unable to import Transaction from app at " +
                    "%s. Falling back to httpy.app." % app_path)
            return httpy.app

        if not hasattr(app.Transaction, 'process'):
            log(90, "The app.Transaction in %s does not have " % app_path)
                    "a `process' method. Falling back to httpy.app."
            return httpy.app

        if not callable(app.Transaction.process):
            log(90, "app.Transaction.process from %s is not " % app_path)
                    "callable. Falling back to httpy.app."
            return httpy.app

        return app


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
