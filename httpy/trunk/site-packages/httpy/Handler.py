import imp
import os
import sys
import traceback
from SocketServer import StreamRequestHandler

import httpy.app
from httpy import log
from httpy.Request import Request
from httpy.Response import Response
from httpy.Response import STATUS_CODES


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""


class Handler(StreamRequestHandler):

    def handle(self):

        try:
            self.handle_unsafely()
        except Response, response:
            self.end(response)
        except:
            self.fail()


    def handle_unsafely(self):
        """Execute one transaction.

        Transaction.process is expected to raise a Response or other exception.

        """

        log(98, "Received a request.")
        self.request_ = Request(self.rfile)
        log(94, "Successfully parsed a request: %s" % self.request_.path)

        self.config = {}
        self.config['mode'] = self.server.config['mode']
        self.config['verbosity'] = self.server.config['verbosity']

        self.transaction = self.get_transaction()
        log(98, "Successfully instantiated a transaction.")
        self.transaction.process(self.request_)


        # If we get this far, it means that Transaction.process did not raise
        # anything. Bad method! No soup for you!

        log(90, "%s.process did not raise anything." % str(self.transaction))
        raise Response(500)


    def end(self, response):
        try:
            self.end_unsafely(response)
        except:
            self.fail()


    def end_unsafely(self, response):

        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase = STATUS_CODES.get(response.code)[0]
        status_line = "%s %s %s\r\n" % ( self.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.wfile.write(status_line)
        self.wfile.flush()


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            # There are too many variables for us to guess here.
            # Setting this header is the application's job.
            headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in response.headers.iteritems():
            self.wfile.write("%s: %s\r\n" % header)

        self.wfile.write("\r\n")
        self.wfile.flush()


        # Output the body.
        # ================

        if self.request_.method != 'HEAD':
            self.wfile.write(response.body)
            self.wfile.flush()

        log(94, "Responded with %d %s" % (response.code, reason_phrase))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 200
                                       , "Internal Server Error"
                                        )

        if self.server.config['mode'] == 'development':
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        self.wfile.write(status_line)
        for header in headers.items():
            self.wfile.write('%s: %s\r\n' % header)
        self.wfile.write('\r\n')
        self.wfile.write(body)


    def get_transaction(self):
        """Return an instance of a Transaction appropriate to the request.

        The following conditions must be met, otherwise we default to
        httpy.app.Transaction:

            - The directory at app_root must have a subdirectory named `__'.
            - There must be a module `app.py', or a package `app', in `__'.
            - The app module/package must have a `Transaction' class.
            - app.Transaction must have a callable named `process'.


        This method started life as the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        # If we are in development mode, refresh all modules.
        # ===================================================
        #
        # if self.config['mode'] == 'development':
        #     "http://pyunit.sourceforge.net/notes/reloading.html"


        app_root, __ = self.get_paths()

        if not __:
            log(95, "No magic directory found at %s. Falling back " % __ +
                    "to httpy.app")
            app = httpy.app
        else:
            log(98, "Found magic directory at %s; will look for app." % __)
            app = None


        if not app:

            # Fast path: see if the module has already been imported.
            try:
                return sys.modules['app']
            except KeyError:
                pass

            try:
                fp, pathname, description = imp.find_module('app', [__])
                app = imp.load_module('app', fp, pathname, description)
            except ImportError:
                log(95, "Unable to import app from %s. " % __ +
                        "Falling back to httpy.app.")
                app = httpy.app

            if not hasattr(app, 'Transaction'):
                log(91, "Unable to import Transaction from app at " +
                        "%s. Falling back to httpy.app." % __)
                app = httpy.app

            if not hasattr(app.Transaction, 'process'):
                log(91, "The app.Transaction in %s does not have " % __ +
                        "a `process' method. Falling back to httpy.app.")
                app = httpy.app

            if not callable(app.Transaction.process):
                log(91, "app.Transaction.process from %s is not " % __ +
                        "callable. Falling back to httpy.app.")
                app = httpy.app


        # Let the application influence configuration if it wants to.
        # ===========================================================
        # But we get the final say on app_root and __.

        if not hasattr(app, 'configure'):
            log(95, "Application at %s provides no local " % __ +
                    "configuration.")
        else:
            log(98, "Found local configuration for application at " +
                    "%s." % app_root)
            self.config = app.configure(self.config)

        self.config['root'] = app_root
        self.config['__'] = __


        # Return an instance of the transaction.
        # ======================================

        log(98, "Found a transaction to use: %s." % str(app.Transaction))
        return app.Transaction(self.config)


    def get_paths(self):
        """Map the requested path to the filesystem.

        This method returns two paths:

            app_root    the root of the application that matches this request
            __          the application's magic directory, or the empty string

        """

        # Find a valid application to use to serve this request.
        # ======================================================

        path = self.request_.path
        app = '/'
        for _app in self.server.config['apps']:
            if path.startswith(app):
                app = _app
        app_root = os.path.join(self.server.config['root'], app[1:])
        app_root = os.path.realpath(app_root)
        path = os.path.join(app_root, path.lstrip('/'))
        path = os.path.realpath(path)

        if not os.path.isdir(app_root):
            # This can happen if an app is removed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(400)


        # Look for a magic directory in the app, and protect it.
        # ======================================================

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            __ = ''
        if __ and path.startswith(__):
            raise Response(404)


        return (app_root, __)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
