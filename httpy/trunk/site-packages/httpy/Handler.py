import imp
import os
import sys
import traceback
from SocketServer import StreamRequestHandler

import httpy.app
from httpy import log
from httpy.Endings import Ending
from httpy.Request import Request
from httpy.Response import Response


class Handler(StreamRequestHandler):

    def handle(self):

        try:
            log(95, "Attempting to handle a request.")
            self.config = self.server.config.copy()
            self._request = Request(self.rfile)
            self.handle_unsafely()
        except Response, response:
            self.end(response)
        except:
            self.fail()


    def handle_unsafely(self):
        """Execute one transaction.

        Transaction.process must raise an Ending or other exception.

        """
        Transaction = self.get_transaction()
        transaction = Transaction(self.config, self._request)
        transaction.process()


        # If we get this far, it means that Transaction.process did not raise an
        # Ending. Bad process! No soup for you!

        raise Endings.InternalServerError


    def get_transaction(self):
        """Given a config dict and an httpy.Request, return a Transaction.

         - import based on uri path and app/server root
         - in deployment mode, don't reimport
         - in development mode, reimport on every request
         - app-layer configuration should be optional

        """


        # If we are in development mode, refresh all modules.
        # ===================================================

        if self.config['mode'] == 'development':
            "http://pyunit.sourceforge.net/notes/reloading.html"


        # Determine which application to use for this request.
        # ====================================================

        app = '/'
        for _app in self.config['apps']:
            if self._request.path.startswith(app):
                app = _app
        app_path = os.path.join(self.config['root'], app[1:])
        app_path = os.path.realpath(app_path)
        if not os.path.isdir(app_path):
            # This can happen if an app is removed after httpy is started.
            raise Endings.NotFound


        # See if our app has a magic directory.
        # =====================================

        __ = os.path.join(app_path, '__')
        if not os.path.isdir(__):
            log(95,"No magic directory found at %s." % __)
            self.config['__'] = ''
        else:
            log(98,"Found magic directory at %s." % __)
            self.config['__'] = __


        # Get the application to use to serve this request.
        # =================================================

        app = self.get_app(app_path)

        if not hasattr(app, 'configure'):
            log(92, "Application at %s provides no local " % app_path +
                    "configuration.")
        else:
            log(98, "Found local configuration for application at " +
                    "%s." % app_path)
            self.config = app.configure(self.config)

        return app.Transaction


    def end(self, response):
        log(93, "Attempting to send a response")

        response.code

        self.wfile.write("HTTP/1.1 200 OK\r\n")
        self.wfile.flush()

        for header in response.headers.iteritems():
            self.wfile.write("%s: %s\r\n" % header)
        self.wfile.write("\r\n")
        self.wfile.flush()

        self.wfile.write(response.body)
        self.wfile.flush()


    def fail(self):
        log(90, "Request failed:")
        print traceback.format_exc()


    def get_app(self, app_path):
        """Given a filesystem path, import an app if possible.

        If not possible, we fall back to httpy.app. This method is adapted from
        the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        NAME = 'app'

        # Fast path: see if the module has already been imported.
        try:
            return sys.modules[NAME]
        except KeyError:
            pass

        try:
            fp, pathname, description = imp.find_module(NAME, [app_path])
            app = imp.load_module(NAME, fp, pathname, description)
        except ImportError:
            log(90, "Unable to import app from %s. " % app_path +
                    "Falling back to httpy.app.")
            app = httpy.app

        if not hasattr(app, 'Transaction'):
            log(90, "Unable to import Transaction from app at " +
                    "%s. Falling back to httpy.app." % app_path)
            app = httpy.app

        return app
