import imp
import os
import sys
import traceback
from SocketServer import StreamRequestHandler

import httpy.app
from httpy import log
from httpy.Request import Request
from httpy.Response import Response
from httpy.Response import STATUS_CODES


FAILURE = """\
<html>
<head>
    <title>Failure</title>
</head>
<body>
    <h1>Failure</h1>
    <p>Error code: 500</p>
    <p>Message: Internal Server Error</p>
    <pre>%s</pre>
</body>
</html>"""


class Handler(StreamRequestHandler):
    """The SocketServer machinery instantiates this for each request.
    """

    def handle(self):

        try:
            self.parse()
            self.configure()
            self.process()
        except Response, response:
            self.end(response)
        except:
            self.fail()


    def parse(self):
        """Parse the request and store it at self.request_.

        We can't use self.request because it is used by a base class,
        SocketServer.BaseRequestHandler.

        """
        log(98, "Received a request.")
        self.request_ = Request(self.rfile)
        log(94, "Successfully parsed a request: %s" % self.request_.path)


    def configure(self):
        """Start building our configuration from the server's config.
        """
        self.config = {}
        self.config['mode'] = self.server.config['mode']
        self.config['verbosity'] = self.server.config['verbosity']
        log(98, "Started building configuration.")


    def process(self):
        """Execute one transaction.

        Transaction.process is expected to raise a Response or other exception.

        """
        self.transaction = self.get_transaction()
        log(98, "Successfully instantiated a transaction.")
        self.transaction.process(self.request_)
        log(90, "%s.process did not raise anything." % str(self.transaction))
        raise Response(500)


    def end(self, response):
        try:
            self.end_unsafely(response)
        except:
            self.fail()


    def end_unsafely(self, response):

        log(96, "Attempting to send a response")
        log(99, "Response lineage as follows:\n%s" % traceback.format_exc())


        # Output the Status-Line.
        # =======================

        if response.code not in STATUS_CODES:
            log(90, "Bad response code: %r" % response.code)
            self.fail()

        reason_phrase = STATUS_CODES.get(response.code)[0]
        status_line = "%s %s %s\r\n" % ( self.server.http_version_string
                                       , response.code
                                       , reason_phrase
                                        )
        self.wfile.write(status_line)
        self.wfile.flush()


        # Output the headers.
        # ===================
        # First we convert all headers to lower case so that we can index them
        # sanely. We then ensure a minimal set of headers, overriding any
        # existing content-length because we don't trust it.

        headers = {}
        for k, v in response.headers.items():
            header = k.lower()
            if header == 'content-length':
                continue
            headers[k] = v

        if 'content-length' not in headers:
            headers['content-length'] = len(response.body)
        if 'content-type' not in headers:
            if not str(response.code).startswith('2'):
                # Error messages default to text/plain.
                headers['content-type'] = 'text/plain'
            else:
                # But setting this header for succesful requests is the
                # application's job.
                headers['content-type'] = 'application/octet-stream'
        if 'server' not in headers:
            headers['server'] = self.server.response_header

        for header in headers.iteritems():
            self.wfile.write("%s: %s\r\n" % header)

        self.wfile.write("\r\n")
        self.wfile.flush()


        # Output the body.
        # ================
        # We don't output the body for 304s or HEAD requests, but we always do
        # for Request parsing errors.

        if response.code == 304:
            pass
        elif not hasattr(self, 'request_'):
            # We are handling an parsing error in Request().
            self.wfile.write(response.body)
        elif self.request_.method != 'HEAD':
            self.wfile.write(response.body)

        self.wfile.flush()
        log(94, "Responded with %d %s" % (response.code, reason_phrase))


    def fail(self):
        """Still return a response in cases of extreme failure.
        """

        log(90, "Critical error:\n%s" % traceback.format_exc())

        status_line = "%s %d %s\r\n" % ( self.server.http_version_string
                                       , 500
                                       , "Internal Server Error"
                                        )

        if self.server.config['mode'] == 'development':
            body = FAILURE % traceback.format_exc()
        else:
            body = FAILURE % ''

        headers = {}
        headers['Content-Type'] = 'text/html'
        headers['Content-Length'] = len(body)


        self.wfile.write(status_line)
        for header in headers.items():
            self.wfile.write('%s: %s\r\n' % header)
        self.wfile.write('\r\n')
        self.wfile.write(body)


    def get_transaction(self):
        """Return an instance of a Transaction appropriate to the request.

        The following conditions must be met, otherwise we default to
        httpy.app.Transaction:

            - The directory at app_root must have a subdirectory named `__'.
            - There must be a module `app.py', or a package `app', in `__'.
            - The app module/package must have a `Transaction' class.
            - app.Transaction must have a callable named `process'.


        This method started life as the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        # If we are in development mode, refresh all modules.
        # ===================================================
        #
        # if self.config['mode'] == 'development':
        #     "http://pyunit.sourceforge.net/notes/reloading.html"


        app_root, __ = self.translate(self.request_.path)

        if not __:
            log(95, "No magic directory found at %s. Falling back " % __ +
                    "to httpy.app")
            app = httpy.app
        else:
            log(98, "Found magic directory at %s; will look for app." % __)
            app = None


        if not app:

            # Fast path: see if the module has already been imported.
            try:
                return sys.modules['app']
            except KeyError:
                pass

            try:
                fp, pathname, description = imp.find_module('app', [__])
                app = imp.load_module('app', fp, pathname, description)
            except ImportError:
                log(95, "Unable to import app from %s. " % __ +
                        "Falling back to httpy.app.")
                app = httpy.app

            if not hasattr(app, 'Transaction'):
                log(91, "Unable to import Transaction from app at " +
                        "%s. Falling back to httpy.app." % __)
                app = httpy.app

            if not hasattr(app.Transaction, 'process'):
                log(91, "The app.Transaction in %s does not have " % __ +
                        "a `process' method. Falling back to httpy.app.")
                app = httpy.app

            if not callable(app.Transaction.process):
                log(91, "app.Transaction.process from %s is not " % __ +
                        "callable. Falling back to httpy.app.")
                app = httpy.app


        # Let the application influence configuration if it wants to.
        # ===========================================================
        # But we get the final say on app_root and __.

        if not hasattr(app, 'configure'):
            log(95, "Application at %s provides no local " % __ +
                    "configuration.")
        else:
            log(98, "Found local configuration for application at " +
                    "%s." % app_root)
            self.config = app.configure(self.config)

        self.config['root'] = app_root
        self.config['__'] = __


        # Return an instance of the transaction.
        # ======================================

        log(98, "Found a transaction to use: %s." % str(app.Transaction))
        return app.Transaction(self.config)


    def translate(self):
        """Map the requested path to the filesystem.

        This method returns two paths:

            app_root    the root of the application that matches this request
            __          the application's magic directory, or None

        """

        # Find an application directory that match the requested URI-path.
        # ================================================================

        app = '/' # The website root is always an implicit application.
        for _app in self.server.config['apps']:
            if path.startswith(app):
                app = _app
        app_root = os.path.join(self.server.config['root'], app[1:])
        app_root = os.path.realpath(app_root)
        path = os.path.join(app_root, path.lstrip('/'))
        path = os.path.realpath(path)

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(400)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            __ = None
        if __ and path.startswith(__):
            raise Response(404)


        return (app_root, __)


"""
TODO

range requests --> app, with handler fallback
keep alive --> handler


"""
