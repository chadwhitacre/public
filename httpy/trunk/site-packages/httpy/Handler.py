import imp
import os
import sys
import traceback
from SocketServer import StreamRequestHandler

import httpy.app
from httpy.Endings import Ending
from httpy.Request import Request
from httpy.Response import Response


class Handler(StreamRequestHandler):

    def handle(self):

        try:
            self.config = self.server.config
            self.handle_unsafely(Request(self.rfile))
        except Ending, ending:
            self.end(ending)
        except:
            self.fail()


    def handle_unsafely(self, request):
        """Execute one transaction.

        Transaction.process must raise an Ending or other exception.

        """
        Transaction = self.get_transaction(self.config.copy(), request)
        transaction = Transaction(request)
        transaction.process()


        # If we get this far, it means that Transaction.process did not raise an
        # Ending. Bad process! No soup for you!

        raise Endings.InternalServerError


    def get_transaction(self, config, request):
        """Given a config dict and an httpy.Request, return a Transaction.

         - import based on uri path and app/server root
         - in deployment mode, don't reimport
         - in development mode, reimport on every request
         - app-layer configuration should be optional

        """


        # If we are in development mode, refresh all modules.
        # ===================================================

        if config['mode'] == 'development':
            "http://pyunit.sourceforge.net/notes/reloading.html"


        # Determine which application to use for this request.
        # ====================================================

        app = '/'
        for _app in config['apps']:
            if request.path.startswith(app):
                app = _app
        app_path = os.path.join(config['root'], app[1:])
        app_path = os.path.realpath(app_path)
        if not os.path.isdir(app_path):
            # This can happen if an app is removed after httpy is started.
            raise Endings.NotFound


        # See if our app has a magic directory.
        # =====================================

        __ = os.path.join(app_path, '__')
        if not os.path.isdir(__):
            config['__'] = ''
        else:
            config['__'] = __


        # Attempt to import the application.
        # ==================================

        app = self.import_app(app_path)

        config = app.configure(config)

        if not hasattr(app, 'Application'):
            raise Exception, "No 'Application' class in %s/app.py" % app_path
        app.Transaction


    def end(self, response):
        print ending


    def fail(self):
        print traceback.format_exc()


    def import_app(self, app_path):
        """Manual import lifted from the docs.
        """

        NAME = 'app'

        # Fast path: see if the module has already been imported.
        try:
            return sys.modules[NAME]
        except KeyError:
            pass

        fp, pathname, description = imp.find_module(NAME, [app_path])

        try:
            app = imp.load_module(NAME, fp, pathname, description)
        except ImportError:
            app = httpy.app
        finally:
            # Since we may exit via an exception, close fp explicitly.
            if fp:
                fp.close()

        if not hasattr(app, 'Transaction'):
            app = httpy.app

        return app
