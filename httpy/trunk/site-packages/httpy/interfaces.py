from httpy._zope.interface import Interface
from httpy._zope.interface import Attribute


__docformat__ = 'rest'
__all__ = ( 'IConfig'
          , 'IRequest'
          , 'IResponder'
          , 'IResponse'
           )


class IConfig(Interface):
    """A configuration object, passed to the Server constructor.

    Note that any mode attribute is not used by Server. Instead, mode should be
    placed in os.environ['HTTPY_MODE'], and accessed from httpy.mode. See
    httpy.utils.mode for details.

    Also, the default Config infers the sockfam from the address.

    """

    address = Attribute( 'address'
                       , "a socket address, the format of which depends on " +
                         "the socket type: if the address begins with a / " +
                         "or ., it is interpreted as an AF_UNIX address " +
                         "(i.e., a path), otherwise it is interpreted as an " +
                         "AF_INET address; AF_INET6 is not supported"
                        )

    threads = Attribute('threads', "the number of worker threads to maintain")

    user = Attribute( 'user'
                    , "the user account to switch to after binding to the " +
                      "socket; this is necessary for httpy to bind to TCP " +
                      "port 80 without continuing as root"
                     )

    sockfam = Attribute('sockfam', "socket.AF_UNIX or socket.AF_INET")


class ICoupler(Interface):
    """Coupler objects put IResponders on the network.
    """

    def __init__(responder, *args, **kwargs):
        """Takes an IResponder.
        """

    def go():
        """Start the coupler.

        For CGI, this means respond to a single request (CGI); for all others,
        listen and respond to multiple requests.

        """


class IRequest(Interface):
    """An HTTP Request message.

        http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html

    This is a wooden representation of a Request, with only the following API:

        attribute       description
        =======================================================================
        raw             the raw Request exactly as it was found on the wire
        raw_line        the Request-Line
        raw_headers     the message headers
        raw_body        the message body

        method          the HTTP method requested
        uri             the full requested URI as a dictionary
        path            the URI path below the responder (the URI path of the
                        responder is available at responder.uri)
        headers         the HTTP message headers as an instance of
                        email.Message.Message, or None if there is no message


    The values of raw_line and raw_headers do not include the terminating
    linebreaks of those items. However, raw includes every byte that was
    received over the wire, so it is possible to retrieve those values. raw
    also includes any initial blank lines.

    """

    raw = Attribute("raw")
    raw_line = Attribute("raw_line")
    raw_headers = Attribute('raw_headers')
    raw_body = Attribute('raw_body')

    method = Attribute('method')
    uri = Attribute('uri')
    path = Attribute('path')
    headers = Attribute('headers')



class IResponder(Interface):
    """Represents an application that wants to talk over HTTP.

    This can be either a module or a class.

    """

    def respond(request):
        """Given an httpy.request.Request, raise an IResponse.

        Other objects than httpy.Response may also be raised; they will generate
        a '500 Internal Server Error' HTTP response.

        """


class IResponse(Interface):
    """An HTTP Response message.

    This is the payload for our overloaded raise statement. ICoupler is
    responsible for catch, validate, and flatten it before writing it to the
    wire.

    """

    def __init__(code_, body, headers):
        """Takes an int, a string, and a dict. Validation is Task's job.

        Body is second in the parameters list to ease debugging:

            raise Response(500, foo)

        This is httpy's print statement: instant output. If headers were second
        it would require more typing. But for non-2xx responses, httpy will
        automatically set the content-type header set to text/plain.

        """

    code = Attribute('code', "An HTTP response code, e.g., 404")
    body = Attribute('body', "The message body as a string")
    headers = Attribute('headers', "A dictionary of HTTP headers")



class IMixin(Interface):
    """A class intended for mixing into a primary httpy responder.

    We want these mixins to function as standalone responders, and play nice
    when, um, mixed in. Any additional members of this class should be privately
    named.

    """

    def respond(request):
        """This method should do nothing besides call self.serve_*
        """

    def serve_something(request):
        """This is where the real work happens.
        """


class ICoupler(Interface):
    """An object that connects Responders to the outside world.
    """

    def __init__(responder, *args, **kwargs):
        """Takes an IResponder, and then whatever else it needs.
        """
