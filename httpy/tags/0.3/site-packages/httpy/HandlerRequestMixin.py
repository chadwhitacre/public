import imp
import os
import sys

import httpy.app
from httpy import log
from httpy.Request import Request
from httpy.Response import Response
from httpy.RollbackImporter import RollbackImporter


class HandlerRequestMixin:
    """This object contains request-side logic for the Handler class.
    """

    rollbackImporter = None


    def parse(self):
        """Parse the request and store it in self.request_.

        We can't use self.request because it is used by a base class,
        SocketServer.BaseRequestHandler.

        """
        log(98, "Received a request.")
        self.request_ = Request(self.rfile)
        log(94, "Successfully parsed a request: %s" % self.request_.path)


    def process(self):
        """Execute one transaction.

        Transaction.process is expected to raise a Response or other exception.

        """
        transaction = self.get_transaction( self.server.config.copy()
                                          , self.request_.path
                                           )
        log(98, "Successfully instantiated a transaction.")
        transaction.process(self.request_)
        log(90, "%s.process did not raise anything." % str(transaction))
        raise Response(500)


    def get_transaction(self, config, uri_path):
        """Return an instance of a Transaction appropriate to the request.

        This method takes a copy of the server's configuration dictionary, and
        the requested URI-path. It then translates the requested URI to one of
        the pre-registered app paths. If the following conditions are met, we
        use a Transaction from the registered app. Otherwise we default to
        httpy.app.Transaction.

            - The directory at app_root must have a subdirectory named `__'.
            - There must be a module `app.py', or a package `app', in `__'.
            - The app module/package must have a `Transaction' class.
            - app.Transaction must have a callable named `process'.

        We could certainly do better validation here: make sure that Transaction
        is a class, and that __init__ and process take the right number of
        arguments, etc.

        FWIW, this method started life as the example at:

            http://www.python.org/doc/2.4.1/lib/examples-imp.html

        """

        # If we are in development mode, refresh all modules.
        # ===================================================
        # We want to see changes made during development without restarting
        # the server.

        if config['mode'] == 'development':
            log(95, "Rolling back imports in development mode.")
            if self.rollbackImporter:
                self.rollbackImporter.uninstall()
            self.rollbackImporter = RollbackImporter()


        # Setup per-request configuration.
        # ================================

        root = config['root']
        apps = config['apps']

        app_root, __  = self.translate(root, apps, uri_path)

        _config = {}
        _config['mode'] = config['mode']
        _config['verbosity'] = config['verbosity']
        _config['root'] = app_root
        _config['__'] = __
        config = _config


        # Find a usable app.
        # ==================
        # We should really keep an app cache on self.server.

        if not __:
            log(95, "No magic directory found in %s. Falling " % app_root +
                    "back to httpy.app")
            app = httpy.app
        else:
            log(98, "Found magic directory at %s; will look for app." % __)
            app = None


        if not app:

            try:
                fp, pathname, description = imp.find_module('app', [__])
                app = imp.load_module('app', fp, pathname, description)
            except ImportError:
                log(95, "Unable to import app from %s. " % __ +
                        "Falling back to httpy.app.")
                app = httpy.app

            if not hasattr(app, 'Transaction'):
                log(91, "Unable to import Transaction from app at " +
                        "%s. Falling back to httpy.app." % __)
                app = httpy.app

            if not hasattr(app.Transaction, 'process'):
                log(91, "The app.Transaction in %s does not have " % __ +
                        "a `process' method. Falling back to httpy.app.")
                app = httpy.app

            if not callable(app.Transaction.process):
                log(91, "app.Transaction.process from %s is not " % __ +
                        "callable. Falling back to httpy.app.")
                app = httpy.app


        # Return an instance of the Transaction.
        # ======================================

        log(98, "Found a transaction to use: %s." % str(app.Transaction))
        return app.Transaction(config)


    def translate(self, root, apps, path):
        """Map the requested path to the filesystem.

        This method takes a website's filesystem-root, a list of application
        URI-roots, and the requested URI-path. It returns the filesystem-root of
        the application to be used for this request, and the filesystem-path of
        the application's magic directory, or None if the application does not
        have a magic directory.

        """

        # Find an application directory that matches the requested URI-path.
        # ==================================================================
        # The website root is always an implicit application. The first-named
        # app will match first.

        app = '/'
        for _app in apps:
            if path.startswith(_app):
                app = _app
                break
        app_root = os.path.realpath(os.path.join(root, app.lstrip('/')))
        path = os.path.realpath(os.path.join(app_root, path.lstrip('/')))

        if not os.path.isdir(app_root):
            # This can happen if an app dir is changed after httpy is started.
            raise Response(404)
        if not path.startswith(app_root):
            # protect against '../../../../../../../../../../etc/master.passwd'
            raise Response(403)


        # Look for a magic directory in the app directory, and protect it.
        # ================================================================

        __ = os.path.join(app_root, '__')
        if not os.path.isdir(__):
            __ = None
        if __ and path.startswith(__):
            raise Response(404)


        return (app_root, __)
