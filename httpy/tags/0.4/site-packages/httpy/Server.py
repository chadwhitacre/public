import asyncore
import os
import signal
import sys
import time
import traceback

from httpy._zope.server.serverbase import ServerBase
from httpy._zope.server.taskthreads import ThreadedTaskDispatcher

from httpy.Channel import Channel
from httpy.utils import log


class Server(ServerBase):
    """An httpy server.

    Instantiate with a ServerConfig object, and start it with start().

    """

    # ServerBase boilerplate
    channel_class = Channel
    SERVER_IDENT = 'httpy'


    http_version = (1, 0)
    http_version_string = "HTTP/1.0"
    response_header = "httpy/0.5"


    def __init__(self, config, threads=10):
        """Takes an httpy.ServerServerConfig object.

        We stick verbosity in the environment so that httpy.log can use it. The
        thread count should probably be exposed to configuration, but I still
        want to hold out the possibility of swapping out a different base
        server, which may change the meaning of that parameter.

        """

        self.config = config
        os.environ["HTTPY_VERBOSITY"] = str(config.verbosity)
        td = ThreadedTaskDispatcher()
        td.setThreadCount(threads)
        self.mtimes = {}

        ServerBase.__init__( self
                           , config.ip
                           , config.port
                           , start=0
                           , task_dispatcher=td
                            )


    def start(self):
        self.accept_connections()
        try:
            addr, port = self.socket.getsockname()
            log(1, "httpy started on port %s" % port)
            log(99, "%s\n\n" % ("="*76))
            asyncore.loop(timeout=5)
        except KeyboardInterrupt:
            log(1, "shutting down...")
            self.task_dispatcher.shutdown()



class Restart(Exception):
    pass


class RestartingServer:
    """Instantiate with a ServerConfig object, and start it with start().

    This server runs the *real* server in a separate process, restarting it
    whenever modules change on the filesystem. There are actually a number of
    ways to skin this deceptively simple cat. Here's what I've tried:

        Refresh modules directly from within the python process.
        --------------------------------------------------------

        The basic trick is to delete items from sys.modules, forcing a refresh
        the next time they are loaded. However, because modules import from one
        another, you need to make sure you reload enough of them to make it
        worth it. I got pretty far down this road (the place to start is to
        google for RollbackImporter), but at a couple points I started seeing
        very elusive segfaults. My best guess is that I was hitting a bug in
        Python, but I never narrowed it down enough to file it. :-(


        Run the python process within a wrapper that knows how to restart it.
        ---------------------------------------------------------------------

        Since you need to refresh almost all of your modules anyway, it makes a
        lot of sense to deal with the problem at the macro level. I got this
        idea from Ian Bicking via CherryPy. Thanks, guys. :-) Their version of
        this solution is to spawn a process and block for it, and then monitor
        the state of the modules on the filesystem in a separate thread. They
        use the blocked process's exit code to trigger reloading.


        Run within a wrapper but monitor within the process.
        ----------------------------------------------------

        I think it should also work to push the monitoring functionality down
        into the application, but I wasn't able to successfully exit zope.server
        from inside it, because I don't understand threading well enough.


        Run in a non-blocking process, monitor within the main process.
        ---------------------------------------------------------------

        The solution I've settled on here is to start the main server in a
        separate process, but not to block for it. I then monitor the filesystem
        in the main process/thread, and manipulate the worker process via its
        process ID. This solution, therefore, is not Windows-compatible. But,
        boy, is it simpler. :-)  See also: my above comment on me vs. threading.


    I am open to modifying this in a future version to use a thread rather than
    a process for Windows-compatibility.

    """

    def __init__(self, config):
        self.config = config
        self.mtimes = {}
        self.pid = None


    def start(self, args=None):
        if args is None:
            args = [sys.executable] + sys.argv
        new_env = os.environ.copy()
        new_env['HTTPY_PLAIN_JANE'] = 'So plain.'
        while 1:
            try:
                try:
                    self.pid = os.spawnve( os.P_NOWAIT
                                         , sys.executable
                                         , args
                                         , new_env
                                          )
                    while 1:
                        self.look_for_changes()
                        time.sleep(1)
                finally:
                    self.stop()

            except Restart:
                print >> sys.stderr, "Restarting server ..."

            except (SystemExit, KeyboardInterrupt):
                raise

            except:
                print >> sys.stderr, traceback.format_exc()


    def stop(self):
        if self.pid:
            os.kill(self.pid, signal.SIGTERM)


    def look_for_changes(self):
        """See if any of our available modules have changed on the filesystem.
        """
        for module in sys.modules.values():

            # Get out early if we can.
            # ========================

            filename = getattr(module, '__file__', None)
            if filename is None:
                continue
            if filename.endswith(".pyc"):
                filename = filename[:-1]


            # The file may have been removed from the filesystem.
            # ===================================================

            if not os.path.isfile(filename):
                print >> sys.stderr, "File is missing: %s" % filename
                if filename in self.mtimes:
                    del self.mtimes[filename]
                raise Restart


            # Or not.
            # =======

            mtime = os.stat(filename).st_mtime
            if filename not in self.mtimes:
                self.mtimes[filename] = mtime
                continue
            if mtime > self.mtimes[filename]:
                print >> sys.stderr, "File is outdated: %s" % filename
                self.mtimes[filename] = mtime
                raise Restart
