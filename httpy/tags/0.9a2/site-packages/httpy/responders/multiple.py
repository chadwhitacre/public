import imp
import inspect
import logging
import os
import sys
import traceback

from httpy._zope.interface import implements
from httpy._zope.interface.exceptions import Invalid
from httpy._zope.interface.verify import verifyObject, verifyClass

from httpy import Response, utils
from httpy._zope.interface import Attribute, Interface
from httpy.responders.static import Responder as Static
from httpy.interfaces import IResponder as IBaseResponder


logger = logging.getLogger('httpy.responder.multiple')


class Iresponder(Interface):
    """A module that defines a Responder object.
    """

    Responder = Attribute('Responder', 'A class that implements IResponder')


class IResponder(IBaseResponder):
    """Represents a Responder within a tree on the filesystem.

    This interface is very close to the standard httpy IResponder interface,
    with the addition of the framework hooks and the added API.

    The data attributes described below are added to your responder dynamically
    when the server is starting up. This happens just prior to instantiation if
    your responder is a class, so you have this API in your constructor. If your
    responder already has attributes by these names, they are not overwritten.

        site_root   the filesystem root of the site in which the responder is
                      embedded
        site___     the site's magic directory
        root        the filesystem root of the responder
        __          the responder's magic directory
        uri         the URI path under which requests go to this responder
        pkg         the path that was inserted into sys.path for this responder


    """

    def respond(request):
        """Given a request, raise a response.

        The incoming request object will be whatever is emitted by
        IFramework.wrap_request, and this method can raise anything that can be
        meaningfully passed to IFramework.unwrap_response.

        Using the default framework, this means that request will be an
        httpy.Request object, and respond ought to raise an httpy.Response.
        Exceptions other than httpy.Response may also be raised; they will
        generate a '500 Internal Server Error' response.

        """


class Responder:
    """This default responder infers a site from your filesystem.
    """

    implements(IBaseResponder)

    root = ''

    def __init__(self, root=None):

        # Set paths.
        # ==========

        root = root or os.getcwd()
        if not os.path.isdir(root):
            raise ValueError("root '%s' does not point to a directory" % root)
        self.root = os.path.realpath(root)
        self.__ = os.path.join(self.root, '__')
        if not os.path.exists(self.__):
            self.__ = None


        # Find findables.
        # ===============

        self.framework = self.get_framework()
        self.responders = self.get_responders()



    # Contracts
    # =========

    def respond(self, request):
        """Given a Request, return an IResponse.

        This is where we insert our framework hooks.

        """

        # Inbound hooks
        # =============

        if hasattr(self.framework, 'get_responder'):
            responder = self.framework.get_responder(request)
        else:
            responder = self.get_responder(request)

        if hasattr(self.framework, 'wrap_request'):
            request = self.framework.wrap_request(responder, request)


        # Get a response
        # ==============

        try:
            response = responder.respond(request)
        except Response, response:
            response = response
        except:
            raise



        # Outbound hook
        # =============

        if hasattr(self.framework, 'unwrap_response'):
            response = self.framework.unwrap_response( response
                                                     , responder
                                                     , request
                                                      )
        return response



    def stop(self):
        """Close down all responders and any framework.
        """
        for responder in self.responders:
            if hasattr(responder, 'stop'):
                if inspect.ismethod(responder.stop):
                    responder.close()
                    return
        if hasattr(self.framework, 'stop'):
            if inspect.ismethod(responder.stop):
                self.framework.stop()


    # Helpers
    # =======

    def get_framework(self):
        """Return a framework or None.

        We look in __, then in .. We add a couple API niceties before
        returning.

        """

        # Find a framework.
        # =================

        framework = None
        for path in (self.root, self.__):
            if path and os.path.isfile(os.path.join(path, 'framework.py')):
                try:
                    logger.debug("loading framework ...")
                    result = imp.find_module('framework', [path])
                    framework = imp.load_module('framework', *result)
                    break
                except ImportError:
                    logger.warning("Framework import failed:\n" +
                                   traceback.format_exc())
        if framework is None:
            logger.debug("No framework found.")
            return
        if hasattr(framework, 'Framework'):
            framework = framework.Framework


        # Add API, instantiate, and return.
        # =================================

        if not hasattr(framework, '__'):
            framework.__ = self.__
        if not hasattr(framework, 'root'):
            framework.root = self.root

        if inspect.isclass(framework):
            framework = framework()

        return framework


    def get_responders(self):
        """Return a sequence of responder instances.

        Any properly-formed responder.py within a subdirectory of the website
        filsystem root will be imported under the filesystem path of the
        subdirectory. If no responder.py is found in the website root directory
        itself, then we look for one in the magic directory (__). If no
        responder.py is found there, then we fall back to Static.

        """

        # Walk the tree rooted in root and load responders.
        # =================================================

        responders = []
        need_default = True
        for path, dirs, files in os.walk(self.root):

            dirs.sort() # on Windows, __ comes at the end

            do_not_enter = ('.svn', 'site-packages', 'lib')
            for name in do_not_enter:
                if name in dirs:
                    # Skip some directories.
                    dirs.remove(name)

            if os.path.basename(path) == '__':
                # Never recurse into subdirectories of __.
                dirs[:] = []

            dirs = sorted(dirs)

            if '__' in dirs:
                if 'responder.py' in os.listdir(os.path.join(path, '__')):
                    # A responder in <path>/__ trumps one in <path>.
                    continue

            if 'responder.py' in files:
                # Found one!
                responders.append(self.load_responder(path))
                if path in (self.root, self.__):
                    need_default = False

        responders.reverse()


        # Make sure we have a responder for / before returning.
        # =====================================================

        if need_default:
            self.add_api(Static, self.root, None)
            responders.append(Static(self.root))

        return responders


    def load_responder(self, root):
        """Given a responder's filesystem root, return an instance.

        Each responder is imported under the root so that they don't collide in
        sys.modules.

        """


        # Alter sys.path.
        # ===============

        pkg = self.sys_path(root)


        # Import the responder.
        # =====================

        logger.debug("loading responder from %s" % root)
        try:
            result = imp.find_module('responder', [root])
            responder = imp.load_module(root, *result)
        except ImportError:
            raise ImportError("unable to import responder from " +
                              "%s: \n%s" % ( root
                                           , traceback.format_exc()
                                            ))

        # Validate the responder.
        # =======================
        # We use zope interfaces, although your responder needn't implement
        # them explicitly. Allow both module and class responders.

        try:                                   # responder.Responder.respond()

            verifyObject(Iresponder, responder, tentative=True)

            try:
                responder = responder.Responder
                verifyClass(IBaseResponder, responder, tentative=True)
            except Invalid:
                logger.debug( "responder.Responder in %s " % root +
                              "is not valid."
                              )
                raise

        except Invalid:                                  # responder.respond()

            try:
                verifyObject(IBaseResponder, responder, tentative=True)
            except:
                logger.debug("responder in %s is not valid." % root)
                raise


        # Add API and return.
        # ===================

        self.add_api(responder, root, pkg)
        if inspect.isclass(responder):
            responder = responder()
        return responder


    def sys_path(self, root):
        """Given a filesystem path, insert a path into sys.path and return it.

        We insert exactly one of the following paths into sys.path; the first
        one that exists is chosen:

            1. root/site-packages/
            2. root/lib/
            3. root/

        If the responder is not from a magic directory, then we also consider a
        magic directory for inclusion in sys.path.

        """

        site_packages = os.path.join(root, 'site-packages')
        lib = os.path.join(root, 'lib')
        candidates = [site_packages, lib]
        if os.path.basename(root) == '__':
            candidates.append(root)
        else:
            candidates.append(os.path.join(root, '__'))

        pkg = None
        for path in candidates:
            if os.path.isdir(path):
                pkg = path
                sys.path.insert(0, path)
                break

        return pkg


    def add_api(self, Responder, root, pkg):
        """Given a class/module and two filesystem paths, return the class.
        """

        head, tail = os.path.split(root)
        __ = None
        if tail == '__':
            __ = root
            root = head
        else:
            ___ = os.path.join(root, '__')
            if os.path.exists(___):
                __ = ___ # :^D

        path = root[len(self.root):]
        path = path.replace(os.sep, '/')
        if not path:
            path = '/'

        api = {}
        api['site_root'] = self.root
        api['site___'] = self.__
        api['root'] = root
        api['__'] = __
        api['path'] = path
        api['pkg'] = pkg

        for key, val in api.items():
            if not hasattr(Responder, key):
                setattr(Responder, key, val)


    def get_responder(self, request):
        """Given a request, return a responder.
        """

        # Match a responder based on the URI path.
        # ========================================
        # We also update request.path.

        responder = None
        for _responder in self.responders:
            if request.path.startswith(_responder.path):
                responder = _responder
                request.path = request.path[len(responder.path)-1:]
                if not request.path:
                    request.path = '/'
                break
        if responder is None:
            # This catches, e.g., ../../../../../../../../../etc/master.passwd
            raise Response(400)

        logger.debug("Using %s for this request." % responder)


        # Make sure our paths still exist, but aren't being accessed.
        # ===========================================================

        fs_path = utils.translate(request.path, responder.root, raw=True)

        if not os.path.isdir(responder.root):
            logger.critical( "Filesystem root (%s) has " % responder.root +
                             "disappeared for responder '%s'" % responder
                            )
            raise Response(500)

        if responder.__ is not None:
            if not os.path.isdir(responder.__):
                logger.critical( "Magic directory (%s) has " % responder.__ +
                                 "disappeared for responder '%s'" % responder
                                )
                raise Response(500)
            if fs_path.startswith(responder.__):
                raise Response(403)

        if responder.pkg is not None:
            if not os.path.isdir(responder.pkg):
                logger.critical( "Package directory (%s) has " % responder.pkg +
                                 "disappeared for responder '%s'" % responder
                                )
                raise Response(500)
            if fs_path.startswith(responder.pkg):
                raise Response(403)
        return responder


Multiple = Responder