#!/usr/bin/env python
"""Replacement for the standard pwd module.

This module provides a class, Passwd, that represents a FreeBSD passwd(5) file,
or a Version 7 passwd(5) file. FreeBSD files have 10 fields, Version 7 files
have 7 fields. The class constructor's single argument is a filesystem path to
the passwd(5) file that it will manage.

"""

__author__ = "Chad Whitacre <chad@zetaweb.com>"
__version__ = (0,7)

import os
import stat
import tempfile


class Record:
    """Represent a single record in a 10-field FreeBSD passwd(5) file.
    """

    fields = ( ('name', str)
             , ('password', str)
             , ('uid', int)
             , ('gid', int)
             , ('class', str)
             , ('change', int)
             , ('expire', int)
             , ('gecos', str)
             , ('home_dir', str)
             , ('shell', str)
              )

    def __init__(self, *fields):
        for i in range(len(fields)):
            name, func = self.fields[i]
            setattr(self, name, func(fields[i]))

    def __cmp__(self, other):
        """Sort by uid.
        """
        # root should always be first
        if self.name == 'root':
            return -1
        elif other.name == 'root':
            return 1

        # after that we sort on uid
        elif self.uid < other.uid:
            return -1
        elif self.uid == other.uid:

            # lastly we sort on name
            if self.name < other.name:
                return -1
            elif self.name == other.name:
                return 0
            else: # self.name > other.name
                return 1

        else: # self.uid > other.uid:
            return 1

    def __len__(self):
        return 10

    def __repr__(self):
        return "<passwd record for '%s'>" % self.name

    def __str__(self):
        """Reconstitute the record in passwd(5) format.
        """
        vals = []
        for i in range(len(self.fields)):
            vals.append(str(getattr(self, self.fields[i][0])))
        return ':'.join(vals)

    def __getitem__(self, key):
        return getattr(self, key)

    def __setitem__(self, name, val):
        setattr(self, name, val)



class Passwd:
    """Represent a FreeBSD passwd(5) file.

    This class is intended to represent a passwd(5) file with passwords, and the
    save method will attempt to install the file using pwd_mkdb.

    We keep two mappings, one keyed to UID (by_uid) and the other to username
    (by_name). Since users can share uids but not usernames, the by_name index
    contains all records from the underlying file, whereas the by_uid index only
    contains one entry per UID. For UIDs with more than one entry, by_uid knows
    about the first.

    Records may be sorted. They compare according to the following rubric:

        1. The username 'root' is always first.
        2. Lower UIDs come before higher ones.
        3. Usernames sharing a UID are compared alphabetically.

    """

    loaded = False

    def __init__(self, path='/etc/master.passwd'):
        """Read and parse the passwd(5) file.
        """
        self.path = path
        self.synced = 0


    # Output
    # ======

    def __repr__(self):
        return "<passwd(5) file @ %s>" % self.path

    def __str__(self):
        """We output based on username to account for duplicate UIDs.
        """
        out = ['# This passwd(5) file automatically generated by mpwd.py']
        for rec in sorted(self.by_name.values()):
            out.append(str(rec))
        return '\n'.join(out)


    # Access
    # ======
    # Support both key and attr access.

    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError, err:
            raise AttributeError(*err.args)

    def __getitem__(self, key):
        """Be smart about the incoming type.
        """
        if not self.loaded:
            raise StandardError("Passwd must be loaded before accessed.")
        if isinstance(key, basestring):
            return self.by_name[key]
        elif isinstance(key, (int, long)):
            return self.by_uid[key]
        else:
            raise KeyError("Bad key type.")


    # Container Interface
    # ===================
    # Extend to add our sorting algorithm.

    def __len__(self):
        return len(self.by_name)

    def __iter__(self):
        return iter([v.name for v in sorted(self.by_name.values())])
    iterkeys = __iter__

    def itervalues(self):
        return iter(sorted(self.by_name.itervalues()))

    def iteritems(self):
        return iter(sorted(self.by_name.iteritems()))

    def keys(self):
        return sorted(self.by_name.keys())

    def values(self):
        return sorted(self.by_name.values())

    def items(self):
        return sorted(self.by_name.items())




    # Read and Write
    # ==============

    def load(self):
        """Load the password file, overwriting all info.
        """

        self.by_name = {}
        self.by_uid = {}
        passwd_file = open(self.path, 'r')

        for line in passwd_file.readlines():

            # Skip blank lines and comments.
            # ==============================

            line = line.splitlines(False)[0].strip()
            comment = line.startswith('#')
            blank = not line
            if comment or blank:
                continue


            # Parse the rest.
            # ===============

            else:
                fields = line.split(':')
                if len(fields) == 10:
                    rec = Record(*fields)
                    if rec.uid not in self.by_uid:
                        # Only track the first instance of a UID.
                        self.by_uid[rec.uid] = rec
                    # But track all instances of a username.
                    self.by_name[rec.name] = rec
                else:
                    raise StandardError("Malformed record %s" % line)

        passwd_file.close()
        self.synced = os.stat(self.path)[stat.ST_MTIME]
        self.loaded = True


    def save(self):
        """Write self's data to file.

        Don't worry about preserving comments or blank lines.

        """
        try:
            fd, filepath = tempfile.mkstemp()
            print >> file(filepath, 'w'), self
            os.system('/usr/bin/env pwd_mkdb %s' % filepath)
        except:
            # pwd_mkdb cleans up after itself if it succeeds.
            if os.path.isfile(filepath):
                os.remove(filepath)
        else:
            self.synced = os.stat(self.path)[stat.ST_MTIME]



if __name__ == '__main__':
    import sys
    from code import interact
    from pprint import pprint as pp

    if len(sys.argv) == 2:
        path = sys.argv[1]
    else:
        path = '/etc/master.passwd'
    banner = "'passwd' bound to passwd(5) file at %s" % path
    passwd = Passwd(path)
    interact(banner, local=locals())
