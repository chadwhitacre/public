\chapter{Extending Aspen}

Aspen uses Python's WSGI specification for its extension architecture. There are
three categories of extension:

\begin{tableii}{l|l}{}{Category}{Explanation}
\lineii{applications}{applications are connected to directories within the site
    hierarchy; only one app touches any given request}
\lineii{handlers}{handlers are tied to individual resources (i.e., files) based
    on extensible rules; only one handler touches any given request}
\lineii{middleware}{one or many middleware applications may be specified;
    all middleware generally touches every request}
\end{tableii}

All extensions are WSGI callables, connected to the above entry points with
three configuration files in \file{__/etc}:

\begin{itemize}
\item{\file{apps.conf}}
\item{\file{handlers.conf}}
\item{\file{middleware.conf}}
\end{itemize}

Where called for in these files, objects are specified in a notation derived
from setuptools' entry_points feature: a dotted module name, followed by a colon
and a dotted identifier naming an object within the module. This is referred to
below as \dfn{colon notation}. The following example would import the \code{bar}
object from \code{example.package.foo}, and use its \code{baz} attribute (a WSGI
callable):

\begin{verbatim}
example.package.foo:bar.baz
\end{verbatim}

The comment character for these files is \#, and comments can be included
in-line. Blank lines are ignored, as is initial and trailing whitespace
per-line. Where section names are called for, they are given in brackets.


\section{Applications: Path-based Extension \label{apps}}

In Aspen, an \dfn{application} or \dfn{app} refers to a WSGI application that is
connected to a particular directory. Apps are set up in \file{__/etc/apps.conf}.

The \file{__/etc/apps.conf} file contains a newline-separated list of
white-space-separated path name/object name pairs. The path names refer to
URL-space, and are translated literally to the filesystem. If the trailing slash
is given, then requests for that directory will first be redirected to the
trailing slash before being handed off to the application. If no trailing slash
is given, the application will also get requests without the slash. When
choosing an application to service a request, the most specific pathname matches
first.

Object names are in colon notation, and they name WSGI callables.

Aspen will (over)write a file called \file{README.aspen} in each directory
mentioned in \file{apps.conf}, containing the relevant line from
\file{apps.conf}. If the directory does not exist, it is created.


\subsection{Example apps.conf \label{apps.conf}}

\begin{verbatim}
/foo        example.apps:foo    # will get both /foo and /foo/
/bar/       example.apps:bar    # /bar will redirect to /bar/
/bar        example.apps:Bar    # will never be called
/bar/baz    example.apps:baz    # but this may be
\end{verbatim}


\section{Handlers: Resource-based Extension \label{handlers}}

Aspen provides an extensible mechanism for supporting ASP/PHP-style web
development, where URLs map literally to the filesystem, and the response is
generated by somehow processing a filesystem resource.

The \file{__/etc/handlers.conf} file begins with a newline-separated list of
white-space-separated rule name/object name pairs. Rule names can be any string
without whitespace. Each object name (in colon notation) specifies a \dfn{rule},
a callable taking a Python file object and an arbitrary predicate string, and
returning \class{True} or \class{False}.

Following the rule specification are sections specifying \dfn{handlers}, which
as mentioned above are WSGI callables. When called, handlers receive the
following additional objects in \code{environ}:

\begin{tableii}{l|l}{var}{key}{value}
\lineii{aspen.fp}{the filesystem resource as a \class{file} object, positioned at zero}
\lineii{aspen.website}{the \class{Website} instance}
\end{tableii}

The name of each section specifies a handler (a WSGI callable) in colon
notation. The body of each section is a newline-separated list of conditions
under which this handler is to be called. Fundamentally, these conditions are
made up of a rule name as defined at the beginning of the file, and an arbitrary
predicate string that is meaningful to the matching rule callable. If no
predicate is given, then the rule callable will receive \class{None} for its
predicate argument. Rules must be explicitly specified at the beginning of the
file before being available within handler sections.


After the first condition in a handler section, additional condition lines must
begin with one of \code{AND}, \code{OR}, or \code{NOT}. These case-insensitive
tokens specify how conditions are to be combined in evaluating whether to use
this handler. On each request, handlers are considered in the order given, and
the first matching handler is used. Only one handler is used for any given
request.

Note that if the file \file{__/etc/handlers.conf} exists at all, the defaults
(see the example below) disappear, and you must respecify any of the default
rules in your own file if you want them.


\subsection{Example handlers.conf \label{handlers.conf}}
This is Aspen's default handler configuration:

\begin{verbatim}
fnmatch     aspen.rules.fnmatch
hashbang    aspen.rules.hashbang
mime-type   aspen.rules.mimetype


[aspen.handlers.HTTP404]
fnmatch *.py[cod]           # hide any compiled Python scripts


[aspen.handlers.pyscript]
    fnmatch     *.py        # exec python scripts ...
OR  hashbang                # ... and anything beginning with #!


[aspen.handlers.Simplate]
mime-type text/html         # run html files through the Simplates engine


[aspen.handlers.static]
fnmatch *                   # anything else, serve it statically
\end{verbatim}


\section{Middleware: Global Extension \label{middleware}}

