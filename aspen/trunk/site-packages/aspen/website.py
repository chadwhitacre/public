import os
import string
import sys
import traceback
from os.path import basename, dirname, exists, isdir, isfile, join

from httpy import Response, mode, utils
from httpy.responders.static import Static


def is_script(path):
    """Given a filesystem path, return a boolean.
    """
    try:
        assert os.path.isfile(path)                 # exists
        assert open(path, 'rb').read(2) == '#!'     # hashbang
        assert (os.stat(path).st_mode & 0111) != 0  # executable
        # svn:executable?
        return True
    except AssertionError:
        return False

INITIAL = '_' + string.letters
INNER = INITIAL + string.digits
def is_valid_identifier(s):
    """Given a string of length > 0, return a boolean.

        >>> is_valid_identifier('.svn')
        False
        >>> is_valid_identifier('svn')
        True
        >>> is_valid_identifier('_svn')
        True
        >>> is_valid_identifier('__svn')
        True
        >>> is_valid_identifier('123')
        False
        >>> is_valid_identifier('r123')
        True

    """
    try:
        assert s[0] in INITIAL
        assert False not in [x in INNER for x in s]
        return True
    except AssertionError:
        return False


class Website:
    """Represent a website for aspen to publish.

    You can extend instances of this object with magically-named scripts in
    directories under __/local. Each script is run with 'website' in its local
    namespace, along with the following:

        hook        objects in local ns      expected action
        ========================================================================
        startup                              populate the global namespace
        request     request                  modify the request object
        exception   request, response        modify the response object
        response    request, response        modify the response object

    All scripts within your site hierarchy will also have this object in their
    namespace, as well as the following:

        __file__        the filename of the script being executed

    """

    def __init__(self, paths):
        """Set up the Static responder and plugins.
        """

        # Paths.
        # ======

        self.paths = paths
        self.paths.pkg = None
        self.paths.hooks = None

        if self.paths.__ is not None:
            pkg = join(self.paths.__, 'site-packages')
            if isdir(pkg):
                self.paths.pkg = pkg
                sys.path.insert(0, pkg)

            hooks = join(self.paths.__, 'hooks')
            if isdir(hooks):
                self.paths.hooks = hooks


        # Etc.
        # ====

        self.__static = Static()
        self.__static.root = self.paths.root
        self.__static.defaults = ['index.htm', 'index.html', 'index.py']

        self.__hooks = self.__load_hooks()
        self.__on_startup()


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """

        # Reload hooks in dev mode.
        # =========================

        if mode.IS_DEVELOPMENT or mode.IS_DEBUGGING:
            self.__hooks = self.__load_hooks()


        # Prime our custom request API.
        # =============================

        request.fspath = None


        # Handle safely.
        # ==============
        # All hooks (besides startup) are called here.

        try:
            request = self.__on_request(request)
            response = self.__respond_unsafely(request)
        except Response, response:
            pass
        except:
            response = self.__on_exception(request)
            raise response

        return self.__on_response(request, response)


    def __respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        if request.path.startswith('/__'):
            raise Response(404)

        fspath = self.__static.translate(request.path)

        if exists(fspath):

            # Found a resource; serve it.
            # ===========================

            fspath = request.fspath = self.__static.find_default(fspath)
            if is_script(fspath):
                response = self.__execute(fspath, request)
            else:
                response = self.__static.respond(request)
                del response.headers['Content-Length']

        else:

            # No resource; look for a script to handle the request.
            # =====================================================

            script = None
            parts = request.path.split('/')
            while len(parts) > 0:
                del parts[-1]
                path = self.__static.translate('/'.join(parts))
                if exists(path):
                    path = self.__static.find_default(path)
                    if is_script(path):
                        script = path
                        break

            if script is not None:
                request.fspath = script
                response = self.__execute(script, request)
            else:
                raise Response(404)

        return response


    def __execute(website, __file__, request):
        """Execute a script.
        """
        response = Response()
        try:
            exec open(__file__)
        except SystemExit:
            pass
        return response


    # Hooks
    # =====

    def __load_hooks(self):
        """Return a mapping of hook names to code objects.
        """
        hooks = { 'exception'   : None
                , 'request'     : None
                , 'response'    : None
                , 'startup'     : None
                 }
        if self.paths.hooks is not None:
            for hook in hooks:
                filepath = join(self.paths.hooks, hook+'.py')
                if is_script(filepath):
                    hooks[hook] = compile( open(filepath).read()
                                         , filepath
                                         , 'exec'
                                          )
        return hooks


    def __on_startup(website):
        if website.__hooks['startup'] is not None:
            try:
                exec website.__hooks['startup']
            except SystemExit:
                pass


    def __on_request(website, request):
        if website.__hooks['request'] is not None:
            try:
                exec website.__hooks['request']
            except SystemExit:
                pass
        return request


    def __on_response(website, request, response):
        if website.__hooks['response'] is not None:
            try:
                exec website.__hooks['response']
            except SystemExit:
                pass
        return response


    def __on_exception(website, request):
        response = Response(500)
        if mode.IS_DEBUGGING or mode.IS_DEVELOPMENT:
            response.body = traceback.format_exc()
        if website.__hooks['exception'] is not None:
            try:
                exec website.__hooks['exception']
            except SystemExit:
                pass
        return response


if __name__ == '__main__':
    import doctest
    doctest.testmod()
