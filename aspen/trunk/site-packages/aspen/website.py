import commands
import logging
import os
import string
import sys
import traceback
from os.path import basename, dirname, exists, isdir, isfile, join

from httpy import Response, mode, utils
from httpy.responders.static import Static


log = logging.getLogger('aspen.website')


class HandlerConfigError(StandardError):
    pass


def is_script(path):
    """Given a filesystem path, return a boolean.
    """
    try:
        assert isfile(path)                         # exists
        assert open(path, 'rb').read(2) == '#!'     # hashbang
        assert (os.stat(path).st_mode & 0111) != 0  # executable
        # svn:executable?
        return True
    except AssertionError:
        return False

INITIAL = '_' + string.letters
INNER = INITIAL + string.digits
def is_valid_identifier(s):
    """Given a string of length > 0, return a boolean.

        >>> is_valid_identifier('.svn')
        False
        >>> is_valid_identifier('svn')
        True
        >>> is_valid_identifier('_svn')
        True
        >>> is_valid_identifier('__svn')
        True
        >>> is_valid_identifier('123')
        False
        >>> is_valid_identifier('r123')
        True

    """
    try:
        assert s[0] in INITIAL
        assert False not in [x in INNER for x in s]
        return True
    except AssertionError:
        return False


class Website:
    """Represent a website for aspen to publish.

    You can extend instances of this object with magically-named scripts in
    directories under __/local. Each script is run with 'website' in its local
    namespace, along with the following:

        hook        objects in local ns      expected action
        ========================================================================
        startup                              populate the global namespace
        request     request                  modify the request object
        exception   request, response        modify the response object
        response    request, response        modify the response object

    All scripts within your site hierarchy will also have this object in their
    namespace, as well as the following:

        __file__        the filename of the script being executed

    """

    def __init__(self, paths):
        """Set up the Static responder and plugins.
        """

        # Paths.
        # ======

        self.paths = paths
        self.paths.pkg = None
        self.paths.hooks = None

        if self.paths.__ is not None:
            pkg = join(self.paths.__, 'site-packages')
            if isdir(pkg):
                self.paths.pkg = pkg
                sys.path.insert(0, pkg)

            hooks = join(self.paths.__, 'hooks')
            if isdir(hooks):
                self.paths.hooks = hooks


        # Etc.
        # ====

        self.__static = Static()
        self.__static.root = self.paths.root
        self.__static.defaults = ['index.htm', 'index.html', 'index.py']

        self.__hooks = self.__load_hooks()
        self.__handlers = self.__load_handlers()


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """

        # Reload hooks and handlers in dev mode.
        # ======================================

        if mode.IS_DEVELOPMENT or mode.IS_DEBUGGING:
            self.__hooks = self.__load_hooks()
            self.__handlers = self.__load_handlers()


        # Prime our custom request API.
        # =============================

        request.fspath = None


        # Handle safely.
        # ==============
        # All hooks (besides startup) are called here.

        try:
            request = self.__on_request(request)
            response = self.__respond_unsafely(request)
        except Response, response:
            pass
        except:
            response = self.__on_exception(request)
            raise response

        return self.__on_response(request, response)


    def __respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        if '/__' in request.path:
            raise Response(404)

        fspath = self.__static.translate(request.path)
        if not exists(fspath):
            raise Response(404)

        fspath = request.fspath = self.__static.find_default(fspath)
        atype = self.__get_atype(fspath)
        try:
            handler = self.__handlers[atype]
        except KeyError:
            msg = "No handler configured for aspen:type %s" % atype
            raise HandlerConfigError, msg

        contexts = {}

        # Eternal
        # =======
        # The application lives forever.

        context['website'] = self


        # Four score
        # ==========
        # Cross-request state, i.e. session. Maybe someday add conversation or
        # page contexts, a la SEAM?

        contexts['session']


        # Ephemeral
        # =========
        # A number of contexts only last for one HTTP transaction.

        context['request'] = request
        context['response'] = Response()
        context['cookie'] = Cookie(request)
        context['form'] = Form(request)
        context['query'] = Query(request)

        response = handler.handle(**contexts)
        return response


    # Hooks
    # =====

    def __load_hooks(self):
        """Return a mapping of hook names to code objects.
        """
        hooks = { 'exception'   : None
                , 'request'     : None
                , 'response'    : None
                , 'startup'     : None
                 }
        if self.paths.hooks is not None:
            for hook in hooks:
                filepath = join(self.paths.hooks, hook+'.py')
                if is_script(filepath):
                    hooks[hook] = compile( open(filepath).read()
                                         , filepath
                                         , 'exec'
                                          )
        return hooks


    def __on_startup(website):
        if website.__hooks['startup'] is not None:
            try:
                exec website.__hooks['startup']
            except SystemExit:
                pass


    def __on_request(website, request):
        if website.__hooks['request'] is not None:
            try:
                exec website.__hooks['request']
            except SystemExit:
                pass
        return request


    def __on_response(website, request, response):
        if website.__hooks['response'] is not None:
            try:
                exec website.__hooks['response']
            except SystemExit:
                pass
        return response


    def __on_exception(website, request):
        response = Response(500)
        if mode.IS_DEBUGGING or mode.IS_DEVELOPMENT:
            response.body = traceback.format_exc()
        if website.__hooks['exception'] is not None:
            try:
                exec website.__hooks['exception']
            except SystemExit:
                pass
        return response


    # Handlers
    # ========

    def handle(self, **context):
        """If nobody else wants it, we will serve it statically.
        """
        return self.__static.respond(context['request'])


    def __load_handlers(self):
        """Return a mapping of handler names to code object.
        """
        handlers = {None:self}
        if self.paths.__ is not None:
            conf = join(self.paths.__, 'etc', 'handlers.conf')
            if isfile(conf):
                i = 0
                for line in file(conf):
                    i += 1
                    orig = line                             # save for errors
                    line = line.split('#', 1)[0].strip()    # ignore comments
                    if line:                                # and blank lines


                        # Locate and instantiate a handler for this aspen:type.
                        # =====================================================

                        try:
                            atype, modname = line.strip().split(None, 1)
                        except ValueError:
                            msg = "Line %d of %s is bad: %s" % (i, conf, orig)
                            raise HandlerConfigError, msg
                        if atype in handlers:
                            log.warn('Conflict for %s' % atype)

                        try:
                            module = __import__( modname
                                               , globals()
                                               , locals()
                                               , 'Handler'
                                                )
                            Handler = getattr(module, 'Handler')
                        except ImportError:
                            msg =  "cannot import Handler from " + modname
                            raise HandlerConfigError, msg

                        handlers[atype] = Handler(self)

        return handlers


    def __get_atype(self, fspath):
        """Given a filesystem path, return an aspen:type.
        """
        command = "svn propget 'aspen:type' %s" % fspath
        status, output = commands.getstatusoutput(command)
        if status > 0:
            atype = None
        else:
            output = output.strip()
            atype = output and output or None
        return atype


if __name__ == '__main__':
    import doctest
    doctest.testmod()
