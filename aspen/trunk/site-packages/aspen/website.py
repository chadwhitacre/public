import commands
import logging
import os
import string
import sys
import threading
import traceback
from os.path import basename, dirname, exists, isdir, isfile, join

from httpy import Response, mode, utils
from httpy.responders.static import Static


log = logging.getLogger('aspen.website')
clean = lambda x: x.split('#')[0].strip() # comments & whitespace
reloading = threading.Lock()


class AspenError(StandardError):
    pass

class ConfigError(AspenError):
    pass

class HookError(AspenError):
    pass


def is_script(path):
    """Given a filesystem path, return a boolean.
    """
    try:
        assert isfile(path)                         # exists
        assert open(path, 'rb').read(2) == '#!'     # hashbang
        assert (os.stat(path).st_mode & 0111) != 0  # executable
        # svn:executable?
        return True
    except AssertionError:
        return False

INITIAL = '_' + string.letters
INNER = INITIAL + string.digits
def is_valid_identifier(s):
    """Given a string of length > 0, return a boolean.

        >>> is_valid_identifier('.svn')
        False
        >>> is_valid_identifier('svn')
        True
        >>> is_valid_identifier('_svn')
        True
        >>> is_valid_identifier('__svn')
        True
        >>> is_valid_identifier('123')
        False
        >>> is_valid_identifier('r123')
        True

    """
    try:
        assert s[0] in INITIAL
        assert False not in [x in INNER for x in s]
        return True
    except AssertionError:
        return False


class Website:
    """Represent a website for aspen to publish.

    You can extend instances of this object with magically-named scripts in
    directories under __/local. Each script is run with 'website' in its local
    namespace, along with the following:

        hook        objects in local ns      expected action
        ========================================================================
        startup                              populate the global namespace
        request     request                  modify the request object
        exception   request, response        modify the response object
        response    request, response        modify the response object

    All scripts within your site hierarchy will also have this object in their
    namespace, as well as the following:

        __file__        the filename of the script being executed

    """

    def __init__(self, paths):
        """Set up the Static responder and plugins.
        """

        # Paths
        # =====

        self.paths = paths
        if self.paths.__ is not None:
            hooks = join(self.paths.__, 'hooks')
            if isdir(hooks):
                self.paths.hooks = hooks


        # Etc.
        # ====

        self.__static = Static()
        self.__static.root = self.paths.root
        self.__static.defaults = ['index.htm', 'index.html', 'index.py']
        self.__configure()


    def __configure(self):
        """Set hooks and handlers on self.

        Eventually this should respond to SIGHUP.

        """
        reloading.acquire()
        try: # critical section
            self.__hooks = self.__load_hooks()
            self.__handlers = self.__load_handlers()
            self.__on_startup()
        finally:
            reloading.release()


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """

        # Reload hooks and handlers in dev mode.
        # ======================================

        if mode.IS_DEVELOPMENT or mode.IS_DEBUGGING:
            self.__configure()


        # Prime our custom request API.
        # =============================

        request.fspath = None


        # Handle safely.
        # ==============
        # All hooks (besides startup) are called here.

        try:
            request = self.__on_request(request)
            response = self.__respond_unsafely(request)
        except Response, response:
            pass
        except:
            response = self.__on_exception(request)
            raise response

        return self.__on_response(request, response)


    def __respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        if '/__' in request.path:
            raise Response(404)

        fspath = self.__static.translate(request.path)
        if not exists(fspath):
            raise Response(404)

        fspath = request.fspath = self.__static.find_default(fspath)
        atype = self.__get_atype(fspath)
        try:
            handler = self.__handlers[atype]
        except KeyError:
            msg = "No handler configured for aspen:type %s" % atype
            raise ConfigError, msg

        contexts = {}


        # Eternal
        # =======
        # The application lives forever.

        contexts['website'] = self


        # Four score
        # ==========
        # Cross-request state, i.e. session. Maybe someday add conversation or
        # page contexts, a la SEAM?

        contexts['session'] = None


        # Ephemeral
        # =========
        # A number of contexts only last for one HTTP transaction.

        contexts['request'] = request
        contexts['response'] = Response()
        #contexts['cookie'] = Cookie(request)
        #contexts['form'] = Form(request)
        #contexts['query'] = Query(request)

        response = handler.handle(**contexts)
        return response


    # Hooks
    # =====

    def __imp(self, modname, name):
        """Equivalent to 'from <modname> import <name>'
        """
        module = __import__(modname, globals(), locals(), name)
        try:
            callable_ = getattr(module, name)
        except:
            raise ImportError("Can't import %s from %s" % (name, modname))
        return callable_


    def __load_hooks(self):
        """Return a mapping of hook names to lists of callables.

        This method parses the __/etc/hooks.conf file, which is a list of Python
        dotted names, split into 5 sections. Section names are given in
        brackets, and are taken from the hook names:

            exception
            request
            response
            startup

        Lines after each section name are taken to be Python dotted names
        specifying objects that should be called at each hook point. Objects are
        called in the order specified. If an object cannot be found, ImportError
        is raised.

        Preceding the first explicitly-named section is an anonymous section,
        where names are interpreted as module or package names from which should
        be imported objects with names corresponding to each hook. Callables
        specified in this manner are called in forward order for the startup and
        request hooks, and in reverse order for the response and exception
        hooks. Modules need not define a callable for every hook.

        The comment character for this file is #, and comments can be included
        in-line. Blank lines are ignored, as is initial and trailing whitespace
        per-line.

        Example file:

            foo.hooks   # will look for {exception,request,response,startup}
            bar.hooks   #   in these modules

            [startup]
              example.hooks.startup

            [exception]
              example.exception_handling.hook

        """

        # Set up some variables; exit early if we can.
        # ============================================

        hooks = { 'exception'   : []
                , 'request'     : []
                , 'response'    : []
                , 'startup'     : []
                 }

        if self.paths.__ is None:
            return hooks

        path = join(self.paths.__, 'etc', 'hooks.conf')
        if not isfile(path):
            return hooks


        # We have a config file; proceed.
        # ===============================

        fp = open(path)
        hook = None

        for line in fp:
            line = clean(line)
            if not line:                            # blank line
                continue
            elif line.startswith('['):              # new section
                if not line.endswith(']'):
                    raise ConfigError(line)
                hook = line[1:-1]
                if hook and (hook not in hooks):
                    raise ConfigError("Bad hook '%s'" % hook)
                continue
            elif hook is None:                      # anonymous section
                modname = line
                for name in hooks:
                    try:
                        callable_ = self.__imp(modname, name)
                    except ImportError, exc:
                        log.info(exc.args[0])
                    else:
                        if name in ('startup', 'request'):
                            hooks[name].append(callable_)
                        else:
                            hooks[name].insert(0, callable_)
            else:                                   # named section
                modname, name = line.rsplit('.', 1)
                callable_ = self.__imp(modname, name)
                hooks[hook].append(callable_)

        return hooks


    def __on_startup(website):
        if website.__hooks['startup'] is not None:
            for func in website.__hooks['startup']:
                func(website)


    def __on_request(website, request):
        if website.__hooks['request'] is not None:
            for func in website.__hooks['request']:
                request = func(website, request)
                if request is None:
                    raise HookError, "A request hook returned None."
        return request


    def __on_response(website, request, response):
        if website.__hooks['response'] is not None:
            for func in website.__hooks['response']:
                response = func(website, request, response)
                if response is None:
                    raise HookError, "A response hook returned None."
        return response


    def __on_exception(website, request):
        response = Response(500)
        if mode.IS_DEBUGGING or mode.IS_DEVELOPMENT:
            response.body = traceback.format_exc()
        if website.__hooks['exception'] is not None:
            for func in website.__hooks['exception']:
                response = func(website, request, response)
                if response is None:
                    raise HookError, "An exception hook returned None."
        return response


    # Handlers
    # ========

    def handle(self, **context):
        """If nobody else wants it, we will serve it statically.
        """
        return self.__static.respond(context['request'])


    def __load_handlers(self):
        """Return a mapping of handler names to code object.
        """
        handlers = {None:self}
        if self.paths.__ is not None:
            conf = join(self.paths.__, 'etc', 'handlers.conf')
            if isfile(conf):
                i = 0
                for line in file(conf):
                    i += 1
                    orig = line                             # save for errors
                    line = line.split('#', 1)[0].strip()    # ignore comments
                    if line:                                # and blank lines


                        # Locate and instantiate a handler for this aspen:type.
                        # =====================================================

                        try:
                            atype, modname = line.strip().split(None, 1)
                        except ValueError:
                            msg = "Line %d of %s is bad: %s" % (i, conf, orig)
                            raise ConfigError, msg
                        if atype in handlers:
                            log.warn('Conflict for %s' % atype)

                        try:
                            module = __import__( modname
                                               , globals()
                                               , locals()
                                               , 'Handler'
                                                )
                            Handler = getattr(module, 'Handler')
                        except ImportError:
                            msg =  "cannot import Handler from " + modname
                            raise ConfigError, msg

                        handlers[atype] = Handler(self)

        return handlers


    def __get_atype(self, fspath):
        """Given a filesystem path, return an aspen:type.
        """
        command = "svn propget 'aspen:type' %s" % fspath
        status, output = commands.getstatusoutput(command)
        if status > 0:
            atype = None
        else:
            output = output.strip()
            atype = output and output or None
        return atype


if __name__ == '__main__':
    import doctest
    doctest.testmod()
