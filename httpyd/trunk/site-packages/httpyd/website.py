import __builtin__
import os
import sys
import traceback
from email import message_from_string
from os.path import basename, exists, isdir, isfile, join
from UserList import UserList

from httpy import mode, Response
from httpy.responders.static import Static


def is_script(path):
    """Given a filesystem path, return a boolean.
    """
    try:
        assert os.path.exists(path)                 # exists
        assert open(path, 'rb').read(2) == '#!'     # hashbang
        assert (os.stat(path).st_mode & 0111) != 0  # executable
        # svn:executable?
        return True
    except:
        return False


class Plugin:
    """Represent an individual plugin.
    """

    def __init__(self, root):
        """Takes the filesystem path of this plugin.
        """
        self.name = basename(root)
        self.root = root
        self.hooks = join(root, 'hooks')
        self.lib = None
        lib = join(root, 'lib')
        if isdir(lib):
            self.lib = lib
            sys.path.insert(0, self.lib)

    def __str__(self):
        return '<plugin: %s>' % (self.name)
    __repr__ = __str__

    def load_hook(self, hook):
        """Given the name of a hook, return python code.
        """
        filepath = join(self.hooks, hook)
        if is_script(filepath):
            return open(filepath).read()
        else:
            return ''


class Plugins(UserList):
    """Represent the plugins for a Website.
    """

    def __init__(self, root):
        """Takes the filesystem plugins root.
        """
        self.root = root
        plugins = []
        if isdir(root):
            all = [join(root, d) for d in sorted(os.listdir(root))]
            paths = [d for d in all if isdir(d)]
            for filepath in paths:
                plugins.append(Plugin(filepath))
        self.data = plugins


class Website:
    """Represent a website for httpyd to publish.

    You can extend instances of this object with magically-named scripts in
    directories under __/etc/plugins. These scripts will be compiled into a
    single code object per hook, and then executed with this object in it's
    namespace as 'website'.

        hook        objects in global ns     expected action
        ========================================================================
        startup                              populate the global namespace
        request     request                  modify the request object
        exception   request, response        modify the response object
        response    request, response        modify the response object

    All scripts within your site hierarchy will also have this object in their
    namespace, as well as the following:

        __file__        the filename of the script being executed

    """

    __run_exception_hook = False


    def __init__(self, paths):
        """Set up the Static responder and plugins.
        """
        self.paths = paths
        self.plugins = Plugins(join(self.paths.__, 'plugins'))

        self.__static = Static()
        self.__static.root = self.paths.root
        self.__static.defaults = ['index.htm', 'index.html', 'index.py']

        self.__hooks = self.__load_hooks()
        self.__on_startup()


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """

        if mode.IS_DEVELOPMENT or mode.IS_DEBUGGING:
            self.__hooks = self.__load_hooks()

        if self.__run_exception_hook:
            try:
                request = self.__on_request(request)
                response = self.__respond_unsafely(request)
            except:
                response = self.__on_exception(request)
                raise response
        else:
            request = self.__on_request(request)
            response = self.__respond_unsafely(request)
        return response


    def __respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        if request.path.startswith('/__'):
            raise Response(404)

        fspath = self.__static.translate(request.path)
        request.fspath = ''

        if exists(fspath):

            # Found a resource; serve it.
            # ===========================

            fspath = request.fspath = self.__static.find_default(fspath)
            if is_script(fspath):
                response = self.__execute(fspath, request)
            else:
                response = self.__static.respond(request)
                del response.headers['Content-Length']

        else:

            # No resource; look for a script to handle the request.
            # =====================================================

            script = None
            parts = request.path.split('/')
            while len(parts) > 0:
                del parts[-1]
                path = self.__static.translate('/'.join(parts))
                if exists(path):
                    path = self.__static.find_default(path)
                    if is_script(path):
                        script = path
                        break

            if script is not None:
                request.fspath = script
                response = self.__execute(script, request)
            else:
                raise Response(404)

        return self.__on_response(request, response)


    def __execute(website, __file__, request):
        """Execute a script.
        """
        response = Response()
        try:
            exec open(__file__)
        except SystemExit:
            pass
        return response


    # Plugins
    # =======

    def __load_hooks(self):
        """Return a mapping of hook names to code objects.
        """

        hooks = { 'exception'   : []
                , 'request'     : []
                , 'response'    : []
                , 'startup'     : []
                 }

        # Search all directories under __/etc/plugins.
        # ============================================

        for plugin in self.plugins:
            for hook in hooks:
                python = plugin.load_hook(hook)
                if python is not None:

                    # Found a hook script. Add it to the list.
                    # ========================================

                    hooks[hook].append(python)

                    if hook == 'exception':
                        self.__run_exception_hook = True


        # Concatenate and compile all scripts per-hook.
        # =============================================

        for hook in hooks:
            if hooks[hook]:
                hooks[hook] = os.linesep.join(hooks[hook])
                hooks[hook] = compile(hooks[hook], '<hook: %s>' % hook, 'exec')

        return hooks


    # Hooks
    # =====

    def __on_startup(website):
        if website.__hooks['startup']:
            try:
                exec website.__hooks['startup']
            except SystemExit:
                pass


    def __on_request(website, request):
        if website.__hooks['request']:
            try:
                exec website.__hooks['request']
            except SystemExit:
                pass
        return request


    def __on_response(website, request, response):
        if website.__hooks['response']:
            try:
                exec website.__hooks['response']
            except SystemExit:
                pass
        return response


    def __on_exception(website, request):
        response = Response(500)
        if website.__hooks['exception']:
            try:
                exec website.__hooks['exception']
            except SystemExit:
                pass
        return response
