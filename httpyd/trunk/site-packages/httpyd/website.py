import __builtin__
import os
import sys
import traceback
from email import message_from_string

from httpy import Response
from httpy.utils import mode
from httpy.responders.static import Static


def is_executable(path):
    """Given a valid filesystem path, return a boolean.
    """
    return (os.stat(path).st_mode & 0111) != 0


class Filters:
    """Represent the runtime filters we give users.
    """

    categories = ( 'exception'
                 , 'request'
                 , 'response'
                 , 'startup'
                  )

    def __init__(self, website):
        """Establish the global script namespace, and load filters.
        """
        self.global_ = {}
        self.global_['__builtins__'] = __builtin__
        self.global_['__website__'] = website
        self._keep = self.global_.keys()
        self.root = os.path.join(website.paths.root, '__', 'etc', 'filters')
        self.filters = self.load_filters()


    def load_filters(self):
        """Look for executables, or directories of executables.
        """
        filters = {}
        for name in self.categories:
            filters[name] = []
            path = os.path.join(self.root, name)
            if os.path.exists(path):
                if os.path.isfile(path):            # single executable
                    if is_executable(path):
                        filters[name].append(path)
                elif os.path.isdir(path):           # directory of executables
                    for filename in sorted(os.listdir(path)):
                        fpath = os.path.realpath(os.path.join(path, filename))
                        if os.path.isfile(fpath) and is_executable(fpath):
                            filters[name].append(fpath)
        return filters


    def has_exception_filters(self):
        return len(self.filters['exception']) > 0


    def __call__(self, category, local):
        """Given a filter category and a dictionary, run some scripts.
        """
        for path in self.filters[category]:
            if os.path.exists(path) and is_executable(path):
                local['__file__'] = path
                code_ = open(path)
                try:
                    exec code_ in self.global_, local
                except SystemExit:
                    pass


    # Actual hooks to call.
    # =====================

    def startup(self):
        """Populate a custom namespace to be shared by all scripts on this site.
        """
        for path in self.filters['startup']:
            if os.path.isfile(path) and is_executable(path):
                self.global_['__file__'] = path # will be pruned below
                code_ = open(path)
                try:
                    exec code_ in self.global_

                    if '__all__' in self.global_:

                        # Filter global_ based on __all__.
                        # ================================

                        all = self.global_['__all__']
                        if isinstance(all, (tuple, list)):
                            for name in self.global_.keys():
                                if name in self._keep:
                                    continue
                                if name not in all:
                                    del self.global_[name]

                    else:

                        # Filter global_ based on _ prefix.
                        # =================================

                        for name in self.global_.keys():
                            if name in self._keep:
                                continue
                            if name.startswith('_'):
                                del self.global_[name]

                except SystemExit:
                    pass


    def request(self, request):
        """
        """
        local = {}
        local['request'] = request
        self.__call__('request', local)
        return request


    def response(self, request, response):
        """
        """
        local = {}
        local['request'] = request
        local['response'] = response
        self.__call__('response', local)
        return response


    def exception(self, request):
        """
        """
        local = {}
        local['request'] = request
        local['response'] = response = Response(500)
        self.__call__('exception', local)
        return response


class Website:
    """Represent a website to be published.

    You can extend httpyd's publishing process by putting magically-named
    scripts in the __/etc/filters directory. These scripts will be exec'd within
    a global namespace shared by all of the filter_ scripts and all scripts
    located throughout your site itself.

        filter      objects in global ns     expected action
        ========================================================================
        startup                              populate the global namespace
        request     request                  modify the request object
        exception   request, response        modify the response object
        response    request, response        modify the response object

    All scripts also have the following in their global namespace, which cannot
    be overriden:

        __builtins__    the standard Python built-in modules
        __website__     a reference to this website object
        __file__        the filename of the script being executed

    """

    def __init__(self, paths):
        """Set up the Static responder and filters.
        """
        self.paths = paths
        self.static = Static()
        self.static.root = self.paths.root
        self.static.defaults = ['index.htm', 'index.html', 'index.py']
        self.filters = Filters(self)
        self.filters.startup()
        self.has_exception_filters = self.filters.has_exception_filters()


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """
        if self.has_exception_filters:
            try:
                request = self.filters.request(request)
                response = self.respond_unsafely(request)
            except:
                response = self.filters.exception(request)
                raise response
        else:
            request = self.filters.request(request)
            response = self.respond_unsafely(request)
        return response


    def respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        if request.path.startswith('/__') or ('/.' in request.path):
            raise Response(404)

        fspath = self.static.translate(request.path)
        request.fspath = ''

        if os.path.exists(fspath):
            fspath = request.fspath = self.static.find_default(fspath)
            if os.path.isfile(fspath) and is_executable(fspath):
                response = self.execute(fspath, request)
            else:
                response = self.static.respond(request)
                del response.headers['Content-Length']

        else:

            # Look for a parent script.
            # =========================

            script = None
            parts = request.path.split('/')
            while len(parts) > 0:
                del parts[-1]
                path = self.static.translate('/'.join(parts))
                if os.path.exists(path):
                    path = self.static.find_default(path)
                    if is_executable(path):
                        script = path
                        break

            if script is not None:
                request.fspath = script
                response = self.execute(script, request)
            else:
                raise Response(404)

        return self.filters.response(request, response)


    def execute(self, path, request):
        """Execute a script.
        """

        global_ = self.filters.global_.copy()

        # got unexpected behavior when putting these in local
        global_['request'] = request
        global_['response'] = response = Response()
        global_['__file__'] = path

        code_ = open(path)

        try:
            exec code_ in global_
        except SystemExit:
            pass

        return response
