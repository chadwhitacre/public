import os
import string
import sys
import traceback
from os.path import basename, dirname, exists, isdir, isfile, join

from httpy import mode, Response
from httpy.responders.static import Static


def is_script(path):
    """Given a filesystem path, return a boolean.
    """
    try:
        assert os.path.exists(path)                 # exists
        assert open(path, 'rb').read(2) == '#!'     # hashbang
        assert (os.stat(path).st_mode & 0111) != 0  # executable
        # svn:executable?
        return True
    except AssertionError:
        return False

INITIAL = '_' + string.letters
INNER = INITIAL + string.digits
def is_valid_identifier(s):
    """Given a string of length > 0, return a boolean.

        >>> is_valid_identifier('.svn')
        False
        >>> is_valid_identifier('svn')
        True
        >>> is_valid_identifier('_svn')
        True
        >>> is_valid_identifier('__svn')
        True
        >>> is_valid_identifier('123')
        False
        >>> is_valid_identifier('r123')
        True

    """
    try:
        assert s[0] in INITIAL
        assert False not in [x in INNER for x in s]
        return True
    except AssertionError:
        return False


class Plugin:
    """Represent an individual plugin.
    """

    def __init__(self, root):
        """Takes the filesystem path of this plugin.
        """
        self.name = basename(root)
        self.root = root

        lib = join(root, 'lib')
        if isdir(lib):
            sys.path.insert(0, lib)

        hooks = { 'exception'   : None
                , 'request'     : None
                , 'response'    : None
                , 'startup'     : None
                 }
        for hook in hooks:
            filepath = join(self.root, 'hooks', hook+'.py')
            if is_script(filepath):
                hooks[hook] = compile(open(filepath).read(), filepath, 'exec')
        self.hooks = hooks

    def __str__(self):
        return '<plugin: %s>' % (self.name)
    __repr__ = __str__



class Plugins:
    """Represent the plugins for a Website.
    """

    def __init__(self, root):
        """Takes the filesystem plugins root.
        """
        if isdir(root):
            for name in sorted(os.listdir(root)):
                if is_valid_identifier(name):
                    filepath = join(root, name)
                    if isdir(filepath):
                        setattr(self, name, Plugin(filepath))

    def __str__(self):
        lst = sorted([n for n in self.__dict__ if not n.startswith('_')])
        return '<plugins: %s>' % (', '.join(lst))
    __repr__ = __str__

    def __iter__(self):
        items = sorted(self.__dict__.items())
        return iter([v for k, v in items if not k.startswith('_')])

    def __setattr__(self, name, val):
        if isinstance(val, Plugin):
            if name.startswith('_'):
                raise ValueError("Plugins can't start with underscore.")
        elif (not name.startswith('_')):
            raise ValueError("Public attributes can only be Plugins.")
        self.__dict__[name] = val


class Website:
    """Represent a website for httpyd to publish.

    You can extend instances of this object with magically-named scripts in
    directories under __/pin. Each script is run with 'website' and 'plugin' in
    its local namespace, along with the following:

        hook        objects in local ns      expected action
        ========================================================================
        startup                              populate the global namespace
        request     request                  modify the request object
        exception   request, response        modify the response object
        response    request, response        modify the response object

    All scripts within your site hierarchy will also have this object in their
    namespace, as well as the following:

        __file__        the filename of the script being executed

    """

    def __init__(self, paths):
        """Set up the Static responder and plugins.
        """
        self.paths = paths
        self.paths.pin = join(self.paths.__, 'pin')
        self.plugins = Plugins(self.paths.pin)

        self.__static = Static()
        self.__static.root = self.paths.root
        self.__static.defaults = ['index.htm', 'index.html', 'index.py']

        self.__hooks = self.__load_hooks()
        self.__on_startup()


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """

        if mode.IS_DEVELOPMENT or mode.IS_DEBUGGING:
            self.plugins = Plugins(self.paths.pin)
            self.__hooks = self.__load_hooks()

        try:
            request = self.__on_request(request)
            response = self.__respond_unsafely(request)
        except Response, response:
            pass
        except:
            response = self.__on_exception(request)
            raise response

        return self.__on_response(request, response)


    def __respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        if request.path.startswith('/__'):
            raise Response(404)

        fspath = self.__static.translate(request.path)
        request.fspath = ''

        if exists(fspath):

            # Found a resource; serve it.
            # ===========================

            fspath = request.fspath = self.__static.find_default(fspath)
            if is_script(fspath):
                response = self.__execute(fspath, request)
            else:
                response = self.__static.respond(request)
                del response.headers['Content-Length']

        else:

            # No resource; look for a script to handle the request.
            # =====================================================

            script = None
            parts = request.path.split('/')
            while len(parts) > 0:
                del parts[-1]
                path = self.__static.translate('/'.join(parts))
                if exists(path):
                    path = self.__static.find_default(path)
                    if is_script(path):
                        script = path
                        break

            if script is not None:
                request.fspath = script
                response = self.__execute(script, request)
            else:
                raise Response(404)

        return response


    def __execute(website, __file__, request):
        """Execute a script.
        """
        response = Response()
        try:
            exec open(__file__)
        except SystemExit:
            pass
        return response


    # Plugins
    # =======

    def __load_hooks(self):
        """Return a mapping of hook names to lists of code objects.
        """

        hooks = { 'exception'   : []
                , 'request'     : []
                , 'response'    : []
                , 'startup'     : []
                 }

        # Search all directories under __/etc/pin.
        # ========================================

        for plugin in self.plugins:
            for hook in hooks:
                if plugin.hooks[hook] is not None:
                    hooks[hook].append(plugin)
        hooks['response'].reverse()
        hooks['exception'].reverse()
        return hooks


    # Hooks
    # =====

    def __on_startup(website):
        for plugin in website.__hooks['startup']:
            try:
                exec plugin.hooks['startup']
            except SystemExit:
                pass


    def __on_request(website, request):
        for plugin in website.__hooks['request']:
            try:
                exec plugin.hooks['request']
            except SystemExit:
                pass
        return request


    def __on_response(website, request, response):
        for plugin in website.__hooks['response']:
            try:
                exec plugin.hooks['response']
            except SystemExit:
                pass
        return response


    def __on_exception(website, request):
        response = Response(500)
        if mode.IS_DEBUGGING or mode.IS_DEVELOPMENT:
            response.body = traceback.format_exc()
        for plugin in website.__hooks['exception']:
            try:
                exec plugin.hooks['exception']
            except SystemExit:
                pass
        return response


if __name__ == '__main__':
    import doctest
    doctest.testmod()