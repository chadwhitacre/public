import os
import sys
import traceback
from email import message_from_string

from httpy import Response
from httpy.utils import mode
from httpy.responders.static import Static


def is_executable(path):
    """Given a valid path, return a boolean.
    """
    return (os.stat(path).st_mode & 0111) != 0


class Website:
    """Represent a website to be published.

    You can extend the publishing process by putting scripts in certain
    directories. Executable files in these directories will be execfile'd in
    alphabetical order, with certain mutable items in their namespace. One of
    these items will continue on in the publishing process.

        directory               in                              out
        ================================================================
        __/hooks/request        request                         request
        __/hooks/response       request, response               response
        __/hooks/exception      request, response, exception    response

    """

    def __init__(self, paths):
        """Set up the Static responder and filters.
        """

        self.static = Static()
        self.static.defaults = ['index.htm', 'index.html', 'index.py']


        # Load hooks.
        # ===========

        hook_root = os.path.join(self.static.root, '__', 'hooks')
        hook_categories = [ 'exception'
                          , 'request'
                          , 'response'
                           ]

        self.hooks = {}
        for name in hook_categories:
            self.hooks[name] = []
            path = os.path.join(hook_root, name)
            if os.path.exists(path):
                for filename in sorted(os.listdir(path)):
                    fpath = os.path.realpath(os.path.join(path, filename))
                    if os.path.exists(fpath) and is_executable(fpath):
                        self.hooks[name].append(fpath)


    def respond(self, request):
        """Given a Request, return a response (w/ error handling).
        """
        try:
            request = self.hook('request', request)
            response = self.respond_unsafely(request)
        except Exception, exc:
            response = self.hook('exception', request, Response(), exc)
        return response


    def respond_unsafely(self, request):
        """Given a Request, return a response (w/o error handling).
        """

        filepath = self.static.translate(request.path)

        if os.path.exists(filepath):                        # filesystem
            filepath = self.static.find_default(filepath)
            if is_executable(filepath):                         # script
                response = self.execute(filepath, request, Response())
            else:                                               # other
                response = self.static.respond(request)
                del response.headers['Content-Length']

        else:

            # Look for a parent script.
            # =========================

            script = None
            parts = request.path.split('/')
            while len(parts) > 0:
                del parts[-1]
                path = self.static.translate('/'.join(parts))
                if os.path.exists(path):
                    path = self.static.find_default(path)
                    if is_executable(path):
                        script = path
                        break

            if script is not None:
                response = self.execute(script, request, Response())
            else:
                raise Response(404)


        return self.hook('response', request, response)


    def execute(self, path, request, response=None, exception=None):
        """Given some stuff, return something. :^)

            path -- a valid filesystem path to a Python script.
            request -- a request object
            response -- an optional response object
            exc -- an optional exception

        If you pass in an exception, you must also pass in a response.

        """

        context = {}
        context['request'] = out = request
        if response is not None:
            context['response'] = out = response
        if exception is not None:
            assert response is not None
            if isinstance(exception, Response):
                response = exception
                exception = None
            context['response'] = out = response
            context['exception'] = exception
        try:
            execfile(path, context)
        except SystemExit:
            pass

        return out


    def hook(self, category, *args):
        """Given a hook category and its required args, return something.
        """

        if category == 'request':
            assert len(args) == 1
            out = args[0]
        elif category == 'response':
            assert len(args) == 2
            out = args[1]
        elif category == 'exception':
            assert len(args) == 3
            out = args[1]

        for path in self.hooks[category]:
            if os.path.exists(path) and is_executable(path):
                out = self.execute(path, *args)
        return out
